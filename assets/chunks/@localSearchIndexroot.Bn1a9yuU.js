const t='{"documentCount":284,"nextId":284,"documentIds":{"0":"/#m946i","1":"/toc.html#目录","2":"/笔记/#📒-笔记","3":"/笔记/#m946i","4":"/笔记/JUC/JUC.html#什么是j-u-c","5":"/笔记/JUC/JUC.html#juc是java-util-concurrent包的缩写-包结构如下-说白了就是并发场景进行多线程编程的工具类。","6":"/笔记/JUC/JUC.html#我总结-juc就是在并发场景下-怎么让程序尽量通过有限的硬件-高效的处理请求-并且保证程序-线程安全-而这涉及到的知识非常的庞大。","7":"/笔记/JUC/JUC.html#进程、线程、纤程-协程或虚拟线程","8":"/笔记/JUC/JUC.html#什么是进程","9":"/笔记/JUC/JUC.html#专业说法-在操作系统中-进程是基本的资源分配单位-操作系统通过进程管理计算机的资源-如cpu、内存、磁盘等。每个进程都有一个唯一的进程标识符-pid-用于区分不同的进程。","10":"/笔记/JUC/JUC.html#什么是线程","11":"/笔记/JUC/JUC.html#底层角度-线程是操作系统中的基本执行单元-能够直接执行的最小代码块-它是进程中的一个实体-是cpu调度和分派的基本单位。一个进程可以包含多个线程-每个线程都可以独立执行不同的任务-但它们共享进程的资源。","12":"/笔记/JUC/JUC.html#同一时刻-一个cpu核心只能运行一个线程-也就是cpu内核和同时运行的线程数是1-1的关系-也就是说8核cpu同时可以执行8个线程的代码。","13":"/笔记/JUC/JUC.html#什么是纤程-协程","14":"/笔记/JUC/JUC.html#底层角度","15":"/笔记/JUC/JUC.html#_1-纤程可以在内部创建多个纤程-这些纤程之间可以共享同一个线程资源","16":"/笔记/JUC/JUC.html#_2-纤程是在同一个进程內部运行的-不需要操作系统介入-可以用户空间内实现协作式多任务处理。因此纤程的创建和销毁开销很小-可以更高效地利用系统资源。","17":"/笔记/JUC/JUC.html#通俗角度-通俗地说-如果线程是饭桌-协程就是座椅。","18":"/笔记/JUC/JUC.html#java19才支持虚拟线程-纤程","19":"/笔记/JUC/JUC.html#或者使用第三方协程库quasar-据说这个大神已经入职oracle了-并且正式java的虚拟线程的开发者。","20":"/笔记/JUC/JUC.html#总结","21":"/笔记/JUC/JUC.html#_1-先有进程-然后进程可以创建线程-线程是依附在进程里面的-线程里面可以包含多个协程","22":"/笔记/JUC/JUC.html#_2-进程之间不共享全局变量-纤程之间共享全局变量-但是要注意资源竞争的问题","23":"/笔记/JUC/JUC.html#并行、并发、串行","24":"/笔记/JUC/JUC.html#并发","25":"/笔记/JUC/JUC.html#通俗-并发是多个客户在同一时间段内不约而同来到饭店-但是都想快点上菜-却只有一个厨师-厨师想了个办法-给每一桌上一个菜-然-再-轮流炒第2、3-个菜-达到雨露均沾-不至于后面来的客户闹情绪。","26":"/笔记/JUC/JUC.html#底层-在操作系统中-安装了多个程序-并发的是同一时间段内宏观上有多个程序同时运行-这在单cpu系统中-每一时刻只能有一道程序执行-即见上这些程序是分时的交替运行-只不过是给人的感觉是同时运行-那是因为分时交替运行的时间是非常短的。","27":"/笔记/JUC/JUC.html#并行","28":"/笔记/JUC/JUC.html#通俗-并行是多个客户在同一时刻一起来到饭店-没人愿意排队-好办-饭店有多个厨师-每桌安排一个厨师-高档饭店就是好","29":"/笔记/JUC/JUC.html#底层-在多核cpu系统中-这些同一时刻的程序可以分配到多个处理器上-cpu-实现多任务并行执行-即利用每个处理器来外稗一个可以并发执行的程序-这样多个程序便可以同日丸行。目前电脑市场上说的多核cpu-便是多核处理器-核越多-并行处理的程序越多-能大大是高电脑运行的效率。","30":"/笔记/JUC/JUC.html#串行","31":"/笔记/JUC/JUC.html#通俗-串行就很好理解了-按照客户下单顺序-先到先得-厨师按菜单顺序炒菜。但是后面的客户就要等得比较久了。如果第一个客户吃的是满汉全席后面的客户可能就不想等了。","32":"/笔记/JUC/JUC.html#底层-如单核cpu-同一时刻只能运行一个程序-如果存在多个程-序-需要按照先后顺序执行。我打开qq后-不能再同时打开微信-只能等qq执行完成-关-闭-后才能打开微信-线程的串行亦是如此-一次只能执行一个线程代码指令-其他线程需要排队等待。","33":"/笔记/JUC/JUC.html#综合来说","34":"/笔记/JUC/JUC.html#并发-concurrent-指应用能够交替执行不同的任务比如单cpu核心下执行多线程并非是同时间执行多个任务-如果你开两个线程执行-就是在你几乎不可能察觉到的速度不断去切换这两个任务-已达到-同时执行效果-其实并不是的-只是计算机的速度太快-我们无法察觉到而已。","35":"/笔记/JUC/JUC.html#并行parallel-指应用能够同时执行不同的任务-例-吃饭的时候可以边吃饭边打电话-这两件事情可以同时执行","36":"/笔记/JUC/JUC.html#两者区别-一个是交替执行-一个是同时执行。","37":"/笔记/JUC/JUC.html#cpu核心数和线程的关系","38":"/笔记/JUC/JUC.html#前面说过-目前主流cpu都是多核的-线程是cpu调度的最小单位。同一时刻-一个cpu核心只能运行一个线程-也就是cpu内核和同时运行的线程数是1-1的关系-也就是说8核cpu同时可以执行8个线程的代码。但intel引入超线程技术后-产生了逻辑处理器的概念-使核心数与线程数形成1-2的关系。在我们前面的windows任务管理器贴图就能看出来-内核数是6而逻辑处理器数是12。","39":"/笔记/JUC/JUC.html#在java中提供了runtime-getruntime-avaiiableprocessors-可以让我们获取当前的cpu核心数-汪意这个核心数指的是逻辑处理器数。","40":"/笔记/JUC/JUC.html#获得当前的cpu核心数在并发编程中很重要-并发编程下的性能优化往往和cpu核心数密切相关。","41":"/笔记/JUC/JUC.html#上下文切换-context-switch","42":"/笔记/JUC/JUC.html#由于现在大多计算机都是多核cpu-多线程往往会比单线程更快-更能够提高并发-但提高并发并不意味着启动更多的线程来执行。更多的线程意味着线程创建销毁开销加大、上下文非常频繁-你呈序反而不能支持更高的tps。","43":"/笔记/JUC/JUC.html#时间片","44":"/笔记/JUC/JUC.html#多任务系统往往需要同时执行多道作业。作业数往往大于机器的cpu数-然而一颗cpu同时只能执行一项任务-如何让用户感觉这些任务正在同时进行呢-操作系统的设计者巧妙地利用了时间片轮转的方式","45":"/笔记/JUC/JUC.html#时间片是cpu分配给任务-线程-的时间","46":"/笔记/JUC/JUC.html#总结-1","47":"/笔记/JUC/JUC.html#_1-单核cpu-同一时间-cpu只能处理1个线程-只有1个线程在执行","48":"/笔记/JUC/JUC.html#_2-多线程同时执行-是cpu快速的在多个线程之间的切换","49":"/笔记/JUC/JUC.html#_3-cpu调度线程的时间足够快-就造成了多线程的-同时-执行。","50":"/笔记/JUC/JUC.html#_4-如果线程数非常多-cpu会在n个线程之间切换-消耗大量的cpu资源","51":"/笔记/JUC/JUC.html#_5-每个线程被调度的次数会降低-线程的执行效率降低","52":"/笔记/JUC/JUC.html#创建线程","53":"/笔记/JUC/JUC.html#_1-通过继承thread","54":"/笔记/JUC/JUC.html#_2-通过实现runnable","55":"/笔记/JUC/JUC.html#java线程创建调用关系","56":"/笔记/JUC/JUC.html#start与run","57":"/笔记/JUC/JUC.html#类型","58":"/笔记/JUC/JUC.html#作用","59":"/笔记/JUC/JUC.html#线程数量方面","60":"/笔记/JUC/JUC.html#调用次数","61":"/笔记/JUC/JUC.html#线程的休眠","62":"/笔记/JUC/JUC.html#测试","63":"/笔记/JUC/JUC.html#线程的让步","64":"/笔记/JUC/JUC.html#线程打断","65":"/笔记/JUC/JUC.html#实例方法interrupt-仅仅是设置线程的中断状态为true-不会停止线程。","66":"/笔记/JUC/JUC.html#通过检查中断标志位-判断当前线程是否被中断。","67":"/笔记/JUC/JUC.html#静态方法-判断线程是否被中断-并清除当前中断状态","68":"/笔记/JUC/JUC.html#也即是说这个方法做了两件事","69":"/笔记/JUC/JUC.html#_1、返回当前线程的中断状态","70":"/笔记/JUC/JUC.html#_2、将当前线程的中断状态设为false","71":"/笔记/JUC/JUC.html#线程合并","72":"/笔记/JUC/JUC.html#isalive","73":"/笔记/JUC/JUC.html#守护线程","74":"/笔记/JUC/JUC.html#默认情况下我们创建的线程都是用户线程-普通线程-进程需要等待所有的线程执行完毕后-进程才会结束。","75":"/笔记/JUC/JUC.html#守护线程-setdaemon-true-设置守护线程","76":"/笔记/JUC/JUC.html#想要查看线程到底是用户线程还是守护线程-可盈通过thread-isdeamon-方法来判断-如果返回的结果是true则为守护线程-反之则为用户线程。","77":"/笔记/JUC/JUC.html#当所有的用户线程退出后-守护线程会立马结束。","78":"/笔记/JUC/JUC.html#应用","79":"/笔记/JUC/JUC.html#垃圾回收线程属于守护线程","80":"/笔记/JUC/JUC.html#tomcat用来接受处理外部的请求的线程就是守护线程。","81":"/笔记/JUC/JUC.html#线程的5种状态","82":"/笔记/JUC/JUC.html#线程状态间转换","83":"/笔记/JUC/JUC.html#blocked进入runnable","84":"/笔记/JUC/JUC.html#想要从blocked状态进入runable状态-我们上面说过必须要线程获得monitor锁-但是如果想进入其他状态就相对比较特殊-因为它是没有超时机制的-也就是不会主动进入。","85":"/笔记/JUC/JUC.html#waiting进入runnable","86":"/笔记/JUC/JUC.html#只有当执行了locksupport-unpark-或者join的线程运行结束-或者被中断时可以进入runnable状态。","87":"/笔记/JUC/JUC.html#timed-waiting进入runnable","88":"/笔记/JUC/JUC.html#同样在time-waiting中执行notify-和notifyall-也是一样的道理-它们会先进入blocked状态-然后抢夺锁成功后-再回到runnable状态。","89":"/笔记/JUC/JUC.html#但是对于timed-waiting而言-它存在超时机制-也就是说如果超时时间到了那么就会系统自动直接拿到锁-或者当join的线程执行结束-调用了","90":"/笔记/JUC/JUC.html#locksupport-unpark-被中断等情况都会直接进入runnable状态-而不会经历blocked状态","91":"/笔记/JUC/JUC.html#总结-2","92":"/笔记/JUC/JUC.html#线程的状态是按照箭头方向来走的-比如线程从new状态是不可以直接进入blocked状态的-他需要先经历runnable状态。","93":"/笔记/JUC/JUC.html#线程生命周期不可逆-一旦进入runnable状态就不能回到new状态-一旦被终止就不能再有任何状态的变化。","94":"/笔记/JUC/JUC.html#所以一个线程只能有一次new和terminated状态-只有处于中间状态才可以相互转换。也就是这两个状态不会参与相互转化","95":"/笔记/JUC/JUC.html#callable接口","96":"/笔记/JUC/JUC.html#一般情况下-使用runnable接囗、thread实现的线程我们都是无法返回结果的。但是如果对一些场合需要线程返回的结果。就要使用callable、future这几个类。callable只能executorservice的线程池中跑-但有返回结果-也可以通过返回的future对象查询执行状态。future本身也是一种设计模式-它是用来取得异步任务的结果看看其源码","97":"/笔记/JUC/JUC.html#它只有一个call方法-并且有一个返回v-是范型。可以认为这里返回v就是线程返回的结果。","98":"/笔记/JUC/JUC.html#线程的3种创建方式","99":"/笔记/JUC/JUC.html#java中有三种线程创建方式","100":"/笔记/JUC/JUC.html#_1-实现runnable接口的run方法。","101":"/笔记/JUC/JUC.html#_2-继承thread类并重写run的方法。","102":"/笔记/JUC/JUC.html#_3-使用futuretask方式-实现callable接口的方式-。","103":"/笔记/JUC/JUC.html#三种方式的区别","104":"/笔记/JUC/JUC.html#java中-类仅支持单继承-如果一个类继承了thread类-就无法再继承其它类-因此-如果一个类既要继承其它的类-又必须创建为一个线程-就可以使用runnable接口的方式。","105":"/笔记/JUC/JUC.html#使用实现callable接口的方式创建的线程-可以获取到线程执行的返回值、是否执行完成等信息。","106":"/笔记/JUC/JUC.html#什么是线程池","107":"/笔记/JUC/JUC.html#我们使用线程的时候就去创建一个线程-这样实现起来非常简便-但是就会有一个问题","108":"/笔记/JUC/JUC.html#如果并发的线程数量很多-并且每个线程都是执行一个时间很短的任务就结束了-这样频繁创建线程就会人人降低系统的效率-因为频繁创建线程和销毁线程需要时间。","109":"/笔记/JUC/JUC.html#那么有没有一种办法使得线程可以复用-就是执行完一个任务-井不被销毁-而是可以继续执行其他的任务","110":"/笔记/JUC/JUC.html#在java中可以通过线程池来达到这样的效果。","111":"/笔记/JUC/JUC.html#线程池-其实就是一个容纳多个线程的容器-其中的线程可以反复使用-省去了频繁创建线程对象的操作-无需反复创建线程而消耗过多资源。","112":"/笔记/JUC/JUC.html#为什么用线程池","113":"/笔记/JUC/JUC.html#线程池的优势","114":"/笔记/JUC/JUC.html#线程池做的工作丰要是控制运行的线程数量-处理过程中将任务放入队列-然后在线程创建后启动这些任务-如果线程数量超过了最大数量-超出数量的线程排队等候-等其他线程执行完毕-再从队列中取出任务来执行。","115":"/笔记/JUC/JUC.html#它的主要特点为-线程复用-控制最大并发数-管理线程。","116":"/笔记/JUC/JUC.html#第一-降低资源消耗。-通过重复利用已创建的线程降低线程创建和销毁造成的销耗。","117":"/笔记/JUC/JUC.html#第二-提高响应速度。-当任务到达时-任务可以不需要等待线程创建就能立即执行。","118":"/笔记/JUC/JUC.html#第三-提高线程的可管理性。-线程是稀缺资源-如果无限制的创建-不仅会销耗系统资源-还会降低系统的稳定性-使用线程池可以进行统一的分配-调优和监控","119":"/笔记/JUC/JUC.html#线程池的使用","120":"/笔记/JUC/JUC.html#java里面线程池的顶级接口是java-util-concurrent-executor-但是严格意义上讲executor并不是一个线程池-而只是一个执行的工具。真正的线程池接口是java-util-concurrent-executorservice。要配置一个线程池是比较复杂的-尤其是对于线程池的原理不是很清楚的情况下-很有可能配置的线程池不是较优的-因此再java-util-concurrent-executors线程工厂类里面提供了一些静态工厂-生成一些常用的线程池。官方建议使用executors工厂类来创建线程池对象。","121":"/笔记/JUC/JUC.html#java类库提供了许多静态方法创建一个线程池","122":"/笔记/JUC/JUC.html#a、newfixedthreadpool创建一个固定长度的线程池-当到达线程最大数量时-线程池的规模将不再变化。","123":"/笔记/JUC/JUC.html#b、newcachedthreadpool创建一个可缓存的线程池-如果当前线程池的规模超出了处理需求-将回收空的线程-当需求增加时-会增加线程数量-线程池规模无限制。","124":"/笔记/JUC/JUC.html#c、newsinglethreadpoolexecutor创建一个单线程的executor-确保任务对了-串行执行。","125":"/笔记/JUC/JUC.html#d、newscheduledthreadpool创建一个固定长度的线程池-而且以延续或者定时的方式来执行任务-类似于timer。","126":"/笔记/JUC/JUC.html#线程池的关闭","127":"/笔记/JUC/JUC.html#execute方法和submit方法区别","128":"/笔记/JUC/JUC.html#线程池参数-原理","129":"/笔记/JUC/JUC.html#corepoolsize-核心线程池数量","130":"/笔记/JUC/JUC.html#maximumpoolsize-最大线程数量","131":"/笔记/JUC/JUC.html#keepalivetime-非核心线程的空闲状态的存活时间-数字1","132":"/笔记/JUC/JUC.html#unit-时间单位-天、小时、","133":"/笔记/JUC/JUC.html#workqueue-工作队列-阻塞队列","134":"/笔记/JUC/JUC.html#threadfactory-线程工厂-创建线程","135":"/笔记/JUC/JUC.html#handler-拒绝策略-有以下4种取值","136":"/笔记/JUC/JUC.html#自定义线程池","137":"/笔记/JUC/JUC.html#tomcat线程池和jdk线程池区别","138":"/笔记/JUC/JUC.html#线程池如何创建线程","139":"/笔记/JUC/JUC.html#线程池拒绝策略","140":"/笔记/JUC/JUC.html#线程池淘汰策略","141":"/笔记/JUC/JUC.html#线程池五种状态","142":"/笔记/JUC/JUC.html#线程安全","143":"/笔记/JUC/JUC.html#什么是线程安全","144":"/笔记/JUC/JUC.html#一、原子性","145":"/笔记/JUC/JUC.html#二、可见性","146":"/笔记/JUC/JUC.html#三、有序性","147":"/笔记/JUC/JUC.html#如何解决线程不安全","148":"/笔记/JUC/JUC.html#破坏临界资源","149":"/笔记/JUC/JUC.html#只读","150":"/笔记/JUC/JUC.html#局部变量","151":"/笔记/JUC/JUC.html#threadlocal","152":"/笔记/JUC/JUC.html#threadlocal是什么","153":"/笔记/JUC/JUC.html#threadlocal内存泄漏是怎么回事","154":"/笔记/JUC/JUC.html#inheritablethreadlocal是什么","155":"/笔记/JUC/JUC.html#volatile","156":"/笔记/JUC/JUC.html#jmm内存模型怎么回事","157":"/笔记/JUC/JUC.html#jmm内存模型","158":"/笔记/JUC/JUC.html#jmm数据原子操作","159":"/笔记/JUC/JUC.html#jmm缓存不一致问题","160":"/笔记/JUC/JUC.html#volatile可见性底层实现原理","161":"/笔记/JUC/JUC.html#指令重排与内存屏障","162":"/笔记/JUC/JUC.html#单例模式dcl导致的可见性问题","163":"/笔记/JUC/JUC.html#内存屏障","164":"/笔记/JUC/JUC.html#java规范定义的内存屏障","165":"/笔记/JUC/JUC.html#java规定volatile需要实现的内存屏障","166":"/笔记/JUC/JUC.html#原子类","167":"/笔记/JUC/JUC.html#基本数据类型","168":"/笔记/JUC/JUC.html#atomicinteger","169":"/笔记/JUC/JUC.html#atomicarray","170":"/笔记/JUC/JUC.html#引用类型原子类","171":"/笔记/JUC/JUC.html#升级类型原子类","172":"/笔记/JUC/JUC.html#adder累加器、accumulate积累器","173":"/笔记/JUC/JUC.html#锁","174":"/笔记/JUC/JUC.html#乐观锁和悲观锁","175":"/笔记/JUC/JUC.html#悲观锁","176":"/笔记/JUC/JUC.html#乐观锁","177":"/笔记/JUC/JUC.html#cas","178":"/笔记/JUC/JUC.html#cas是什么","179":"/笔记/JUC/JUC.html#源码分析compareandset-int-expect-int-update","180":"/笔记/JUC/JUC.html#cas底层原理-如果知道-谈谈你对unsafe的理解","181":"/笔记/JUC/JUC.html#cas的缺点","182":"/笔记/JUC/JUC.html#自旋锁-借鉴cas思想","183":"/笔记/JUC/JUC.html#aba问题","184":"/笔记/JUC/JUC.html#wait-sleep的区别","185":"/笔记/JUC/JUC.html#生产者消费者模式","186":"/笔记/JUC/JUC.html#synchronized锁升级","187":"/笔记/JUC/JUC.html#管程-monitor-概念","188":"/笔记/JUC/JUC.html#锁升级","189":"/笔记/JUC/JUC.html#markword","190":"/笔记/JUC/JUC.html#无锁","191":"/笔记/JUC/JUC.html#偏向锁存","192":"/笔记/JUC/JUC.html#可重入锁-又名递归锁","193":"/笔记/JUC/JUC.html#reentrantlock","194":"/笔记/JUC/JUC.html#reentrantlock锁申请等待限时","195":"/笔记/JUC/JUC.html#trylock","196":"/笔记/JUC/JUC.html#reentrantlock获取锁的过程是可以中断的","197":"/笔记/JUC/JUC.html#公平锁和非公平锁","198":"/笔记/JUC/JUC.html#为什么会有公平锁-非公平锁的设计为什么默认非公平","199":"/笔记/JUC/JUC.html#使用公平锁会有什么问题","200":"/笔记/JUC/JUC.html#什么时候用公平-什么时候用非公平","201":"/笔记/JUC/JUC.html#共享锁和排他锁","202":"/笔记/JUC/JUC.html#排他锁","203":"/笔记/JUC/JUC.html#共享锁","204":"/笔记/JUC/JUC.html#synchronized与lock的区别","205":"/🔌 知识库插件列表.html#知识库插件列表","206":"/🔌 知识库插件列表.html#必选","207":"/🔌 知识库插件列表.html#admonition","208":"/🔌 知识库插件列表.html#asciinema-player","209":"/🔌 知识库插件列表.html#obsidian-footnotes-plugin","210":"/🔌 知识库插件列表.html#dataview","211":"/🔌 知识库插件列表.html#可选","212":"/🔌 知识库插件列表.html#obsidian-git","213":"/🔌 知识库插件列表.html#auto-pair-chinese-symbol","214":"/🔌 知识库插件列表.html#file-explorer-note-count","215":"/🔌 知识库插件列表.html#remember-cursor-position","216":"/🔌 知识库插件列表.html#advanced-tables","217":"/笔记/mysql/mysql.html#连接数据库","218":"/笔记/mysql/mysql.html#ddl","219":"/笔记/mysql/mysql.html#dml","220":"/笔记/mysql/mysql.html#dql","221":"/笔记/mysql/mysql.html#dcl","222":"/笔记/mysql/mysql.html#约束","223":"/笔记/mysql/mysql.html#多表关系","224":"/笔记/mysql/mysql.html#多表查询","225":"/笔记/mysql/mysql.html#内连接-交集部分","226":"/笔记/mysql/mysql.html#外连接","227":"/笔记/mysql/mysql.html#自连接","228":"/笔记/mysql/mysql.html#联合查询","229":"/笔记/mysql/mysql.html#子查询-嵌套查询","230":"/笔记/mysql/mysql.html#根据子查询结果不同-分为","231":"/笔记/mysql/mysql.html#标量子查询","232":"/笔记/mysql/mysql.html#列子查询","233":"/笔记/mysql/mysql.html#行子查询","234":"/笔记/mysql/mysql.html#表子查询","235":"/笔记/mysql/mysql.html#事务","236":"/笔记/mysql/mysql.html#事务-是一组操作的集合-它是一个不可分割的工作单位-事务会吧所有的操作作为一个整体一起想系统提交或撤销操作请求-即这些操作要么同时成功-要么同时失败。","237":"/笔记/mysql/mysql.html#事务操作","238":"/笔记/mysql/mysql.html#事务四大特性","239":"/笔记/mysql/mysql.html#并发事务问题","240":"/笔记/mysql/mysql.html#事务隔离级别","241":"/笔记/mysql/mysql.html#存储引擎","242":"/笔记/mysql/mysql.html#存储引擎简介","243":"/笔记/mysql/mysql.html#在创建表时-指定存储引擎","244":"/笔记/mysql/mysql.html#查看当前数据库支持的存储引擎","245":"/笔记/mysql/mysql.html#存储引擎特点","246":"/笔记/mysql/mysql.html#innodb","247":"/笔记/mysql/mysql.html#myisam","248":"/笔记/mysql/mysql.html#memory","249":"/笔记/mysql/mysql.html#存储引擎选择","250":"/笔记/mysql/mysql.html#在选择存储引擎时-应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统-还可以根据实际情况选择多种存储引擎进行组合。","251":"/笔记/mysql/mysql.html#mysql安装-linux版","252":"/笔记/mysql/mysql.html#索引","253":"/笔记/mysql/mysql.html#索引概述","254":"/笔记/mysql/mysql.html#演示","255":"/笔记/mysql/mysql.html#优缺点","256":"/笔记/mysql/mysql.html#索引结构","257":"/笔记/mysql/mysql.html#索引分类","258":"/笔记/mysql/mysql.html#索引语法","259":"/笔记/mysql/mysql.html#sql性能分析","260":"/笔记/mysql/mysql.html#索引使用","261":"/笔记/mysql/mysql.html#索引设计原则","262":"/笔记/mysql/mysql.html#sql优化","263":"/笔记/mysql/mysql.html#视图-存储过程-触发器","264":"/笔记/mysql/mysql.html#视图","265":"/笔记/mysql/mysql.html#存储过程","266":"/笔记/mysql/mysql.html#存储函数","267":"/笔记/mysql/mysql.html#触发器","268":"/笔记/mysql/mysql.html#锁","269":"/笔记/mysql/mysql.html#概述","270":"/笔记/mysql/mysql.html#全局锁","271":"/笔记/mysql/mysql.html#表级锁","272":"/笔记/mysql/mysql.html#行级锁","273":"/笔记/mysql/mysql.html#innodb引擎","274":"/笔记/mysql/mysql.html#逻辑存储结构","275":"/笔记/mysql/mysql.html#架构","276":"/笔记/mysql/mysql.html#内存结构","277":"/笔记/mysql/mysql.html#磁盘结构","278":"/笔记/mysql/mysql.html#后台线程","279":"/笔记/mysql/mysql.html#事务原理","280":"/笔记/mysql/mysql.html#mvcc","281":"/笔记/mysql/mysql.html#mysql管理","282":"/笔记/mysql/mysql.html#系统数据库","283":"/笔记/mysql/mysql.html#常用工具"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[1,1,3],"2":[2,1,1],"3":[1,2,1],"4":[3,1,1],"5":[6,3,1],"6":[8,3,1],"7":[5,1,1],"8":[2,5,1],"9":[11,5,1],"10":[2,5,1],"11":[9,5,1],"12":[6,5,1],"13":[3,5,1],"14":[2,5,1],"15":[3,5,1],"16":[7,5,1],"17":[5,5,1],"18":[3,5,1],"19":[4,5,1],"20":[1,5,1],"21":[5,5,1],"22":[4,5,1],"23":[3,1,1],"24":[1,3,1],"25":[14,3,1],"26":[10,3,1],"27":[1,3,1],"28":[8,3,1],"29":[13,3,1],"30":[1,3,1],"31":[8,3,1],"32":[16,3,1],"33":[2,3,1],"34":[12,3,1],"35":[5,3,1],"36":[4,3,1],"37":[1,1,1],"38":[15,2,1],"39":[6,2,1],"40":[3,2,1],"41":[4,1,1],"42":[8,4,1],"43":[1,4,1],"44":[5,4,1],"45":[4,4,1],"46":[1,4,1],"47":[5,4,1],"48":[3,4,1],"49":[6,4,1],"50":[4,4,1],"51":[3,4,1],"52":[1,1,1],"53":[2,2,1],"54":[2,2,22],"55":[1,2,1],"56":[1,1,1],"57":[1,2,3],"58":[1,2,3],"59":[1,2,3],"60":[1,2,4],"61":[1,1,4],"62":[2,2,22],"63":[1,1,21],"64":[1,1,4],"65":[4,2,4],"66":[3,2,5],"67":[3,2,1],"68":[2,2,1],"69":[2,2,1],"70":[2,2,1],"71":[1,1,1],"72":[1,1,1],"73":[1,1,1],"74":[5,2,1],"75":[4,2,1],"76":[7,2,1],"77":[3,2,1],"78":[2,1,1],"79":[1,3,1],"80":[2,3,1],"81":[1,1,1],"82":[1,1,1],"83":[1,1,1],"84":[6,2,1],"85":[1,1,1],"86":[5,2,1],"87":[2,1,1],"88":[8,3,1],"89":[6,3,1],"90":[4,3,1],"91":[1,1,1],"92":[4,2,1],"93":[4,2,1],"94":[3,2,1],"95":[1,1,1],"96":[12,2,10],"97":[5,2,53],"98":[1,1,1],"99":[2,2,1],"100":[3,2,1],"101":[3,2,1],"102":[4,2,1],"103":[2,1,1],"104":[9,3,1],"105":[4,3,1],"106":[1,1,1],"107":[4,3,1],"108":[5,3,1],"109":[5,3,1],"110":[2,3,1],"111":[6,3,1],"112":[1,1,1],"113":[2,1,1],"114":[8,3,1],"115":[5,3,1],"116":[4,3,1],"117":[5,3,1],"118":[8,3,1],"119":[1,1,1],"120":[16,3,1],"121":[2,3,1],"122":[5,3,1],"123":[8,3,1],"124":[5,3,1],"125":[5,3,1],"126":[1,1,48],"127":[1,1,45],"128":[3,1,1],"129":[2,5,1],"130":[2,5,1],"131":[4,5,1],"132":[5,5,18],"133":[4,5,7],"134":[4,5,1],"135":[4,5,12],"136":[1,1,75],"137":[2,1,15],"138":[2,1,29],"139":[1,1,99],"140":[1,1,192],"141":[1,1,86],"142":[1,1,1],"143":[1,1,31],"144":[2,1,99],"145":[2,1,51],"146":[2,1,104],"147":[1,1,1],"148":[1,1,1],"149":[1,2,2],"150":[1,2,4],"151":[1,1,1],"152":[2,1,79],"153":[2,1,59],"154":[2,1,58],"155":[1,1,42],"156":[1,1,1],"157":[1,1,35],"158":[1,1,27],"159":[1,1,13],"160":[1,1,26],"161":[1,1,37],"162":[1,1,35],"163":[1,1,1],"164":[1,1,19],"165":[1,1,72],"166":[1,1,19],"167":[1,2,26],"168":[1,1,51],"169":[1,1,29],"170":[1,1,33],"171":[1,1,29],"172":[2,1,55],"173":[1,1,1],"174":[1,1,1],"175":[1,2,28],"176":[1,2,32],"177":[1,1,31],"178":[1,1,73],"179":[5,1,22],"180":[3,1,46],"181":[1,1,9],"182":[2,1,28],"183":[1,1,14],"184":[2,1,32],"185":[1,1,1],"186":[1,1,6],"187":[3,1,63],"188":[1,1,21],"189":[1,2,42],"190":[1,2,24],"191":[1,2,108],"192":[3,1,11],"193":[1,1,24],"194":[1,1,16],"195":[1,1,65],"196":[1,1,114],"197":[1,1,38],"198":[2,1,16],"199":[1,1,8],"200":[3,1,7],"201":[1,1,1],"202":[1,1,5],"203":[1,1,17],"204":[1,1,47],"205":[1,1,1],"206":[1,1,9],"207":[1,2,21],"208":[2,2,26],"209":[3,2,21],"210":[1,2,28],"211":[1,1,2],"212":[2,2,17],"213":[4,2,16],"214":[4,2,23],"215":[3,2,22],"216":[2,2,23],"217":[1,1,10],"218":[1,1,63],"219":[1,1,23],"220":[1,1,56],"221":[1,1,128],"222":[1,1,16],"223":[1,1,13],"224":[1,1,1],"225":[3,1,15],"226":[1,1,15],"227":[1,1,13],"228":[1,1,12],"229":[3,1,12],"230":[3,4,9],"231":[1,4,4],"232":[1,4,14],"233":[1,4,6],"234":[1,4,2],"235":[1,1,1],"236":[7,3,1],"237":[1,2,12],"238":[1,2,14],"239":[1,2,14],"240":[1,2,17],"241":[1,1,1],"242":[1,1,1],"243":[2,2,15],"244":[1,2,3],"245":[1,1,1],"246":[1,2,35],"247":[1,2,17],"248":[1,2,14],"249":[1,1,1],"250":[5,2,24],"251":[3,1,23],"252":[1,1,1],"253":[1,2,13],"254":[1,2,1],"255":[1,10,15],"256":[1,2,81],"257":[1,2,44],"258":[1,2,15],"259":[1,2,139],"260":[1,2,131],"261":[1,2,36],"262":[1,1,253],"263":[3,1,1],"264":[1,4,112],"265":[1,4,251],"266":[1,4,26],"267":[1,4,52],"268":[1,1,1],"269":[1,2,27],"270":[1,2,28],"271":[1,2,113],"272":[1,2,111],"273":[1,1,1],"274":[1,2,46],"275":[1,2,36],"276":[1,2,69],"277":[1,2,80],"278":[1,2,44],"279":[1,2,73],"280":[1,2,118],"281":[1,1,1],"282":[1,2,24],"283":[1,2,166]},"averageFieldLength":[2.6302816901408455,2.1021126760563402,20.49295774647888],"storedFields":{"0":{"title":"M946i","titles":[]},"1":{"title":"目录","titles":[]},"2":{"title":"📒 笔记","titles":[]},"3":{"title":"M946i","titles":["📒 笔记"]},"4":{"title":"什么是J.U.C","titles":[]},"5":{"title":"JUC是java.util.concurrent包的缩写，包结构如下，说白了就是并发场景进行多线程编程的工具类。","titles":["什么是J.U.C"]},"6":{"title":"我总结 JUC就是在并发场景下，怎么让程序尽量通过有限的硬件，高效的处理请求，并且保证程序“线程安全”而这涉及到的知识非常的庞大。","titles":["什么是J.U.C"]},"7":{"title":"进程、线程、纤程（协程或虚拟线程）","titles":[]},"8":{"title":"什么是进程？","titles":["进程、线程、纤程（协程或虚拟线程）"]},"9":{"title":"专业说法：在操作系统中，进程是基本的资源分配单位，操作系统通过进程管理计算机的资源，如CPU、内存、磁盘等。每个进程都有一个唯一的进程标识符（PID），用于区分不同的进程。","titles":["进程、线程、纤程（协程或虚拟线程）"]},"10":{"title":"什么是线程？","titles":["进程、线程、纤程（协程或虚拟线程）"]},"11":{"title":"底层角度：线程是操作系统中的基本执行单元（能够直接执行的最小代码块），它是进程中的一个实体，是CPU调度和分派的基本单位。一个进程可以包含多个线程，每个线程都可以独立执行不同的任务，但它们共享进程的资源。","titles":["进程、线程、纤程（协程或虚拟线程）"]},"12":{"title":"同一时刻，一个CPU核心只能运行一个线程，也就是CPU内核和同时运行的线程数是1：1的关系，也就是说8核CPU同时可以执行8个线程的代码。","titles":["进程、线程、纤程（协程或虚拟线程）"]},"13":{"title":"什么是纤程（协程）？","titles":["进程、线程、纤程（协程或虚拟线程）"]},"14":{"title":"底层角度：","titles":["进程、线程、纤程（协程或虚拟线程）"]},"15":{"title":"1.纤程可以在内部创建多个纤程，这些纤程之间可以共享同一个线程资源","titles":["进程、线程、纤程（协程或虚拟线程）"]},"16":{"title":"2.纤程是在同一个进程內部运行的，不需要操作系统介入，可以用户空间内实现协作式多任务处理。因此纤程的创建和销毁开销很小，可以更高效地利用系统资源。","titles":["进程、线程、纤程（协程或虚拟线程）"]},"17":{"title":"通俗角度：通俗地说，如果线程是饭桌，协程就是座椅。","titles":["进程、线程、纤程（协程或虚拟线程）"]},"18":{"title":"Java19才支持虚拟线程（纤程）","titles":["进程、线程、纤程（协程或虚拟线程）"]},"19":{"title":"或者使用第三方协程库quasar（据说这个大神已经入职oracle了，并且正式java的虚拟线程的开发者。）","titles":["进程、线程、纤程（协程或虚拟线程）"]},"20":{"title":"总结","titles":["进程、线程、纤程（协程或虚拟线程）"]},"21":{"title":"1）先有进程，然后进程可以创建线程，线程是依附在进程里面的，线程里面可以包含多个协程","titles":["进程、线程、纤程（协程或虚拟线程）","总结"]},"22":{"title":"2）进程之间不共享全局变量，纤程之间共享全局变量，但是要注意资源竞争的问题","titles":["进程、线程、纤程（协程或虚拟线程）","总结"]},"23":{"title":"并行、并发、串行","titles":[]},"24":{"title":"并发","titles":["并行、并发、串行"]},"25":{"title":"通俗：并发是多个客户在同一时间段内不约而同来到饭店，但是都想快点上菜，却只有一个厨师，厨师想了个办法，给每一桌上一个菜，然 再 轮流炒第2、3....个菜，达到雨露均沾，不至于后面来的客户闹情绪。","titles":["并行、并发、串行","并发"]},"26":{"title":"底层：在操作系统中，安装了多个程序，并发的是同一时间段内宏观上有多个程序同时运行，这在单CPU系统中，每一时刻只能有一道程序执行，即见上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。","titles":["并行、并发、串行","并发"]},"27":{"title":"并行","titles":["并行、并发、串行"]},"28":{"title":"通俗：并行是多个客户在同一时刻一起来到饭店，没人愿意排队，好办！饭店有多个厨师，每桌安排一个厨师，高档饭店就是好！","titles":["并行、并发、串行","并行"]},"29":{"title":"底层：在多核CPU系统中，这些同一时刻的程序可以分配到多个处理器上(CPU)，实现多任务并行执行，即利用每个处理器来外稗一个可以并发执行的程序，这样多个程序便可以同日丸行。目前电脑市场上说的多核CPU,便是多核处理器，核越多，并行处理的程序越多，能大大是高电脑运行的效率。","titles":["并行、并发、串行","并行"]},"30":{"title":"串行","titles":["并行、并发、串行"]},"31":{"title":"通俗：串行就很好理解了，按照客户下单顺序，先到先得，厨师按菜单顺序炒菜。但是后面的客户就要等得比较久了。如果第一个客户吃的是满汉全席后面的客户可能就不想等了。","titles":["并行、并发、串行","串行"]},"32":{"title":"底层：如单核CPU，同一时刻只能运行一个程序，如果存在多个程 序 ，需要按照先后顺序执行。我打开qq后，不能再同时打开微信，只能等qq执行完成（ 关 闭 ）后才能打开微信，线程的串行亦是如此，一次只能执行一个线程代码指令，其他线程需要排队等待。","titles":["并行、并发、串行","串行"]},"33":{"title":"综合来说：","titles":["并行、并发、串行","串行"]},"34":{"title":"并发 Concurrent：指应用能够交替执行不同的任务比如单CPU核心下执行多线程并非是同时间执行多个任务，如果你开两个线程执行，就是在你几乎不可能察觉到的速度不断去切换这两个任务，已达到&quot;同时执行效果&quot;，其实并不是的，只是计算机的速度太快，我们无法察觉到而已。","titles":["并行、并发、串行","串行"]},"35":{"title":"并行Parallel：指应用能够同时执行不同的任务，例：吃饭的时候可以边吃饭边打电话，这两件事情可以同时执行","titles":["并行、并发、串行","串行"]},"36":{"title":"两者区别：一个是交替执行，一个是同时执行。","titles":["并行、并发、串行","串行"]},"37":{"title":"CPU核心数和线程的关系","titles":[]},"38":{"title":"前面说过，目前主流CPU都是多核的，线程是CPU调度的最小单位。同一时刻，一个CPU核心只能运行一个线程，也就是CPU内核和同时运行的线程数是1：1的关系，也就是说8核CPU同时可以执行8个线程的代码。但Intel引入超线程技术后，产生了逻辑处理器的概念，使核心数与线程数形成1：2的关系。在我们前面的Windows任务管理器贴图就能看出来，内核数是6而逻辑处理器数是12。","titles":["CPU核心数和线程的关系","串行"]},"39":{"title":"在Java中提供了Runtime.getRuntime().avaiIableProcessors()，可以让我们获取当前的CPU核心数，汪意这个核心数指的是逻辑处理器数。","titles":["CPU核心数和线程的关系","串行"]},"40":{"title":"获得当前的CPU核心数在并发编程中很重要，并发编程下的性能优化往往和CPU核心数密切相关。","titles":["CPU核心数和线程的关系","串行"]},"41":{"title":"上下文切换（Context switch）","titles":[]},"42":{"title":"由于现在大多计算机都是多核CPU，多线程往往会比单线程更快，更能够提高并发，但提高并发并不意味着启动更多的线程来执行。更多的线程意味着线程创建销毁开销加大、上下文非常频繁，你呈序反而不能支持更高的TPS。","titles":["上下文切换（Context switch）","串行"]},"43":{"title":"时间片","titles":["上下文切换（Context switch）","串行"]},"44":{"title":"多任务系统往往需要同时执行多道作业。作业数往往大于机器的CPU数，然而一颗CPU同时只能执行一项任务，如何让用户感觉这些任务正在同时进行呢？操作系统的设计者巧妙地利用了时间片轮转的方式","titles":["上下文切换（Context switch）","串行"]},"45":{"title":"时间片是CPU分配给任务（线程）的时间！","titles":["上下文切换（Context switch）","串行"]},"46":{"title":"总结","titles":["上下文切换（Context switch）","串行"]},"47":{"title":"1.(单核CPU)同一时间，CPU只能处理1个线程，只有1个线程在执行","titles":["上下文切换（Context switch）","串行"]},"48":{"title":"2.多线程同时执行：是CPU快速的在多个线程之间的切换","titles":["上下文切换（Context switch）","串行"]},"49":{"title":"3.CPU调度线程的时间足够快，就造成了多线程的“同时”执行。","titles":["上下文切换（Context switch）","串行"]},"50":{"title":"4.如果线程数非常多，CPU会在n个线程之间切换，消耗大量的CPU资源","titles":["上下文切换（Context switch）","串行"]},"51":{"title":"5.每个线程被调度的次数会降低，线程的执行效率降低","titles":["上下文切换（Context switch）","串行"]},"52":{"title":"创建线程","titles":[]},"53":{"title":"1.通过继承Thread","titles":["创建线程","串行"]},"54":{"title":"2.通过实现Runnable","titles":["创建线程","串行"]},"55":{"title":"Java线程创建调用关系","titles":["创建线程","串行"]},"56":{"title":"start与run","titles":[]},"57":{"title":"类型","titles":["start与run","串行"]},"58":{"title":"作用","titles":["start与run","串行"]},"59":{"title":"线程数量方面","titles":["start与run","串行"]},"60":{"title":"调用次数","titles":["start与run","串行"]},"61":{"title":"线程的休眠","titles":[]},"62":{"title":"测试：","titles":["线程的休眠","串行"]},"63":{"title":"线程的让步","titles":[]},"64":{"title":"线程打断","titles":[]},"65":{"title":"实例方法interrupt()仅仅是设置线程的中断状态为true，不会停止线程。","titles":["线程打断","串行"]},"66":{"title":"通过检查中断标志位，判断当前线程是否被中断。","titles":["线程打断","串行"]},"67":{"title":"静态方法，判断线程是否被中断，并清除当前中断状态","titles":["线程打断","串行"]},"68":{"title":"也即是说这个方法做了两件事：","titles":["线程打断","串行"]},"69":{"title":"1、返回当前线程的中断状态","titles":["线程打断","串行"]},"70":{"title":"2、将当前线程的中断状态设为false","titles":["线程打断","串行"]},"71":{"title":"线程合并","titles":[]},"72":{"title":"isAlive","titles":[]},"73":{"title":"守护线程","titles":[]},"74":{"title":"默认情况下我们创建的线程都是用户线程（普通线程），进程需要等待所有的线程执行完毕后，进程才会结束。","titles":["守护线程","串行"]},"75":{"title":"守护线程.setDaemon(true):设置守护线程","titles":["守护线程","串行"]},"76":{"title":"想要查看线程到底是用户线程还是守护线程，可盈通过Thread.isDeamon()方法来判断，如果返回的结果是true则为守护线程，反之则为用户线程。","titles":["守护线程","串行"]},"77":{"title":"当所有的用户线程退出后，守护线程会立马结束。","titles":["守护线程","串行"]},"78":{"title":"应用：","titles":["守护线程"]},"79":{"title":"垃圾回收线程属于守护线程","titles":["守护线程","应用："]},"80":{"title":"tomcat用来接受处理外部的请求的线程就是守护线程。","titles":["守护线程","应用："]},"81":{"title":"线程的5种状态","titles":[]},"82":{"title":"线程状态间转换","titles":[]},"83":{"title":"Blocked进入Runnable","titles":["线程状态间转换"]},"84":{"title":"想要从Blocked状态进入Runable状态，我们上面说过必须要线程获得monitor锁，但是如果想进入其他状态就相对比较特殊，因为它是没有超时机制的，也就是不会主动进入。","titles":["线程状态间转换","Blocked进入Runnable"]},"85":{"title":"Waiting进入Runnable","titles":["线程状态间转换"]},"86":{"title":"只有当执行了LockSupport.unpark()，或者join的线程运行结束，或者被中断时可以进入Runnable状态。","titles":["线程状态间转换","Waiting进入Runnable"]},"87":{"title":"Timed Waiting进入Runnable","titles":["线程状态间转换"]},"88":{"title":"同样在Time Waiting中执行notify()和notifyAll()也是一样的道理，它们会先进入Blocked状态，然后抢夺锁成功后，再回到Runnable状态。","titles":["线程状态间转换","Timed Waiting进入Runnable"]},"89":{"title":"但是对于Timed Waiting而言，它存在超时机制，也就是说如果超时时间到了那么就会系统自动直接拿到锁，或者当join的线程执行结束/调用了","titles":["线程状态间转换","Timed Waiting进入Runnable"]},"90":{"title":"LockSupport.unpark()/被中断等情况都会直接进入Runnable状态，而不会经历Blocked状态","titles":["线程状态间转换","Timed Waiting进入Runnable"]},"91":{"title":"总结","titles":["线程状态间转换"]},"92":{"title":"线程的状态是按照箭头方向来走的，比如线程从New状态是不可以直接进入Blocked状态的，他需要先经历Runnable状态。","titles":["线程状态间转换","总结"]},"93":{"title":"线程生命周期不可逆：一旦进入Runnable状态就不能回到New状态；一旦被终止就不能再有任何状态的变化。","titles":["线程状态间转换","总结"]},"94":{"title":"所以一个线程只能有一次New和Terminated状态，只有处于中间状态才可以相互转换。也就是这两个状态不会参与相互转化","titles":["线程状态间转换","总结"]},"95":{"title":"Callable接口","titles":[]},"96":{"title":"一般情况下，使用Runnable接囗、Thread实现的线程我们都是无法返回结果的。但是如果对一些场合需要线程返回的结果。就要使用Callable、Future这几个类。Callable只能ExecutorService的线程池中跑，但有返回结果，也可以通过返回的Future对象查询执行状态。Future本身也是一种设计模式，它是用来取得异步任务的结果看看其源码：","titles":["Callable接口","总结"]},"97":{"title":"它只有一个call方法，并且有一个返回V，是范型。可以认为这里返回V就是线程返回的结果。","titles":["Callable接口","总结"]},"98":{"title":"线程的3种创建方式","titles":[]},"99":{"title":"JAVA中有三种线程创建方式：","titles":["线程的3种创建方式","总结"]},"100":{"title":"（1）实现Runnable接口的run方法。","titles":["线程的3种创建方式","总结"]},"101":{"title":"（2）继承Thread类并重写run的方法。","titles":["线程的3种创建方式","总结"]},"102":{"title":"（3）使用FutureTask方式（实现Callable接口的方式）。","titles":["线程的3种创建方式","总结"]},"103":{"title":"三种方式的区别？","titles":["线程的3种创建方式"]},"104":{"title":"Java中，类仅支持单继承，如果一个类继承了Thread类，就无法再继承其它类，因此，如果一个类既要继承其它的类，又必须创建为一个线程，就可以使用Runnable接口的方式。","titles":["线程的3种创建方式","三种方式的区别？"]},"105":{"title":"使用实现Callable接口的方式创建的线程，可以获取到线程执行的返回值、是否执行完成等信息。","titles":["线程的3种创建方式","三种方式的区别？"]},"106":{"title":"什么是线程池","titles":[]},"107":{"title":"我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：","titles":["什么是线程池","三种方式的区别？"]},"108":{"title":"如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会人人降低系统的效率，因为频繁创建线程和销毁线程需要时间。","titles":["什么是线程池","三种方式的区别？"]},"109":{"title":"那么有没有一种办法使得线程可以复用，就是执行完一个任务，井不被销毁，而是可以继续执行其他的任务？","titles":["什么是线程池","三种方式的区别？"]},"110":{"title":"在Java中可以通过线程池来达到这样的效果。","titles":["什么是线程池","三种方式的区别？"]},"111":{"title":"线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。","titles":["什么是线程池","三种方式的区别？"]},"112":{"title":"为什么用线程池","titles":[]},"113":{"title":"线程池的优势：","titles":["为什么用线程池"]},"114":{"title":"线程池做的工作丰要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。","titles":["为什么用线程池","线程池的优势："]},"115":{"title":"它的主要特点为：线程复用；控制最大并发数；管理线程。","titles":["为什么用线程池","线程池的优势："]},"116":{"title":"第一：*降低资源消耗。*通过重复利用已创建的线程降低线程创建和销毁造成的销耗。","titles":["为什么用线程池","线程池的优势："]},"117":{"title":"第二：*提高响应速度。*当任务到达时，任务可以不需要等待线程创建就能立即执行。","titles":["为什么用线程池","线程池的优势："]},"118":{"title":"第三：*提高线程的可管理性。*线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控","titles":["为什么用线程池","线程池的优势："]},"119":{"title":"线程池的使用","titles":[]},"120":{"title":"Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行的工具。真正的线程池接口是java.util.concurrent.ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此再java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工厂类来创建线程池对象。","titles":["线程池的使用","线程池的优势："]},"121":{"title":"Java类库提供了许多静态方法创建一个线程池：","titles":["线程池的使用","线程池的优势："]},"122":{"title":"a、newFixedThreadPool创建一个固定长度的线程池，当到达线程最大数量时，线程池的规模将不再变化。","titles":["线程池的使用","线程池的优势："]},"123":{"title":"b、newCachedThreadPool创建一个可缓存的线程池，如果当前线程池的规模超出了处理需求，将回收空的线程；当需求增加时，会增加线程数量；线程池规模无限制。","titles":["线程池的使用","线程池的优势："]},"124":{"title":"c、newSingleThreadPoolExecutor创建一个单线程的Executor，确保任务对了，串行执行。","titles":["线程池的使用","线程池的优势："]},"125":{"title":"d、newScheduledThreadPool创建一个固定长度的线程池，而且以延续或者定时的方式来执行任务，类似于Timer。","titles":["线程池的使用","线程池的优势："]},"126":{"title":"线程池的关闭","titles":[]},"127":{"title":"execute方法和submit方法区别","titles":[]},"128":{"title":"线程池参数&amp;原理","titles":[]},"129":{"title":"corePoolSize：核心线程池数量","titles":["线程池参数&amp;原理","线程池的优势："]},"130":{"title":"maximumPoolSize：最大线程数量","titles":["线程池参数&amp;原理","线程池的优势："]},"131":{"title":"keepAliveTime：非核心线程的空闲状态的存活时间（数字1）","titles":["线程池参数&amp;原理","线程池的优势："]},"132":{"title":"unit：时间单位（天、小时、...）","titles":["线程池参数&amp;原理","线程池的优势："]},"133":{"title":"workQueue：工作队列（阻塞队列）","titles":["线程池参数&amp;原理","线程池的优势："]},"134":{"title":"threadFactory：线程工厂（创建线程）","titles":["线程池参数&amp;原理","线程池的优势："]},"135":{"title":"handler：拒绝策略，有以下4种取值：","titles":["线程池参数&amp;原理","线程池的优势："]},"136":{"title":"自定义线程池","titles":[]},"137":{"title":"tomcat线程池和jdk线程池区别？","titles":[]},"138":{"title":"线程池如何创建线程？","titles":[]},"139":{"title":"线程池拒绝策略","titles":[]},"140":{"title":"线程池淘汰策略","titles":[]},"141":{"title":"线程池五种状态","titles":[]},"142":{"title":"线程安全","titles":[]},"143":{"title":"什么是线程安全","titles":["线程安全"]},"144":{"title":"一、原子性","titles":["线程安全"]},"145":{"title":"二、可见性","titles":["线程安全"]},"146":{"title":"三、有序性","titles":["线程安全"]},"147":{"title":"如何解决线程不安全","titles":[]},"148":{"title":"破坏临界资源","titles":["如何解决线程不安全"]},"149":{"title":"只读","titles":["如何解决线程不安全","破坏临界资源"]},"150":{"title":"局部变量","titles":["如何解决线程不安全","破坏临界资源"]},"151":{"title":"ThreadLocal","titles":[]},"152":{"title":"ThreadLocal是什么？","titles":["ThreadLocal"]},"153":{"title":"ThreadLocal内存泄漏是怎么回事？","titles":[]},"154":{"title":"InheritableThreadLocal是什么？","titles":[]},"155":{"title":"volatile","titles":[]},"156":{"title":"JMM内存模型怎么回事","titles":[]},"157":{"title":"JMM内存模型","titles":["JMM内存模型怎么回事"]},"158":{"title":"JMM数据原子操作","titles":[]},"159":{"title":"JMM缓存不一致问题","titles":[]},"160":{"title":"Volatile可见性底层实现原理","titles":[]},"161":{"title":"指令重排与内存屏障","titles":[]},"162":{"title":"单例模式DCL导致的可见性问题","titles":[]},"163":{"title":"内存屏障","titles":[]},"164":{"title":"Java规范定义的内存屏障","titles":["内存屏障"]},"165":{"title":"Java规定volatile需要实现的内存屏障","titles":["内存屏障"]},"166":{"title":"原子类","titles":[]},"167":{"title":"基本数据类型","titles":["原子类","Java规定volatile需要实现的内存屏障"]},"168":{"title":"AtomicInteger","titles":[]},"169":{"title":"AtomicArray","titles":[]},"170":{"title":"引用类型原子类","titles":[]},"171":{"title":"升级类型原子类","titles":[]},"172":{"title":"Adder累加器、Accumulate积累器","titles":[]},"173":{"title":"锁","titles":[]},"174":{"title":"乐观锁和悲观锁","titles":["锁"]},"175":{"title":"悲观锁","titles":["锁","乐观锁和悲观锁"]},"176":{"title":"乐观锁","titles":["锁","乐观锁和悲观锁"]},"177":{"title":"CAS","titles":[]},"178":{"title":"cas是什么","titles":["CAS"]},"179":{"title":"源码分析compareAndSet(int expect,int update)","titles":["CAS"]},"180":{"title":"CAS底层原理？如果知道，谈谈你对Unsafe的理解","titles":["CAS"]},"181":{"title":"CAS的缺点","titles":["CAS"]},"182":{"title":"自旋锁，借鉴CAS思想","titles":[]},"183":{"title":"ABA问题","titles":[]},"184":{"title":"wait/sleep的区别","titles":[]},"185":{"title":"生产者消费者模式","titles":[]},"186":{"title":"synchronized锁升级","titles":[]},"187":{"title":"管程（Monitor）概念","titles":["synchronized锁升级"]},"188":{"title":"锁升级","titles":["synchronized锁升级"]},"189":{"title":"markWord","titles":["synchronized锁升级","锁升级"]},"190":{"title":"无锁","titles":["synchronized锁升级","锁升级"]},"191":{"title":"偏向锁存","titles":["synchronized锁升级","锁升级"]},"192":{"title":"可重入锁（又名递归锁）","titles":[]},"193":{"title":"ReentrantLock","titles":[]},"194":{"title":"ReentrantLock锁申请等待限时","titles":["ReentrantLock"]},"195":{"title":"tryLock","titles":[]},"196":{"title":"ReentrantLock获取锁的过程是可以中断的","titles":[]},"197":{"title":"公平锁和非公平锁","titles":[]},"198":{"title":"为什么会有公平锁/非公平锁的设计为什么默认非公平","titles":["公平锁和非公平锁"]},"199":{"title":"使用公平锁会有什么问题","titles":["公平锁和非公平锁"]},"200":{"title":"什么时候用公平？什么时候用非公平？","titles":["公平锁和非公平锁"]},"201":{"title":"共享锁和排他锁","titles":[]},"202":{"title":"排他锁","titles":["共享锁和排他锁"]},"203":{"title":"共享锁","titles":["共享锁和排他锁"]},"204":{"title":"synchronized与Lock的区别","titles":[]},"205":{"title":"知识库插件列表","titles":[]},"206":{"title":"必选","titles":["知识库插件列表"]},"207":{"title":"Admonition","titles":["知识库插件列表","必选"]},"208":{"title":"Asciinema Player","titles":["知识库插件列表","必选"]},"209":{"title":"Obsidian Footnotes Plugin","titles":["知识库插件列表","必选"]},"210":{"title":"Dataview","titles":["知识库插件列表","必选"]},"211":{"title":"可选","titles":["知识库插件列表"]},"212":{"title":"Obsidian Git","titles":["知识库插件列表","可选"]},"213":{"title":"Auto Pair Chinese Symbol","titles":["知识库插件列表","可选"]},"214":{"title":"File Explorer Note Count","titles":["知识库插件列表","可选"]},"215":{"title":"Remember Cursor Position","titles":["知识库插件列表","可选"]},"216":{"title":"Advanced Tables","titles":["知识库插件列表","可选"]},"217":{"title":"连接数据库","titles":[]},"218":{"title":"DDL","titles":["连接数据库"]},"219":{"title":"DML","titles":["连接数据库"]},"220":{"title":"DQL","titles":["连接数据库"]},"221":{"title":"DCL","titles":["连接数据库"]},"222":{"title":"约束","titles":["连接数据库"]},"223":{"title":"多表关系","titles":["连接数据库"]},"224":{"title":"多表查询","titles":["连接数据库"]},"225":{"title":"内连接 [交集部分]","titles":["连接数据库"]},"226":{"title":"外连接","titles":["连接数据库"]},"227":{"title":"自连接","titles":["连接数据库"]},"228":{"title":"联合查询","titles":["连接数据库"]},"229":{"title":"子查询 [嵌套查询]","titles":["连接数据库"]},"230":{"title":"根据子查询结果不同，分为:","titles":["连接数据库","子查询 [嵌套查询]"]},"231":{"title":"标量子查询","titles":["连接数据库","子查询 [嵌套查询]"]},"232":{"title":"列子查询","titles":["连接数据库","子查询 [嵌套查询]"]},"233":{"title":"行子查询","titles":["连接数据库","子查询 [嵌套查询]"]},"234":{"title":"表子查询","titles":["连接数据库","子查询 [嵌套查询]"]},"235":{"title":"事务","titles":["连接数据库"]},"236":{"title":"事务 是一组操作的集合，它是一个不可分割的工作单位，事务会吧所有的操作作为一个整体一起想系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。","titles":["连接数据库","事务","表子查询"]},"237":{"title":"事务操作","titles":["连接数据库","事务"]},"238":{"title":"事务四大特性","titles":["连接数据库","事务"]},"239":{"title":"并发事务问题","titles":["连接数据库","事务"]},"240":{"title":"事务隔离级别","titles":["连接数据库","事务"]},"241":{"title":"存储引擎","titles":["连接数据库"]},"242":{"title":"存储引擎简介","titles":["连接数据库"]},"243":{"title":"在创建表时，指定存储引擎","titles":["连接数据库","存储引擎简介"]},"244":{"title":"查看当前数据库支持的存储引擎","titles":["连接数据库","存储引擎简介"]},"245":{"title":"存储引擎特点","titles":["连接数据库"]},"246":{"title":"InnoDB","titles":["连接数据库","存储引擎特点"]},"247":{"title":"MyISAM","titles":["连接数据库","存储引擎特点"]},"248":{"title":"Memory","titles":["连接数据库","存储引擎特点"]},"249":{"title":"存储引擎选择","titles":["连接数据库"]},"250":{"title":"在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。","titles":["连接数据库","存储引擎选择"]},"251":{"title":"MySQL安装(linux版)","titles":["连接数据库"]},"252":{"title":"索引","titles":["连接数据库"]},"253":{"title":"索引概述","titles":["连接数据库","索引"]},"254":{"title":"演示","titles":["连接数据库","索引"]},"255":{"title":"优缺点","titles":["连接数据库","索引","演示","事务 是一组操作的集合，它是一个不可分割的工作单位，事务会吧所有的操作作为一个整体一起想系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。"]},"256":{"title":"索引结构","titles":["连接数据库","索引"]},"257":{"title":"索引分类","titles":["连接数据库","索引"]},"258":{"title":"索引语法","titles":["连接数据库","索引"]},"259":{"title":"SQL性能分析","titles":["连接数据库","索引"]},"260":{"title":"索引使用","titles":["连接数据库","索引"]},"261":{"title":"索引设计原则","titles":["连接数据库","索引"]},"262":{"title":"SQL优化","titles":["连接数据库"]},"263":{"title":"视图/存储过程/触发器","titles":["连接数据库"]},"264":{"title":"视图","titles":["连接数据库","视图/存储过程/触发器"]},"265":{"title":"存储过程","titles":["连接数据库","视图/存储过程/触发器"]},"266":{"title":"存储函数","titles":["连接数据库","视图/存储过程/触发器"]},"267":{"title":"触发器","titles":["连接数据库","视图/存储过程/触发器"]},"268":{"title":"锁","titles":["连接数据库"]},"269":{"title":"概述","titles":["连接数据库","锁"]},"270":{"title":"全局锁","titles":["连接数据库","锁"]},"271":{"title":"表级锁","titles":["连接数据库","锁"]},"272":{"title":"行级锁","titles":["连接数据库","锁"]},"273":{"title":"InnoDB引擎","titles":["连接数据库"]},"274":{"title":"逻辑存储结构","titles":["连接数据库","InnoDB引擎"]},"275":{"title":"架构","titles":["连接数据库","InnoDB引擎"]},"276":{"title":"内存结构","titles":["连接数据库","InnoDB引擎"]},"277":{"title":"磁盘结构","titles":["连接数据库","InnoDB引擎"]},"278":{"title":"后台线程","titles":["连接数据库","InnoDB引擎"]},"279":{"title":"事务原理","titles":["连接数据库","InnoDB引擎"]},"280":{"title":"MVCC","titles":["连接数据库","InnoDB引擎"]},"281":{"title":"MySQL管理","titles":["连接数据库"]},"282":{"title":"系统数据库","titles":["连接数据库","MySQL管理"]},"283":{"title":"常用工具","titles":["连接数据库","MySQL管理"]}},"dirtCount":0,"index":[["连接选项",{"2":{"283":1}}],["连接数据库",{"0":{"217":1},"1":{"218":1,"219":1,"220":1,"221":1,"222":1,"223":1,"224":1,"225":1,"226":1,"227":1,"228":1,"229":1,"230":1,"231":1,"232":1,"233":1,"234":1,"235":1,"236":1,"237":1,"238":1,"239":1,"240":1,"241":1,"242":1,"243":1,"244":1,"245":1,"246":1,"247":1,"248":1,"249":1,"250":1,"251":1,"252":1,"253":1,"254":1,"255":1,"256":1,"257":1,"258":1,"259":1,"260":1,"261":1,"262":1,"263":1,"264":1,"265":1,"266":1,"267":1,"268":1,"269":1,"270":1,"271":1,"272":1,"273":1,"274":1,"275":1,"276":1,"277":1,"278":1,"279":1,"280":1,"281":1,"282":1,"283":1}}],["备份内容包含创建表",{"2":{"283":1}}],["备注",{"2":{"265":1}}],["省略掉一些信息",{"2":{"283":1}}],["省去了频繁创建线程对象的操作",{"0":{"111":1}}],["忽略掉的日志中qiann行命令",{"2":{"283":1}}],["示例",{"2":{"283":3}}],["选项",{"2":{"283":3}}],["选择使用auto",{"2":{"262":1}}],["权限等",{"2":{"282":1}}],["权限名",{"2":{"221":2}}],["仅在事务中第一次执行快照读时生成readview",{"2":{"280":1}}],["仅仅返回2000000",{"2":{"262":1}}],["仅仅是设置线程的中断状态为true",{"0":{"65":1}}],["成立",{"2":{"280":4}}],["版本链数据访问规则",{"2":{"280":1}}],["预分配事务id",{"2":{"280":1}}],["预期原值及更新值",{"2":{"178":1}}],["链表尾部是最早的旧记录",{"2":{"280":1}}],["链表的头部是最新的旧记录",{"2":{"280":1}}],["链接之间切换",{"2":{"215":1}}],["隐藏主键",{"2":{"280":1}}],["隐藏的字段",{"2":{"280":1}}],["隐式内连接",{"2":{"225":1}}],["快照读为mysql实现mvcc提供了一个非阻塞读功能",{"2":{"280":1}}],["快照读会退化为当前读",{"2":{"280":1}}],["快照读",{"2":{"280":2}}],["快速定位特定数据",{"2":{"257":1}}],["快速匹配文档的方式",{"2":{"256":1}}],["快速创建脚注",{"2":{"209":1}}],["条记录时",{"2":{"279":1}}],["条件处理程序",{"2":{"265":2}}],["条件2",{"2":{"265":1}}],["条件1",{"2":{"265":1}}],["条件>",{"2":{"260":3}}],["条件查询",{"2":{"220":1}}],["条件列表",{"2":{"220":2,"225":1}}],["条件",{"2":{"219":2,"220":1,"225":1,"226":2,"227":1,"259":1,"265":1}}],["记录并维护系统当前活跃的事务",{"2":{"280":1}}],["记录插入这条记录或最后一次修改记录的事务id",{"2":{"280":1}}],["记录中的隐藏字段",{"2":{"280":1}}],["记录的是事务提交时数据页的物理修改",{"2":{"279":1}}],["记录慢查询日志",{"2":{"259":1}}],["特性",{"2":{"279":1}}],["特点",{"2":{"246":1,"247":1,"248":1,"257":2,"265":1,"270":1}}],["协助master",{"2":{"278":1}}],["协程就是座椅",{"0":{"17":1}}],["协程",{"0":{"13":1}}],["协程或虚拟线程",{"0":{"7":1},"1":{"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1}}],["负责将写缓冲区内容刷新到磁盘",{"2":{"278":1}}],["负责将日志缓冲刷新到磁盘",{"2":{"278":1}}],["负责写操作",{"2":{"278":1}}],["负责读操作",{"2":{"278":1}}],["负责调度其他线程",{"2":{"278":1}}],["职责",{"2":{"278":1}}],["合并插入缓存",{"2":{"278":1}}],["合并页的阈值",{"2":{"262":1}}],["涉及两个文件",{"2":{"277":1}}],["便于系统异常时恢复数据",{"2":{"277":1}}],["便是多核处理器",{"0":{"29":1}}],["双写缓冲区",{"2":{"277":1}}],["双重检测锁dcl对象半初始化问题",{"2":{"161":1}}],["初始大小16m",{"2":{"277":1}}],["初始化",{"2":{"154":1}}],["初始化变量和获取第一个任务",{"2":{"140":1}}],["撤销表空间",{"2":{"277":1}}],["撤销权限",{"2":{"221":1}}],["磁盘结构",{"0":{"277":1}}],["磁盘等",{"0":{"9":1}}],["日志在每次事务提交写入",{"2":{"276":1}}],["日志在每次事务提交时写入并刷新到磁盘",{"2":{"276":1}}],["日志刷新到磁盘时机",{"2":{"276":1}}],["日志缓冲区的日志会定期刷新到磁盘中",{"2":{"276":1}}],["日志缓冲区",{"2":{"276":1}}],["日志记录",{"2":{"267":1}}],["称之为自适应hash索引",{"2":{"276":1}}],["称之为不可重复读",{"2":{"239":1}}],["脏页",{"2":{"275":1}}],["脏读",{"2":{"239":1}}],["未提交的",{"2":{"280":1}}],["未被使用",{"2":{"275":1}}],["未能获取到锁",{"2":{"195":1}}],["空闲page",{"2":{"275":1}}],["空间索引是myisam引擎的一个特殊索引类型",{"2":{"256":1}}],["空间索引",{"2":{"256":1}}],["里面可以缓存磁盘上经常操作的真实数据",{"2":{"275":1}}],["缓冲区大小innodb",{"2":{"276":1}}],["缓冲池以page页为单位",{"2":{"275":1}}],["缓冲池是主内存中的一个区域",{"2":{"275":1}}],["缓存行锁定",{"2":{"160":1}}],["缓存锁的核心机制时基于缓存一致性协议来实现的",{"2":{"159":1}}],["缓存加锁",{"2":{"159":1}}],["缓存一致性协议",{"2":{"159":1}}],["缓存还分为一级",{"2":{"145":1}}],["缓存",{"2":{"145":3}}],["下面是innodb架构图",{"2":{"275":1}}],["架构",{"0":{"275":1}}],["都生成一个快照读",{"2":{"280":1}}],["都是一种当前读",{"2":{"280":1}}],["都会把旧的版本写入到undo日志中",{"2":{"274":1}}],["都会把对应的事务id赋值给trx",{"2":{"274":1}}],["都互斥",{"2":{"271":1}}],["回滚指针",{"2":{"280":1}}],["回滚日志",{"2":{"279":1}}],["回滚段",{"2":{"274":1}}],["回滚事务",{"2":{"237":1}}],["段用来管理多个extent",{"2":{"274":1}}],["段",{"2":{"274":1}}],["逻辑存储结构",{"0":{"274":1}}],["普通索弓l",{"2":{"272":1}}],["普通线程",{"0":{"74":1}}],["正常",{"2":{"272":1}}],["正例",{"2":{"162":1}}],["冲突",{"2":{"272":3}}],["请求锁类型",{"2":{"272":1}}],["请在创建表时使用not",{"2":{"261":1}}],["阻止其他事务获得相同数据集的共享锁和排他锁",{"2":{"272":1}}],["阻止其他事务获得相同数据集的排它锁",{"2":{"272":1}}],["阻塞式获取任务",{"2":{"140":1}}],["阻塞11",{"2":{"136":2}}],["阻塞队列为空并且线程池中执行的任务也为空时",{"2":{"141":1}}],["阻塞队列",{"0":{"133":1},"2":{"136":1}}],["临键锁",{"2":{"272":2}}],["临界区代码",{"2":{"187":1}}],["临界资源",{"2":{"143":1}}],["产生幻读",{"2":{"272":1}}],["产生了逻辑处理器的概念",{"0":{"38":1}}],["间隙锁可以共存",{"2":{"272":1}}],["间隙锁唯一目的是防止其他事务插入间隙",{"2":{"272":1}}],["间隙锁",{"2":{"272":2}}],["及插入表的sql语句",{"2":{"283":1}}],["及行数",{"2":{"283":1}}],["及排他锁",{"2":{"271":1}}],["及放弃当前拥有的cpu资源",{"2":{"63":1}}],["互斥",{"2":{"271":1}}],["兼容",{"2":{"271":1,"272":1}}],["与聚集索引不同",{"2":{"276":1}}],["与表锁排它锁",{"2":{"271":1}}],["与表锁共享锁",{"2":{"271":2}}],["与其他的mdl都互斥",{"2":{"271":1}}],["与exclusive互斥",{"2":{"271":2}}],["与shared",{"2":{"271":2}}],["与any等同",{"2":{"232":1}}],["元数据项",{"2":{"271":1}}],["元数据锁",{"2":{"271":1}}],["客户端断开连接",{"2":{"271":1}}],["客户端连接服务端时",{"2":{"262":1}}],["意向排他锁",{"2":{"271":2}}],["意向共享锁",{"2":{"271":2}}],["意向锁之间不会互斥",{"2":{"271":1}}],["意向锁",{"2":{"271":2}}],["意味着在多线程环境下不会出现数据竞争等问题",{"2":{"180":1}}],["存放在前面介绍的rollback",{"2":{"279":1}}],["存在以下问题",{"2":{"270":1}}],["存储mysql服务器正常运行所需的各种信息",{"2":{"282":1}}],["存储用户创建的临时表等数据",{"2":{"277":1}}],["存储函数名称",{"2":{"266":1}}],["存储函数的参数只能是in类型的",{"2":{"266":1}}],["存储函数有返回值的存储过程",{"2":{"266":1}}],["存储函数",{"0":{"266":1}}],["存储过程名称",{"2":{"265":4}}],["存储过程思想上很简单",{"2":{"265":1}}],["存储过程是事先经过编译并存储在数据库中的一段sql语句的集合",{"2":{"265":1}}],["存储过程",{"0":{"263":1,"265":1},"1":{"264":1,"265":1,"266":1,"267":1}}],["存储索引",{"2":{"247":1}}],["存储数据",{"2":{"247":1}}],["存储表结构信息",{"2":{"247":1,"248":1}}],["存储该表的表结构",{"2":{"246":1}}],["存储引擎支持",{"2":{"256":1}}],["存储引擎选择",{"0":{"249":1},"1":{"250":1}}],["存储引擎特点",{"0":{"245":1},"1":{"246":1,"247":1,"248":1}}],["存储引擎简介",{"0":{"242":1},"1":{"243":1,"244":1}}],["存储引擎",{"0":{"241":1}}],["存储",{"2":{"158":1}}],["全称multi",{"2":{"280":1}}],["全局锁就是对整个数据库例加锁",{"2":{"270":1}}],["全局锁",{"0":{"270":1},"2":{"269":1}}],["全文索引查找的是文本中的关键字",{"2":{"257":1}}],["全文索引",{"2":{"256":1,"257":1}}],["除传统的计算资源",{"2":{"269":1}}],["除了高度竞争的情况",{"2":{"166":1}}],["概述",{"0":{"269":1}}],["概念",{"0":{"187":1}}],["现在触发器还只支持行级触发",{"2":{"267":1}}],["现在有一个java类t",{"2":{"189":1}}],["现在有一个变量var",{"2":{"145":1}}],["服务器错误消息参考",{"2":{"265":1}}],["服务层直接按行进行累加",{"2":{"262":1}}],["服务层对于返回的每一行",{"2":{"262":1}}],["服务层判断是否为null",{"2":{"262":1}}],["服务层拿到主键后",{"2":{"262":1}}],["打开游标",{"2":{"265":1}}],["声名游标",{"2":{"265":1}}],["声明",{"2":{"265":1}}],["游标名称",{"2":{"265":4}}],["游标的使用包括游标的声明",{"2":{"265":1}}],["游标",{"2":{"265":2}}],["退出指定标记的循环体",{"2":{"265":1}}],["退出循环",{"2":{"265":1}}],["配合循环使用",{"2":{"265":1}}],["配置完毕之后",{"2":{"259":1}}],["访问之前",{"2":{"265":1}}],["访问速度快",{"2":{"247":1,"250":1}}],["设定系统变量",{"2":{"265":1}}],["设置全局参数local",{"2":{"262":1}}],["设置慢日志的时间为2秒",{"2":{"259":1}}],["设置密码长度",{"2":{"251":1}}],["设置密码等级",{"2":{"251":1}}],["设置事务隔离级别",{"2":{"240":1}}],["设置事务提交方式",{"2":{"237":1}}],["设置别名",{"2":{"220":1}}],["设置对象头",{"2":{"180":1}}],["设置xushu的年龄是10岁",{"2":{"171":1}}],["设置最小值为1",{"2":{"140":1}}],["设置守护线程",{"0":{"75":1}}],["属于服务器层面",{"2":{"265":1}}],["系统数据库",{"0":{"282":1}}],["系统表空间是更改缓冲区的存储区域",{"2":{"277":1}}],["系统变量名=值",{"2":{"265":2}}],["系统变量名",{"2":{"265":1}}],["系统变量",{"2":{"265":1}}],["系统只是会从这个锁的等待队列中随机挑选一个",{"2":{"197":1}}],["名称",{"2":{"265":1}}],["复用",{"2":{"265":1}}],["封装",{"2":{"265":1}}],["安全",{"2":{"264":1}}],["安装了多个程序",{"0":{"26":1}}],["列名列表",{"2":{"264":3}}],["列子查询",{"0":{"232":1},"2":{"230":1}}],["触发并执行触发器中定义的sql语句集合",{"2":{"267":1}}],["触发器类型",{"2":{"267":1}}],["触发器的这种特性可以协助应用在数据库端确保数据的完整性",{"2":{"267":1}}],["触发器是与表有关的数据库对象",{"2":{"267":1}}],["触发器",{"0":{"263":1,"267":1},"1":{"264":1,"265":1,"266":1,"267":1}}],["触发interruptedexception异常之后",{"2":{"196":1}}],["视图可帮助用户屏蔽真实表结构变化带来的影响",{"2":{"264":1}}],["视图不仅可以简化用户对数据的理解",{"2":{"264":1}}],["视图中的行与基础表中的行之间必须存在一对一的关系",{"2":{"264":1}}],["视图中的数据并不在数据库中实际存在",{"2":{"264":1}}],["视图的更新",{"2":{"264":1}}],["视图的检查选项",{"2":{"264":1}}],["视图名称",{"2":{"264":6}}],["视图只保存了查询的sql逻辑",{"2":{"264":1}}],["视图",{"0":{"263":1,"264":1},"1":{"264":1,"265":1,"266":1,"267":1},"2":{"264":1}}],["放一个数字",{"2":{"262":1}}],["放到代码块中",{"2":{"204":1}}],["计数累加",{"2":{"262":1}}],["计算机为了最大限度的发挥机器性能",{"2":{"161":1}}],["计算完成后结果值为b",{"2":{"144":1}}],["把每一行的主键id值取出来",{"2":{"262":1}}],["把b刷到内存之前先比较a是否和内存中变量一致",{"2":{"144":1}}],["累计值就加1",{"2":{"262":1}}],["满足条件后",{"2":{"265":1}}],["满足条件的数据行",{"2":{"262":1}}],["满足业务需求的情况下",{"2":{"262":1}}],["业务基本上就得停摆",{"2":{"270":1}}],["业务操作时",{"2":{"262":1}}],["业务逻辑",{"2":{"136":1}}],["插入或删除许多行的事务",{"2":{"276":1}}],["插入数据时",{"2":{"262":1}}],["插件会记住每个文档的光标和滚动位置",{"2":{"215":1}}],["看看是否将两个页合并以优化使用",{"2":{"262":1}}],["看下如下代码",{"2":{"146":1}}],["批量插入",{"2":{"262":1}}],["批量添加全部字段数据",{"2":{"219":1}}],["批量添加指定字段数据",{"2":{"219":1}}],["维护索引结构的代价就越大",{"2":{"261":1}}],["节省存储空间",{"2":{"261":1}}],["且查询比较频繁的表建立索引",{"2":{"261":1}}],["考虑针对于查询字段建立索引时",{"2":{"260":1}}],["性能也是最好的",{"2":{"260":1}}],["性能由好到差的连接类型为null",{"2":{"259":1}}],["影响查询",{"2":{"260":1}}],["影响系统的响应速度",{"2":{"139":1}}],["浪费大量的磁盘io",{"2":{"260":1}}],["尽量不要使用uuid做主键或者是其他自然主键",{"2":{"262":1}}],["尽量选择顺序插入",{"2":{"262":1}}],["尽量选择区分度高的列作为索引",{"2":{"261":1}}],["尽量降低主键的长度",{"2":{"262":1}}],["尽量使用联合索引",{"2":{"261":1}}],["尽量使用覆盖索引",{"2":{"260":1,"262":1}}],["尽量建立唯一索引",{"2":{"261":1}}],["尽量减少cpu空闲状态时间",{"2":{"198":1}}],["覆盖索引",{"2":{"260":1,"262":1}}],["模糊查询",{"2":{"260":1}}],["范围查询右侧的列索引失效",{"2":{"260":1}}],["范围查询",{"2":{"260":1}}],["联合索引很多时候可以覆盖索引",{"2":{"261":1}}],["联合索引中",{"2":{"260":1}}],["联合索引",{"2":{"260":2}}],["联合查询",{"0":{"228":1}}],["针对唯一索引进行检索时",{"2":{"272":1}}],["针对于非唯一二级索引页",{"2":{"276":1}}],["针对于常作为查询条件",{"2":{"261":1}}],["针对于表中主键创建的索引",{"2":{"257":1}}],["针对数据量较大",{"2":{"261":1}}],["针对字段创建索引",{"2":{"260":1}}],["验证索引效率",{"2":{"260":1}}],["简单的select",{"2":{"280":1}}],["简单",{"2":{"264":1}}],["简单表",{"2":{"259":1}}],["简单来说",{"2":{"180":1,"260":1}}],["常用工具",{"0":{"283":1}}],["常见的取值有simple",{"2":{"259":1}}],["常规索引",{"2":{"257":1}}],["越先执行",{"2":{"259":1}}],["开启事务后第一个select语句才是快照读的地方",{"2":{"280":1}}],["开启从本地加载文件导入数据的开关",{"2":{"262":1}}],["开启mysql慢日志开关",{"2":{"259":1}}],["开始获取锁",{"2":{"195":1}}],["慢查询日志记录了所有执行时间超过指定参数",{"2":{"259":1}}],["慢查询日志",{"2":{"259":1}}],["聚集索引选取规则",{"2":{"257":1}}],["聚集索引",{"2":{"257":1}}],["聚合函数或窗口函数",{"2":{"264":1}}],["聚合函数",{"2":{"220":1}}],["根据状态",{"2":{"275":1}}],["根据profession字段分组",{"2":{"262":3}}],["根据排序字段建立合适的索引",{"2":{"262":1}}],["根据age",{"2":{"262":3}}],["根据主键排序",{"2":{"262":1}}],["根据索引的存储形式",{"2":{"257":1}}],["根据子查询结果不同",{"0":{"230":1}}],["唯一索弓l",{"2":{"272":1}}],["唯一索引的选择性是1",{"2":{"260":1}}],["唯一索引",{"2":{"257":1,"272":1}}],["唯一约束",{"2":{"222":1}}],["含义",{"2":{"257":2,"265":1,"280":2,"282":1}}],["映射到一个相同的槽位上",{"2":{"256":1}}],["映射到对应的槽位上",{"2":{"256":1}}],["键值",{"2":{"256":1}}],["哈希表索引就是采用一定的hash算法",{"2":{"256":1}}],["增加日志缓冲区的大小可以节省磁盘i",{"2":{"276":1}}],["增加一个指向相邻叶子节点的链表指针",{"2":{"256":1}}],["增加指定值并获取",{"2":{"168":1}}],["叶子节点形成一个单向链表",{"2":{"256":1}}],["相同的输入参数总是产生相同的结果",{"2":{"266":1}}],["相对于b",{"2":{"256":1}}],["相比较是一个比较新的类",{"2":{"172":1}}],["描述",{"2":{"256":1}}],["效率提升",{"2":{"265":1}}],["效率很高",{"2":{"262":1}}],["效率通常要高于b+tree索引",{"2":{"256":1}}],["效率降低",{"2":{"255":1}}],["效率更高",{"2":{"166":1}}],["劣势",{"2":{"255":1}}],["演示",{"0":{"254":1},"1":{"255":1},"2":{"270":1,"272":2}}],["索引段即为b+树的非叶子节点",{"2":{"274":1}}],["索引段",{"2":{"274":1}}],["索引等数据",{"2":{"274":1}}],["索引上的范围查询",{"2":{"272":1}}],["索引上的等值查询",{"2":{"272":2}}],["索引的使用也是满足最左前缀法则的",{"2":{"262":1}}],["索引越多",{"2":{"261":1}}],["索引并不是多多益善",{"2":{"261":1}}],["索引设计原则",{"0":{"261":1}}],["索引选择性越高则查询效率越高",{"2":{"260":1}}],["索引失效",{"2":{"260":1}}],["索引不会失效",{"2":{"260":1}}],["索引将失效",{"2":{"260":2}}],["索引将部分失效",{"2":{"260":1}}],["索引列运算",{"2":{"260":1}}],["索引列也是要占用空间的",{"2":{"255":1}}],["索引使用",{"0":{"260":1}}],["索引语法",{"0":{"258":1}}],["索引作为聚集索引",{"2":{"257":1}}],["索引分类",{"0":{"257":1}}],["索引结构的叶子节点关联的是对应的主键",{"2":{"257":1}}],["索引结构的叶子节点保存了行数据",{"2":{"257":1}}],["索引结构",{"0":{"256":1},"2":{"256":1}}],["索引大大提高了查询效率",{"2":{"255":1}}],["索引概述",{"0":{"253":1}}],["索引",{"0":{"252":1},"1":{"253":1,"254":1,"255":1,"256":1,"257":1,"258":1,"259":1,"260":1,"261":1},"2":{"253":1}}],["政策",{"2":{"251":1}}],["太大的表无法缓存在内存中",{"2":{"250":1}}],["页中数据与磁盘的数据产生了不一致",{"2":{"275":1}}],["页合并",{"2":{"262":1}}],["页可以为空",{"2":{"262":1}}],["页分裂",{"2":{"262":1}}],["页",{"2":{"246":1,"274":1}}],["区的大小为1m",{"2":{"274":1}}],["区分度越高",{"2":{"261":1}}],["区",{"2":{"246":1,"274":2}}],["行",{"2":{"274":1}}],["行锁类型",{"2":{"272":1}}],["行锁和间隙锁组合",{"2":{"272":1}}],["行锁",{"2":{"272":3}}],["行锁是通过对索引上的索引项加锁来实现的",{"2":{"272":1}}],["行级触发器",{"2":{"267":1}}],["行级锁",{"0":{"272":1},"2":{"246":1,"269":1,"272":1}}],["行和列数据来自定义视图的查询使用的表",{"2":{"264":1}}],["行子查询",{"0":{"233":1},"2":{"230":1}}],["介绍",{"2":{"246":1,"247":1,"248":1,"264":1,"265":1,"267":1,"269":1,"270":1,"271":1,"272":1}}],["|",{"2":{"240":3,"265":5}}],["||",{"2":{"140":6,"220":1}}],["幻影",{"2":{"239":1}}],["幻读",{"2":{"239":1}}],["好像出现了",{"2":{"239":1}}],["好办",{"0":{"28":1}}],["持久性",{"2":{"238":1,"279":1}}],["隔离性",{"2":{"238":1,"279":1}}],["必须使所有的数据都保持一致状态",{"2":{"279":1}}],["必须使所有的数据都保持一致的状态",{"2":{"238":1}}],["必须用在循环中",{"2":{"265":1}}],["必须有",{"2":{"257":1}}],["必选",{"0":{"206":1},"1":{"207":1,"208":1,"209":1,"210":1}}],["查找使用了索引",{"2":{"260":2}}],["查看意向锁及行锁的加锁情况",{"2":{"271":1,"272":1}}],["查看元数据锁",{"2":{"271":1}}],["查看指定变量的值",{"2":{"265":1}}],["查看指定query",{"2":{"259":2}}],["查看所有系统变量",{"2":{"265":1}}],["查看系统变量",{"2":{"265":1}}],["查看视图数据",{"2":{"264":1}}],["查看创建视图语句",{"2":{"264":1}}],["查看sql的耗时",{"2":{"260":1}}],["查看每一条sql的耗时基本情况",{"2":{"259":1}}],["查看慢日志文件中记录的信息",{"2":{"259":1}}],["查看索引",{"2":{"258":1}}],["查看当前数据库支持的存储引擎",{"0":{"244":1}}],["查看事务隔离级别",{"2":{"240":1}}],["查看",{"2":{"237":1,"265":1,"267":1}}],["查询test库中book表的详细情况",{"2":{"283":1}}],["查询test库中每个表中的字段数",{"2":{"283":1}}],["查询每个数据库的表的数量及表中记录的数量",{"2":{"283":1}}],["查询语句",{"2":{"265":1}}],["查询某个存储过程的定义",{"2":{"265":1}}],["查询指定数据库的存储过程及状态",{"2":{"265":1}}],["查询指定表建表语句",{"2":{"218":1}}],["查询和修改他们所能见到的数据",{"2":{"264":1}}],["查询排序的代价非常大",{"2":{"262":1}}],["查询时",{"2":{"260":1,"261":1}}],["查询使用了索引",{"2":{"260":1}}],["查询返回结果的行数占读取行数的百分比",{"2":{"259":1}}],["查询的序号",{"2":{"259":1}}],["查询效率高",{"2":{"256":1}}],["查询字段的数量和类型必须相同",{"2":{"228":1}}],["查询权限",{"2":{"221":1}}],["查询用户",{"2":{"221":1}}],["查询",{"2":{"220":1,"264":1}}],["查询多个字段",{"2":{"220":1}}],["查询表结构",{"2":{"218":1}}],["查询当前数据库所有表",{"2":{"218":1}}],["查询当前数据库",{"2":{"218":1}}],["事务提交时",{"2":{"279":1}}],["事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求",{"2":{"279":1}}],["事务会吧所有的操作作为一个整体一起想系统提交或撤销操作请求",{"0":{"236":1},"1":{"255":1}}],["事务是不可分割的最小单元",{"2":{"279":1}}],["事务是不可分割的最小操作单元",{"2":{"238":1}}],["事务是一组操作的集合",{"2":{"279":1}}],["事务原理",{"0":{"279":1}}],["事务隔离级别",{"0":{"240":1}}],["事务一旦提交或回滚",{"2":{"238":1,"279":1}}],["事务完成时",{"2":{"238":1,"279":1}}],["事务四大特性",{"0":{"238":1}}],["事务操作",{"0":{"237":1}}],["事务",{"0":{"235":1,"236":1},"1":{"236":1,"237":1,"238":1,"239":1,"240":1,"255":1},"2":{"279":1}}],["嵌套查询",{"0":{"229":1},"1":{"230":1,"231":1,"232":1,"233":1,"234":1}}],["嵌入块增强",{"2":{"210":1}}],["子查询返回列表的所有值都必须满足",{"2":{"232":1}}],["子查询返回列表中",{"2":{"232":1}}],["子查询结果为多行多列",{"2":{"230":1}}],["子查询结果为一行",{"2":{"230":1}}],["子查询结果为一列",{"2":{"230":1}}],["子查询结果为单个值",{"2":{"230":1}}],["子查询外部语句可以是insert",{"2":{"229":1}}],["子查询",{"0":{"229":1},"1":{"230":1,"231":1,"232":1,"233":1,"234":1}}],["子线程等待主线程释放锁后",{"2":{"191":1}}],["右侧为磁盘结构",{"2":{"275":1}}],["右外连接",{"2":{"226":1}}],["右填充pad",{"2":{"221":1}}],["左侧为内存结构",{"2":{"275":1}}],["左外连接",{"2":{"226":1}}],["左填充pad",{"2":{"221":1}}],["外键",{"2":{"250":1}}],["外键约束",{"2":{"222":1}}],["外连接",{"0":{"226":1}}],["交集部分",{"0":{"225":1}}],["交替获取锁",{"2":{"191":1}}],["建议建立联合索引",{"2":{"260":1}}],["建议用timeunit的sleep代替thread的sleep来获得更好的可读性",{"2":{"62":1}}],["建立前缀索引",{"2":{"261":1}}],["建立索引",{"2":{"260":1}}],["建立中间表",{"2":{"223":1}}],["检查约束",{"2":{"222":1}}],["检查线程池的状态",{"2":{"140":1}}],["固定值",{"2":{"221":1}}],["求x四舍五入的值",{"2":{"221":1}}],["之间的随机数",{"2":{"221":1}}],["之后",{"2":{"141":1,"187":1,"196":1}}],["之后调用回调方法",{"2":{"140":1}}],["向右遍历时最后一个值不满足查询需求时",{"2":{"272":1}}],["向下取整",{"2":{"221":1}}],["向上取整",{"2":{"221":1}}],["去除头部尾部空格",{"2":{"221":1}}],["去重",{"2":{"220":1,"228":1}}],["授权",{"2":{"221":1}}],["密码>",{"2":{"283":7}}],["密码等级",{"2":{"251":1}}],["密码",{"2":{"221":1}}],["小写",{"2":{"221":1,"251":2}}],["小",{"2":{"220":1}}],["小时",{"0":{"132":1},"2":{"132":1}}],["别名b",{"2":{"227":1}}],["别名a",{"2":{"227":1}}],["别名2",{"2":{"220":1}}],["别名1",{"2":{"220":1}}],["值",{"2":{"265":2}}],["值越大",{"2":{"259":1}}],["值2",{"2":{"219":10}}],["值1",{"2":{"219":10}}],["删除和更新可能会影响索引树中不相邻的二级索引页",{"2":{"276":1}}],["删除",{"2":{"264":2,"265":1,"267":1}}],["删除掉目前的联合索引",{"2":{"262":1}}],["删除索引",{"2":{"258":1}}],["删除操作",{"2":{"250":1}}],["删除用户",{"2":{"221":1}}],["删除数据",{"2":{"219":1}}],["删除数据库",{"2":{"218":1}}],["删除并重建表",{"2":{"218":1}}],["删除表",{"2":{"218":1}}],["删除字段",{"2":{"218":1}}],["旧字段名",{"2":{"218":1}}],["旧的预期值",{"2":{"180":1}}],["旧的预期值a",{"2":{"178":1}}],["修改",{"2":{"264":1}}],["修改表名",{"2":{"218":1}}],["修改字段名及字段数据类型",{"2":{"218":1}}],["修改字段数据类型",{"2":{"218":1}}],["修改后会先修改工作内存中的存储",{"2":{"145":1}}],["新密码",{"2":{"221":1}}],["新表名",{"2":{"218":1}}],["新字段名",{"2":{"218":1}}],["新数据类型",{"2":{"218":1}}],["新值",{"2":{"168":1}}],["添加字段",{"2":{"218":1}}],["添加一个新的工作线程",{"2":{"140":1}}],["约束",{"0":{"222":1},"2":{"218":2}}],["长度越短越好",{"2":{"259":1}}],["长度",{"2":{"218":3,"251":3}}],["编号",{"2":{"218":1}}],["编译器",{"2":{"146":1}}],["字典文件",{"2":{"251":1}}],["字符串类型字段使用时",{"2":{"260":1}}],["字符串不加引号",{"2":{"260":1}}],["字符串拼接",{"2":{"221":1}}],["字符集",{"2":{"218":1}}],["字段类型及访问权限等",{"2":{"282":1}}],["字段的长度较长",{"2":{"261":1}}],["字段n注释",{"2":{"243":1}}],["字段n类型",{"2":{"243":1}}],["字段n",{"2":{"243":1}}],["字段列表",{"2":{"220":2,"225":2,"259":1}}],["字段3",{"2":{"220":1}}],["字段",{"2":{"220":1,"262":3,"280":1}}],["字段2=值2",{"2":{"219":1}}],["字段2",{"2":{"219":2,"220":2}}],["字段1注释",{"2":{"243":1}}],["字段1类型",{"2":{"243":1}}],["字段1=值1",{"2":{"219":1}}],["字段1",{"2":{"219":2,"220":2,"243":1}}],["字段名称",{"2":{"226":2,"227":1,"228":2}}],["字段名",{"2":{"218":3,"220":1,"265":2}}],["字节填充",{"2":{"189":1}}],["显示指定数据库或者指定表的状态信息",{"2":{"283":1}}],["显示数据库及表的统计信息",{"2":{"283":1}}],["显示简单格式",{"2":{"283":1}}],["显示可能应用在这张表的索引",{"2":{"259":1}}],["显示内连接",{"2":{"225":1}}],["显示所有数据库",{"2":{"218":1}}],["显示的锁定之后再操作同步资源",{"2":{"175":1}}],["表均不指定",{"2":{"283":1}}],["表中的列或者索引",{"2":{"283":1}}],["表",{"2":{"282":1}}],["表空间的单元结构",{"2":{"274":1}}],["表空间",{"2":{"274":1}}],["表独占写锁",{"2":{"271":1}}],["表共享读锁",{"2":{"271":1}}],["表锁",{"2":{"271":2}}],["表级锁",{"0":{"271":1},"2":{"269":1,"271":1}}],["表数据都是根据主键顺序组织存放的",{"2":{"262":1}}],["表明",{"2":{"259":1}}],["表注释",{"2":{"243":1}}],["表子查询",{"0":{"234":1},"1":{"236":1},"2":{"230":1}}],["表b",{"2":{"228":1}}],["表a",{"2":{"227":2,"228":1}}],["表2",{"2":{"225":2,"226":2,"229":1}}],["表1",{"2":{"225":2,"226":2,"229":1}}],["表名>",{"2":{"283":1}}],["表名",{"2":{"218":8,"219":6,"220":7,"221":2,"243":1,"265":2,"271":1}}],["表格",{"2":{"216":1}}],["表示索引中使用的字节数",{"2":{"259":1}}],["表示连接类型",{"2":{"259":1}}],["表示select的类型",{"2":{"259":1}}],["表示查询中执行select子句或者是操作表的顺序",{"2":{"259":1}}],["表示等待指定的时间",{"2":{"194":1}}],["表示需要修改为的新值",{"2":{"179":1}}],["表示需要修改数据的期望的值",{"2":{"179":1}}],["表示要操作对象中属性地址的偏移量",{"2":{"179":1}}],["表示要操作的对象",{"2":{"179":1}}],["方便",{"2":{"283":1}}],["方便编辑和导航表格的插件",{"2":{"216":1}}],["方法可以中断",{"2":{"204":1}}],["方法释放锁",{"2":{"204":1}}],["方法的源代码",{"2":{"179":1}}],["方法的时候",{"2":{"127":1}}],["方法来判断",{"0":{"76":1}}],["方法并不能保证线程一定会让cpu资源",{"2":{"63":1}}],["方法作用是",{"2":{"63":1}}],["符号输入时自动补齐",{"2":{"213":1}}],["功能拓展",{"2":{"212":1,"213":1,"214":1,"215":1,"216":1}}],["命令的设备和环境上通过命令面板自动创建和拉取提交",{"2":{"212":1}}],["数字",{"2":{"251":2}}],["数字1",{"0":{"131":1}}],["数据文件",{"2":{"283":1}}],["数据被修改过",{"2":{"275":1}}],["数据没有被修改过",{"2":{"275":1}}],["数据段就是b+树的叶子节点",{"2":{"274":1}}],["数据也是一种供许多用户共享的资源",{"2":{"269":1}}],["数据校验等操作",{"2":{"267":1}}],["数据独立",{"2":{"264":1}}],["数据组织方式",{"2":{"262":1}}],["数据分布影响",{"2":{"260":1}}],["数据",{"2":{"253":1,"283":1}}],["数据操作除了插入和查询之外",{"2":{"250":1}}],["数据和索引",{"2":{"246":1}}],["数据库中的表",{"2":{"283":1}}],["数据库加全局锁",{"2":{"270":1}}],["数据库可以授权",{"2":{"264":1}}],["数据库系统提供的隔离机制",{"2":{"279":1}}],["数据库系统提供隔离机制",{"2":{"238":1}}],["数据库系统还维护着满足特定查找算法的数据结构",{"2":{"253":1}}],["数据库",{"2":{"221":2,"282":1}}],["数据库名>",{"2":{"283":1}}],["数据库名",{"2":{"218":2}}],["数据查询",{"2":{"210":1}}],["支持hash索引的是memory引擎",{"2":{"256":1}}],["支持表锁",{"2":{"247":1}}],["支持外键foreignkey约束",{"2":{"246":1}}],["支持事务",{"2":{"246":1,"250":1}}],["支持",{"2":{"213":1}}],["支持在文件浏览标签页中展示包含的文档数",{"2":{"214":1}}],["支持在安装有",{"2":{"212":1}}],["支持在",{"2":{"210":1}}],["支持使用快捷键快速添加脚注",{"2":{"209":1}}],["脚注将会自动递增",{"2":{"209":1}}],["文件",{"2":{"246":1,"247":1,"248":1}}],["文件中使用类似",{"2":{"210":1}}],["文件中的插件",{"2":{"208":1}}],["文件嵌入到您的",{"2":{"208":1}}],["文件解析",{"2":{"206":1,"208":1}}],["地址",{"2":{"207":1,"208":1,"209":1,"210":1,"212":1,"213":1,"214":1,"215":1,"216":1}}],["样式遵循",{"2":{"207":1}}],["拓展等功能",{"2":{"206":1}}],["语法二",{"2":{"265":1}}],["语法一",{"2":{"265":1}}],["语法",{"2":{"259":1,"260":1,"265":1,"267":1,"271":1}}],["语法拓展",{"2":{"207":1,"208":1,"210":1}}],["语法增强",{"2":{"206":1,"209":1,"213":1,"216":1}}],["语法不同",{"2":{"184":1}}],["⚠️",{"2":{"206":1}}],["知识库插件列表",{"0":{"205":1},"1":{"206":1,"207":1,"208":1,"209":1,"210":1,"211":1,"212":1,"213":1,"214":1,"215":1,"216":1}}],["用来导入mysqldump加",{"2":{"283":1}}],["用来很快地查找存在哪些数据库",{"2":{"283":1}}],["用来保存要写入到磁盘中的log日志数",{"2":{"276":1}}],["用户",{"2":{"282":1}}],["用户定义的变量无需对其进行声明或初始化",{"2":{"265":1}}],["用户变量不用提前声明",{"2":{"265":1}}],["用户自定义变量",{"2":{"265":1}}],["用户名>",{"2":{"283":7}}],["用户名",{"2":{"221":6}}],["用法",{"2":{"262":1,"265":1}}],["用or分割开的条件",{"2":{"260":1}}],["用于配合undo",{"2":{"280":1}}],["用于记录数据被修改前的信息作用包含两个",{"2":{"279":1}}],["用于在刷新脏页到磁盘",{"2":{"279":1}}],["用于在刷新脏页到磁盘时",{"2":{"277":1}}],["用于存储undo",{"2":{"277":1}}],["用于存储记录",{"2":{"274":1}}],["用于优化对buffer",{"2":{"276":1}}],["用于表结构拆分",{"2":{"223":1}}],["用于格式化",{"2":{"216":1}}],["用于区分不同的进程",{"0":{"9":1}}],["用synchronized关踺字的两个线程1和线程2",{"2":{"204":1}}],["灵活控制",{"2":{"203":1}}],["写锁既会阻塞其他客户端的读",{"2":{"271":1}}],["写锁是排它锁",{"2":{"203":1}}],["写入加锁保证原子性",{"2":{"177":1}}],["写入",{"2":{"158":1}}],["典型的synchronized就是排它锁",{"2":{"202":1}}],["排他",{"2":{"271":1}}],["排他锁",{"0":{"202":1},"2":{"272":7,"280":1}}],["排序",{"2":{"261":1}}],["排序字段列表",{"2":{"220":1}}],["排序规则",{"2":{"218":1}}],["排序方式",{"2":{"1":1}}],["排它锁又称独占锁",{"2":{"202":1}}],["吞吐量自然就上去了",{"2":{"200":1}}],["很显然非公平锁是比较合适的",{"2":{"200":1}}],["很有可能配置的线程池不是较优的",{"0":{"120":1}}],["什么时候用非公平",{"0":{"200":1}}],["什么时候用公平",{"0":{"200":1}}],["什么是纤程",{"0":{"13":1}}],["什么是线程安全",{"0":{"143":1}}],["什么是线程池",{"0":{"106":1},"1":{"107":1,"108":1,"109":1,"110":1,"111":1}}],["什么是线程",{"0":{"10":1}}],["什么是进程",{"0":{"8":1}}],["什么是j",{"0":{"4":1},"1":{"5":1,"6":1}}],["恢复挂起的线程到真正锁的获取还是有时间差的",{"2":{"198":1}}],["恢复为001无锁态",{"2":{"191":1}}],["非空约束",{"2":{"222":1}}],["非固定",{"2":{"221":1}}],["非公平",{"2":{"204":1}}],["非公平锁霸气的忽视这个规则",{"2":{"199":1}}],["非公平锁的设计为什么默认非公平",{"0":{"198":1}}],["非核心线程的空闲状态的存活时间",{"0":{"131":1},"2":{"136":1}}],["随便找个人出票就完事了",{"2":{"197":1}}],["售票员忙的焦头烂额",{"2":{"197":1}}],["接着线程2也请求了锁a",{"2":{"197":1}}],["接口时",{"2":{"141":2}}],["被使用page",{"2":{"275":2}}],["被告知无需等待",{"2":{"196":1}}],["被中断等情况都会直接进入runnable状态",{"0":{"90":1}}],["朋友由于突发状况",{"2":{"196":1}}],["突然你接到一个电话",{"2":{"196":1}}],["你和好朋友越好一起去打球",{"2":{"196":1}}],["你呈序反而不能支持更高的tps",{"0":{"42":1}}],["发生错误时",{"2":{"277":1,"279":1}}],["发生锁冲突的概率最低",{"2":{"272":1}}],["发生锁冲突的概率最高",{"2":{"271":1}}],["发起获取锁请求到还未获取到锁这段时间内",{"2":{"196":1}}],["发送短信",{"2":{"54":1}}],["休眠5秒",{"2":{"195":1}}],["休眠之后退出阻塞",{"2":{"184":1}}],["尝试获取锁",{"2":{"195":1}}],["尝试终止线程池以及判断是否需要添加新的工作线程",{"2":{"140":1}}],["尝试终止",{"2":{"140":1}}],["给不存在的记录加锁时优化为间隙锁",{"2":{"272":1}}],["给全部字段添加数据",{"2":{"219":1}}],["给我们提供了获取锁限时等待的方法trylock",{"2":{"194":1}}],["给每一桌上一个菜",{"0":{"25":1}}],["申请锁等待限时是什么意思",{"2":{"194":1}}],["公平锁保证了排队的公平性",{"2":{"199":1}}],["公平锁的一大特点是",{"2":{"197":1}}],["公平锁是指多个线程尝试获取同一把锁的时候",{"2":{"193":1}}],["公平锁和非公平锁",{"0":{"197":1},"1":{"198":1,"199":1,"200":1},"2":{"193":1}}],["出现范围查询",{"2":{"260":1}}],["出现了作茧自缚",{"2":{"192":1}}],["出来之后它的对象的内存布局是什么样子的呢",{"2":{"189":1}}],["程序可以根据需要取消获取锁的请求",{"2":{"196":1}}],["程序第2次进入被自己阻塞了岂不是天大的笑话",{"2":{"192":1}}],["程序员做第",{"2":{"136":1}}],["前者是在内存中",{"2":{"277":1,"279":1}}],["前或后",{"2":{"262":1}}],["前缀长度",{"2":{"260":1}}],["前缀索引",{"2":{"260":1}}],["前提",{"2":{"192":1}}],["前面说过",{"0":{"38":1}}],["又会阻塞其他客户端的写",{"2":{"271":1}}],["又可以分为以下两种",{"2":{"257":1}}],["又发现这行数据已经存在",{"2":{"239":1}}],["又名递归锁",{"0":{"192":1}}],["又必须创建为一个线程",{"0":{"104":1}}],["首先synchronized是java内置关踺字",{"2":{"204":1}}],["首先写一个简单的线程",{"2":{"144":1}}],["首次加锁为101偏向锁",{"2":{"191":1}}],["若缓冲池没有数据",{"2":{"275":1}}],["若后续该线程再次获取锁",{"2":{"191":1}}],["若用户想在线程池变为tidying时",{"2":{"141":1}}],["大数据量排序时",{"2":{"262":1}}],["大批量插入数据",{"2":{"262":1}}],["大部分都支持b+树索引",{"2":{"256":1}}],["大写和特殊字符",{"2":{"251":2}}],["大写",{"2":{"221":1}}],["大",{"2":{"220":1}}],["大家公平使用",{"2":{"200":1}}],["大家都围在售票窗囗前",{"2":{"197":1}}],["大小端转换",{"2":{"190":1}}],["大白话",{"2":{"143":1}}],["没有not",{"2":{"262":1}}],["没有创建索引时",{"2":{"262":1}}],["没有对应的数据行",{"2":{"239":1}}],["没有占用返回true",{"2":{"195":1}}],["没有任何线程竞争",{"2":{"190":1}}],["没人愿意排队",{"0":{"28":1}}],["944",{"2":{"196":1}}],["9",{"2":{"189":1,"262":3}}],["此指针指向的class",{"2":{"189":1}}],["此时就会升级为表锁",{"2":{"272":1}}],["此时需要mysql排序前2000010记录",{"2":{"262":1}}],["此时需要注意联合索引在创建时的规则",{"2":{"262":1}}],["此时可以使用mysql数据库提供的load指令进行插入",{"2":{"262":1}}],["此时可以只将字符串的一部分前缀",{"2":{"260":1}}],["此时的状态是waiting状态",{"2":{"187":1}}],["此时线程状态变为blocked状态",{"2":{"187":1}}],["轻量级锁会升级成重量级锁",{"2":{"191":1}}],["轻量级锁解锁后",{"2":{"191":1}}],["轻量级锁一",{"2":{"188":1}}],["轻量级锁和重量级锁",{"2":{"188":1}}],["级别由低到高依次为",{"2":{"188":1}}],["偏向锁升级为轻量级锁",{"2":{"191":1}}],["偏向锁存",{"0":{"191":1}}],["偏向锁位",{"2":{"190":1,"191":1}}],["偏向锁一",{"2":{"188":1}}],["偏向锁",{"2":{"188":1}}],["引发interruptedexception异常",{"2":{"196":1}}],["引入了偏向锁和轻量级锁",{"2":{"188":1}}],["引用类型原子类",{"0":{"170":1}}],["后续复用readview",{"2":{"280":1}}],["后续的dml的写语句",{"2":{"270":1}}],["后台线程",{"0":{"278":1}}],["后者在磁盘中",{"2":{"277":1,"279":1}}],["后面的字段索引失效",{"2":{"260":1}}],["后面讲wait",{"2":{"187":1}}],["后才能打开微信",{"0":{"32":1}}],["竞争是非公平的",{"2":{"187":1}}],["竞争激烈的时候",{"2":{"172":1}}],["刚开始monitor中owner为null",{"2":{"187":1}}],["刚放到缓存",{"2":{"145":1}}],["源码是c++",{"2":{"187":1}}],["源码分析compareandset",{"0":{"179":1}}],["翻译成java领域的语言",{"2":{"187":1}}],["让这个类是线程安全的",{"2":{"187":1}}],["让它们支持并发",{"2":{"187":1}}],["让我们一块看一个简单例子吧",{"2":{"144":1}}],["监视器",{"2":{"187":1}}],["直接进入下一次循环",{"2":{"265":2}}],["直接按行进行累加",{"2":{"262":2}}],["直接按行累加",{"2":{"262":1}}],["直接在select语句之前加上关键字explain",{"2":{"259":1}}],["直译为",{"2":{"187":1}}],["直到其他线程释放锁为止",{"2":{"196":1}}],["直到获取到锁才会退出循环",{"2":{"182":1}}],["直到没有任务为止",{"2":{"140":1}}],["管程是指管理共享变量以及对共享变量操作的过程",{"2":{"187":1}}],["管程",{"0":{"187":1},"2":{"187":1}}],["管理线程",{"0":{"115":1}}],["生成readview的时机不同",{"2":{"280":1}}],["生成一些常用的线程池",{"0":{"120":1}}],["生产者消费者模式",{"0":{"185":1}}],["唤醒方式不同",{"2":{"184":1}}],["所设置的全局参数会失效",{"2":{"265":1}}],["所有没有被sqlwarning或者not",{"2":{"265":1}}],["所有以02开头的sqlstate代码的简写",{"2":{"265":1}}],["所有以01开头的sqlstate代码的简写",{"2":{"265":1}}],["所有不是通过索引直接返回排序结果的排序都叫filesort排序",{"2":{"262":1}}],["所有的数据都会出现在叶子节点",{"2":{"256":1}}],["所属类不同",{"2":{"184":1}}],["所以如果想要检查这些文本的文本格式",{"2":{"283":1}}],["所以我们创建视图的时候",{"2":{"264":1}}],["所以尽量使用count",{"2":{"262":1}}],["所以不需要回表查询数据",{"2":{"260":1}}],["所以不会加锁",{"2":{"176":1}}],["所以就有可能导致排队的长时间在排队",{"2":{"199":1}}],["所以就减少了线程的开销",{"2":{"198":1}}],["所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大",{"2":{"198":1}}],["所以非公平锁能更充分的利用cpu的时间片",{"2":{"198":1}}],["所以当线程调用interrupt",{"2":{"196":1}}],["所以获取锁的时间有长有短",{"2":{"194":1}}],["所以java中reentrantlock和synchronized都是可重入锁",{"2":{"192":1}}],["所以让线程不断去尝试更新",{"2":{"182":1}}],["所以在多线程情况下性能会比较好",{"2":{"178":1}}],["所以task2的代码可能会变成",{"2":{"146":1}}],["所以",{"2":{"144":1}}],["所以一个线程只能有一次new和terminated状态",{"0":{"94":1}}],["整体区别其实是有四个",{"2":{"184":1}}],["另外两个线程已经连续修改了两次变量v的值",{"2":{"183":1}}],["另外一个线程b也来使用var",{"2":{"145":1}}],["准备修改为新值u前",{"2":{"183":1}}],["假设这样一种场景",{"2":{"183":1}}],["乐观地认为程序中的并发情况不那么严重",{"2":{"182":1}}],["乐观锁一般有两种实现方式",{"2":{"176":1}}],["乐观锁则直接去操作同步资源",{"2":{"176":1}}],["乐观锁在java中是通过使用无锁编程来实现",{"2":{"176":1}}],["乐观锁",{"0":{"176":1}}],["乐观锁和悲观锁",{"0":{"174":1},"1":{"175":1,"176":1}}],["代表是当前事务id",{"2":{"280":1}}],["代价比较高",{"2":{"182":1}}],["代码执行顺序被重排会是什么效果呢",{"2":{"146":1}}],["代码如下",{"2":{"144":1}}],["借鉴cas思想",{"0":{"182":1}}],["自带了以下四个数据库",{"2":{"282":1}}],["自适应哈希索引",{"2":{"276":1}}],["自适应hash索引",{"2":{"276":1}}],["自动加锁",{"2":{"272":3}}],["自己计数",{"2":{"262":1}}],["自连接查询",{"2":{"227":1}}],["自连接",{"0":{"227":1}}],["自旋锁的实现基础是cas算法机制",{"2":{"182":1}}],["自旋锁与互斥锁比较类似",{"2":{"182":1}}],["自旋锁",{"0":{"182":1},"2":{"182":1}}],["自定义线程池",{"0":{"136":1}}],["循环时间长开销很大",{"2":{"181":1}}],["循环直到获取到任务或者线程池被关闭",{"2":{"140":1}}],["来实现高效且线程安全的操作",{"2":{"180":1}}],["时区",{"2":{"282":1}}],["时",{"2":{"180":1,"260":1}}],["时间单位",{"0":{"132":1}}],["时间片是cpu分配给任务",{"0":{"45":1}}],["时间片",{"0":{"43":1}}],["和",{"2":{"279":1}}],["和新值",{"2":{"180":1}}],["和notifyall",{"0":{"88":1}}],["谈谈你对unsafe的理解",{"0":{"180":1}}],["主从",{"2":{"282":1}}],["主查询",{"2":{"259":1}}],["主键id",{"2":{"262":1}}],["主键不可能为null",{"2":{"262":1}}],["主键",{"2":{"262":2}}],["主键设计原则",{"2":{"262":1}}],["主键优化",{"2":{"262":1}}],["主键顺序插入性能高于乱序插入",{"2":{"262":1}}],["主键顺序插入",{"2":{"262":2}}],["主键索引就是聚集索引",{"2":{"257":1}}],["主键索引",{"2":{"257":1}}],["主键约束",{"2":{"222":1}}],["主要用于收集数据库服务器性能参数",{"2":{"282":1}}],["主要用于回收事务已经提交了的undo",{"2":{"278":1}}],["主要用于地理数据类型",{"2":{"256":1}}],["主要分为以下三类",{"2":{"271":1,"272":1}}],["主要的工作就落在创建这条sql查询语句上",{"2":{"264":1}}],["主要对4个参数做一下说明",{"2":{"179":1}}],["主机名",{"2":{"221":6}}],["主线程首先对user对象加锁",{"2":{"191":1}}],["主线程不会退出",{"2":{"126":1}}],["否则会从行锁升级为表锁",{"2":{"262":1}}],["否则不加",{"2":{"262":1}}],["否则",{"2":{"221":2,"265":1}}],["否则返回",{"2":{"221":1}}],["否则容易造成线程死锁",{"2":{"204":1}}],["否则那就用公平锁",{"2":{"200":1}}],["否则什么都不做或重来",{"2":{"178":1}}],["否则为corepoolsize",{"2":{"140":1}}],["要想不失效",{"2":{"265":1}}],["要使视图可更新",{"2":{"264":1}}],["要控制索引的数量",{"2":{"261":1}}],["要遵守最左前缀法则",{"2":{"260":1}}],["要么全部失败",{"2":{"238":1,"279":1}}],["要么全部成功",{"2":{"238":1,"279":1}}],["要么同时失败",{"0":{"236":1},"1":{"255":1},"2":{"279":1}}],["要么一直等待",{"2":{"196":1}}],["要么获取到锁然后继续后面的操作",{"2":{"196":1}}],["要修改的更新值b",{"2":{"178":1}}],["要配置一个线程池是比较复杂的",{"0":{"120":1}}],["位置内存值v",{"2":{"178":1}}],["中配置如下信息",{"2":{"259":1}}],["中间表包含两个外键",{"2":{"223":1}}],["中文符号自动补齐",{"2":{"213":1}}],["中文翻译成比较并交换",{"2":{"178":1}}],["中断标志的变化是",{"2":{"196":1}}],["中断标志",{"2":{"196":1}}],["中断操作正是提供了一套类似的机制",{"2":{"196":1}}],["中都存在一个threadlocalmap",{"2":{"152":1}}],["算法实现",{"2":{"176":1}}],["采用版本号机制",{"2":{"176":1}}],["适合读操作多的场景",{"2":{"176":1}}],["适合写操作多的场景",{"2":{"175":1}}],["认为自己在使用数据的时候一定有别的线程来修改数据",{"2":{"175":1}}],["悲观锁",{"0":{"175":1}}],["锁对数据库而言显得尤其重要",{"2":{"269":1}}],["锁对象得是同一个对象",{"2":{"192":1}}],["锁冲突也是影响数据库并发访问性能的一个重要因素",{"2":{"269":1}}],["锁是计算机协调多个进程或线程并发访问某一资源的机制",{"2":{"269":1}}],["锁饥饿",{"2":{"199":1}}],["锁的申请都是非公平的",{"2":{"197":1}}],["锁类型",{"2":{"189":1,"271":1}}],["锁升级",{"0":{"188":1},"1":{"189":1,"190":1,"191":1}}],["锁",{"0":{"173":1,"268":1},"1":{"174":1,"175":1,"176":1,"269":1,"270":1,"271":1,"272":1}}],["锁定索引记录间隙",{"2":{"272":1}}],["锁定单个行记录的锁",{"2":{"272":1}}],["锁定粒度最小",{"2":{"272":1}}],["锁定粒度大",{"2":{"271":1}}],["锁定数据库中的所有表",{"2":{"269":1}}],["锁定",{"2":{"158":1}}],["7",{"2":{"172":1,"262":3}}],["year",{"2":{"221":1}}],["y的余数",{"2":{"221":1}}],["your",{"2":{"212":1}}],["y",{"2":{"172":1,"221":2}}],["yield",{"2":{"63":3}}],["降低cpu的消耗",{"2":{"255":1}}],["降低数据排序的成本",{"2":{"255":1}}],["降低数据库的io成本",{"2":{"255":1}}],["降低冲突的概率是多段锁的理念",{"2":{"172":1}}],["降低资源消耗",{"0":{"116":1}}],["减少阻塞",{"2":{"278":1}}],["减少磁盘io",{"2":{"276":1}}],["减少网络交互",{"2":{"265":1}}],["减少数据在数据库和应用服务器之间的传输对于提高数据处理的效率是有好处的",{"2":{"265":1}}],["减少单列索引",{"2":{"261":1}}],["减少select",{"2":{"260":1}}],["减少乐观锁的重试次数",{"2":{"172":1}}],["减少worker数量",{"2":{"140":2}}],["推荐使用longadder对象",{"2":{"172":1}}],["输出选项",{"2":{"283":1}}],["输出xushu现在的年龄",{"2":{"171":1}}],["输出的值都是一样的",{"2":{"154":1}}],["徐庶长了一岁",{"2":{"171":1}}],["升级类型原子类",{"0":{"171":1}}],["zhuge",{"2":{"170":2}}],["6之后",{"2":{"188":1}}],["6之前",{"2":{"186":1}}],["6",{"2":{"168":2,"184":1,"204":1,"262":1}}],["64页",{"2":{"246":1}}],["64架构软件开发者手册对lock指令的解释",{"2":{"160":1}}],["64处理器使用mesi实现缓存一致性协议",{"2":{"159":1}}],["运行结果",{"2":{"168":1}}],["89",{"2":{"262":2}}],["88",{"2":{"262":2}}],["8个字节的markword",{"2":{"189":1}}],["8",{"2":{"168":2,"262":3}}],["懒设置",{"2":{"168":1}}],["递增并且获取",{"2":{"168":1}}],["比atomiclong性能更好",{"2":{"172":1}}],["比较并且设置",{"2":{"168":1}}],["比如",{"2":{"196":1}}],["比如gc标记",{"2":{"189":1}}],["比如在",{"2":{"180":1}}],["比如修改helper的属性声明为private",{"2":{"162":1}}],["比如被中断",{"2":{"140":1}}],["比如线程从new状态是不可以直接进入blocked状态的",{"0":{"92":1}}],["基本类型原子类",{"2":{"167":1}}],["基本数据类型",{"0":{"167":1},"2":{"177":1}}],["粒度更细",{"2":{"166":1}}],["屏障类型",{"2":{"164":1}}],["单列索引",{"2":{"260":1}}],["单列索引与联合索引",{"2":{"260":1}}],["单位",{"2":{"259":1}}],["单例模式dcl导致的可见性问题",{"0":{"162":1}}],["单核cpu",{"0":{"47":1}}],["具有崩溃恢复特性",{"2":{"275":1}}],["具体作用如下",{"2":{"282":1}}],["具体语法如下",{"2":{"266":1}}],["具体语法为",{"2":{"265":3}}],["具体类",{"2":{"167":1}}],["具体是否让出cpu资源",{"2":{"63":1}}],["具备所有屏障能力",{"2":{"161":1}}],["具备ifence和sfence的能力",{"2":{"161":1}}],["阿里面试题",{"2":{"161":1}}],["阿里开源的transmittablethreadlocal",{"2":{"154":1}}],["该mysql不是指mysql服务",{"2":{"283":1}}],["该日志文件由两部分组成",{"2":{"277":1,"279":1}}],["该类参数作为输出",{"2":{"265":1}}],["该类参数作为输入",{"2":{"265":1}}],["该值为索引字段最大可能长度",{"2":{"259":1}}],["该对象头的mark",{"2":{"187":1}}],["该数据会马上同步会主内存",{"2":{"159":1}}],["该线程可以在任意时刻",{"2":{"152":1}}],["标量子查询",{"0":{"231":1},"2":{"230":1}}],["标识为线程独占状态",{"2":{"158":1}}],["标记未超时",{"2":{"140":1}}],["标记为超时",{"2":{"140":1}}],["标记为正常完成",{"2":{"140":1}}],["标记是否突然完成",{"2":{"140":1}}],["载入",{"2":{"158":1}}],["从这个角度来说",{"2":{"269":1}}],["从开发人员来看这个时间微乎其微",{"2":{"198":1}}],["从低级别到高级别",{"2":{"188":1}}],["从此以后java内置锁的状态就有了4种",{"2":{"188":1}}],["从0开始",{"2":{"172":1}}],["从工作内存读取数据来计算",{"2":{"158":1}}],["从主内存读取数据",{"2":{"158":1}}],["从而减少磁盘io",{"2":{"275":1}}],["从而获取一致性视图",{"2":{"270":1}}],["从而使得用户不必为以后的操作每次指定全部的条件",{"2":{"264":1}}],["从而提高索引效率",{"2":{"260":1}}],["从而无需和找到滚动到上次所在的位置",{"2":{"215":1}}],["从而出现内存泄漏",{"2":{"153":1}}],["从而起到线程隔离的作用",{"2":{"152":1}}],["清理线程上下文",{"2":{"154":1}}],["清空任务",{"2":{"140":1}}],["清空worker的第一个任务",{"2":{"140":1}}],["反而不如使用threadlocal时刻提醒自己它要手动传递",{"2":{"154":1}}],["反之亦然",{"2":{"279":1}}],["反之拿到任务运行",{"2":{"138":1}}],["反之则为用户线程",{"0":{"76":1}}],["无人工干预",{"2":{"276":1}}],["无需显式使用",{"2":{"271":1}}],["无需反复创建线程而消耗过多资源",{"0":{"111":1}}],["无法利用索引完成排序操作",{"2":{"256":1}}],["无参则表示立即返回锁申请的结果",{"2":{"194":1}}],["无参构造函数",{"2":{"172":1}}],["无锁一",{"2":{"188":1}}],["无锁",{"0":{"190":1},"2":{"188":1}}],["无论是互斥锁",{"2":{"182":1}}],["无疑在碰到线程时要踩坑",{"2":{"154":1}}],["手动提交事务",{"2":{"262":1}}],["手动清除entry对象",{"2":{"153":1}}],["手动调用threadlocal的remove方法",{"2":{"153":1}}],["解锁后其他线程可以锁定该变量",{"2":{"158":1}}],["解锁",{"2":{"158":1}}],["解锁worker",{"2":{"140":2}}],["解决办法是在使用threadlocal对象之后",{"2":{"153":1}}],["应该根据应用系统的特点选择合适的存储引擎",{"0":{"250":1}}],["应该要把设置的key",{"2":{"153":1}}],["应用在innodb存储引擎中",{"2":{"272":1}}],["应用在mylsam",{"2":{"271":1}}],["应用",{"0":{"78":1},"1":{"79":1,"80":1}}],["key锁进行搜索和索引扫描",{"2":{"272":1}}],["key锁进行搜索和索引扫描以防止幻读",{"2":{"272":1}}],["key",{"2":{"222":2,"259":3,"272":2}}],["keepalivetime",{"0":{"131":1},"2":{"140":1}}],["k",{"2":{"152":2}}],["任何时刻最多只能有一个执行单元获得锁",{"2":{"182":1}}],["任意方法中获取缓存的数据",{"2":{"152":1}}],["任务数量",{"2":{"141":1}}],["任务可以不需要等待线程创建就能立即执行",{"0":{"117":1}}],["避免对主键的修改",{"2":{"262":1}}],["避免回表",{"2":{"261":1}}],["避免同一个表中某数据列中的值重复",{"2":{"257":1}}],["避免阻塞线程造成的cpu在用户态和内核态间转换的消耗",{"2":{"191":1}}],["避免了线程安全的问题",{"2":{"152":1}}],["避免指令重排序导致数据不一致",{"2":{"143":1}}],["局部变量的范围是在其内部声明的begin",{"2":{"265":1}}],["局部变量",{"0":{"150":1},"2":{"265":1}}],["破坏临界资源",{"0":{"148":1},"1":{"149":1,"150":1}}],["马上刷新到内存中",{"2":{"146":1}}],["注释",{"2":{"218":2}}],["注意",{"2":{"206":1,"265":3,"272":1}}],["注意不是threadlocal对象",{"2":{"152":1}}],["注",{"2":{"146":1}}],["按照锁的粒度分",{"2":{"269":1}}],["按照效率排序的话",{"2":{"262":1}}],["按照客户下单顺序",{"0":{"31":1}}],["按现在的顺序执行的话",{"2":{"146":1}}],["他们就产生了hash冲突",{"2":{"256":1}}],["他们共享两个变量val和finish",{"2":{"146":1}}],["他需要先经历runnable状态",{"0":{"92":1}}],["分类",{"2":{"257":2,"269":1}}],["分为数据段",{"2":{"274":1}}],["分为两类",{"2":{"271":1}}],["分为以下三类",{"2":{"269":1}}],["分为全局变量",{"2":{"265":1}}],["分为",{"0":{"230":1}}],["分页参数",{"2":{"220":1}}],["分组操作时",{"2":{"262":1}}],["分组",{"2":{"261":1}}],["分组后条件列表",{"2":{"220":1}}],["分组字段列表",{"2":{"220":1}}],["分配内存",{"2":{"180":1}}],["分别创建两个任务task1和task2",{"2":{"146":1}}],["分钟",{"2":{"132":1}}],["优化思路",{"2":{"262":2}}],["优化后可以是如下代码",{"2":{"146":1}}],["优势",{"2":{"255":1}}],["优缺点",{"0":{"255":1}}],["优先使用volatile来解决可见性问题",{"2":{"145":1}}],["举个简单例子",{"2":{"146":1}}],["防止其他事务在这个间隙进行insert",{"2":{"272":1}}],["防止其他事务对此行进行update和delete",{"2":{"272":1}}],["防止不相关的指令需要等待上一个指令结束才能开始",{"2":{"146":1}}],["防止大量占用cpu资源",{"2":{"62":1}}],["对已存在的记录进行等值匹配时",{"2":{"272":1}}],["对应sql",{"2":{"271":1}}],["对所有的表进行锁定",{"2":{"270":1}}],["对于一些批处理脚本",{"2":{"283":1}}],["对于我们日常的操作",{"2":{"280":1}}],["对于行级锁",{"2":{"272":1}}],["对于表锁",{"2":{"271":1}}],["对于表级锁",{"2":{"271":1}}],["对于返回的结果集",{"2":{"262":1}}],["对于复杂的应用系统",{"0":{"250":1}}],["对于synchronized关键字",{"2":{"196":1}}],["对于互斥锁",{"2":{"182":1}}],["对user对象加锁",{"2":{"191":1}}],["对象处于无锁状态+可偏向状态",{"2":{"191":1}}],["对象处于无锁状态+不可偏向状态",{"2":{"190":1}}],["对象锁",{"2":{"187":1}}],["对synchronized的实现进行了优化",{"2":{"188":1}}],["对对象的一些保护措施",{"2":{"180":1}}],["对代码指令进行乱序处理",{"2":{"146":1}}],["对1做了两次+1操作",{"2":{"144":1}}],["指维护一个数据的多个版本",{"2":{"280":1}}],["指在insert",{"2":{"267":1}}],["指向上一个版本",{"2":{"280":1}}],["指向这条记录的上一个版本",{"2":{"280":1}}],["指向",{"2":{"253":1}}],["指定位置间隔内的所有日志",{"2":{"283":1}}],["指定日期间隔内的所有日志",{"2":{"283":1}}],["指定数据库名称",{"2":{"283":1}}],["指定连接端口",{"2":{"283":1}}],["指定服务器ip或域名",{"2":{"283":1}}],["指定密码",{"2":{"283":1}}],["指定用户名",{"2":{"283":1}}],["指定存储引擎",{"0":{"243":1}}],["指定字段添加数据",{"2":{"219":1}}],["指定获取锁的等待时间",{"2":{"195":1}}],["指令示例",{"2":{"164":1}}],["指令重排序",{"2":{"161":1}}],["指令重排与内存屏障",{"0":{"161":1}}],["指令重排为什么会提高程序性能呢",{"2":{"146":1}}],["指应用能够同时执行不同的任务",{"0":{"35":1}}],["指应用能够交替执行不同的任务比如单cpu核心下执行多线程并非是同时间执行多个任务",{"0":{"34":1}}],["扩展一下",{"2":{"146":1}}],["怎么保证共享变量的可见性呢",{"2":{"145":1}}],["怎么让程序尽量通过有限的硬件",{"0":{"6":1}}],["共享",{"2":{"271":1}}],["共享锁又称读锁",{"2":{"203":1}}],["共享锁",{"0":{"203":1},"2":{"272":4,"280":1}}],["共享锁和排他锁",{"0":{"201":1},"1":{"202":1,"203":1}}],["共享变量使用是需要从主内存中重新获取",{"2":{"145":1}}],["共享的变量需要保证可见性",{"2":{"145":1}}],["共享资源",{"2":{"143":1}}],["读视图",{"2":{"280":1}}],["读锁不会阻塞其他客户端的读",{"2":{"271":1}}],["读是无限阻塞的",{"2":{"203":1}}],["读取的是记录数据的可见版本",{"2":{"280":1}}],["读取的是记录的最新版本",{"2":{"280":1}}],["读取时还要保证其他并发事务不能修改当前记录",{"2":{"280":1}}],["读取",{"2":{"158":1,"177":1}}],["读取到的还是var未修改值",{"2":{"145":1}}],["读写性能上",{"2":{"145":1}}],["工作内存",{"2":{"145":1}}],["工作队列",{"0":{"133":1}}],["结构如下图",{"2":{"145":1}}],["变量值",{"2":{"265":1}}],["变量类型就是数据库字段类型",{"2":{"265":1}}],["变量类型",{"2":{"265":1}}],["变量名",{"2":{"265":4}}],["变量",{"2":{"265":3}}],["变量修改后",{"2":{"146":1}}],["变量会先缓存到本地工作内存中使用",{"2":{"145":1}}],["变量计算前保留一份旧值a",{"2":{"144":1}}],["三",{"0":{"146":1}}],["三级缓存",{"2":{"145":1}}],["三种方式的区别",{"0":{"103":1},"1":{"104":1,"105":1,"107":1,"108":1,"109":1,"110":1,"111":1}}],["二级索引通常是非唯一的",{"2":{"276":1}}],["二级索引",{"2":{"257":1}}],["二级",{"2":{"145":1}}],["二",{"0":{"145":1}}],["操作效率高",{"2":{"262":1}}],["操作如下",{"2":{"262":1}}],["操作的字段建立索引",{"2":{"261":1}}],["操作",{"2":{"183":1}}],["操作等",{"2":{"180":1}}],["操作同步资源",{"2":{"175":1}}],["操作结束",{"2":{"144":1}}],["操作系统的设计者巧妙地利用了时间片轮转的方式",{"0":{"44":1}}],["操作系统通过进程管理计算机的资源",{"0":{"9":1}}],["重做日志缓冲",{"2":{"277":1,"279":1}}],["重做日志",{"2":{"277":1,"279":1}}],["重量级锁",{"2":{"187":1,"188":1}}],["重排序会遵循as",{"2":{"161":1}}],["重排过程中会遵循as",{"2":{"146":1}}],["重复一遍操作",{"2":{"144":1}}],["重复此过程",{"2":{"135":1}}],["重新获取内存中变量值",{"2":{"144":1}}],["加快处理速度",{"2":{"275":1}}],["加的行锁与表锁的冲突",{"2":{"271":1}}],["加mdl写锁",{"2":{"271":1}}],["加mdl读锁",{"2":{"271":1}}],["加载到表结构中",{"2":{"262":1}}],["加载后的业务逻辑",{"2":{"175":1}}],["加上参数",{"2":{"262":1}}],["加锁后整个实例就处于只读状态",{"2":{"270":1}}],["加锁成功之后会执行cas操作",{"2":{"178":1}}],["加锁需要消耗的资源太多",{"2":{"145":1}}],["加锁是万能的操作",{"2":{"145":1}}],["加锁",{"2":{"145":1,"146":1,"271":1}}],["加锁synchronized",{"2":{"144":1}}],["加一",{"2":{"144":1}}],["两者皆可",{"2":{"204":1}}],["两者区别",{"0":{"36":1}}],["两个或以上线程井发的在同一个对象上进行同步时",{"2":{"191":1}}],["两个线程a",{"2":{"144":1}}],["赋值",{"2":{"144":1,"158":1,"265":2}}],["取值",{"2":{"144":1}}],["理想情况下no最后的结果应该是1000",{"2":{"144":1}}],["严格的原子性的操作",{"2":{"144":1}}],["保持数据的一致性",{"2":{"278":1}}],["保留y位小数",{"2":{"221":1}}],["保证读写的正确性",{"2":{"271":1}}],["保证数据的完整性",{"2":{"270":1}}],["保证数据的完整性和正确性",{"2":{"246":1}}],["保证事务在不受外部并发操作影响的独立环境下运行",{"2":{"238":1,"279":1}}],["保证多个线程使用的是同一个atomicinteger",{"2":{"176":1}}],["保证多个线程使用的是同一个lock对象的前提下",{"2":{"175":1}}],["保证load1的读操作已读取结束",{"2":{"164":1}}],["保证load1的读取操作在load2及后续读取操作之前执行",{"2":{"164":1}}],["保证store1的写操作已刷新到主内存之后",{"2":{"164":1}}],["保证store1的写操作已刷新到主内存",{"2":{"164":1}}],["保证原子性需要借助synchronized这样的锁机制",{"2":{"161":1}}],["保证同一时刻只有一个线程进行操作",{"2":{"146":1}}],["保证同一时间只有一个线程操作变量",{"2":{"144":1}}],["保证代码执行的顺序与程序的顺序一致",{"2":{"143":1}}],["保活",{"2":{"138":1}}],["确保索引记录间隙不变",{"2":{"272":1}}],["确保数据不会被别的线程修改",{"2":{"175":1}}],["确保共享变量的修改对于其他线程是可见的",{"2":{"143":1}}],["确保任务对了",{"0":{"124":1}}],["提交事务",{"2":{"237":1}}],["提供了访问数据库元数据的各种表和视图",{"2":{"282":1}}],["提供回滚",{"2":{"279":1}}],["提供的一个可以方便地进行低级内存操作的类",{"2":{"180":1}}],["提供内存屏障功能",{"2":{"160":1}}],["提供互斥访问",{"2":{"143":1}}],["提高查询效率",{"2":{"261":1}}],["提高区间访问的性能",{"2":{"256":1}}],["提高数据检索的效率",{"2":{"255":1}}],["提高并发访问性能",{"2":{"246":1}}],["提高了并发性",{"2":{"172":1}}],["提高线程的可管理性",{"0":{"118":1}}],["提高响应速度",{"0":{"117":1}}],["才会引发interruptedexception异常",{"2":{"196":1}}],["才会将",{"2":{"180":1}}],["才会抛出",{"2":{"127":1}}],["才保证其正确性",{"2":{"143":1}}],["有可能是历史数据",{"2":{"280":1}}],["有了change",{"2":{"276":1}}],["有效性是所有数据库必须解决的一个问题",{"2":{"269":1}}],["有not",{"2":{"262":1}}],["有时候需要索引很长的字符串",{"2":{"260":1}}],["有序",{"2":{"253":1}}],["有序性就基本讲完了",{"2":{"146":1}}],["有序性",{"0":{"146":1},"2":{"143":2,"161":1}}],["有任意一个满足即可",{"2":{"232":1}}],["有些人可能一直买不到票",{"2":{"197":1}}],["有些使用这个操作是非常有必要的",{"2":{"196":1}}],["有的jvm需要8字节对齐",{"2":{"189":1}}],["有个do",{"2":{"181":1}}],["有依赖的变量c在变量a和b之后处理即可",{"2":{"146":1}}],["有两种方式",{"2":{"144":1}}],["有以下4种取值",{"0":{"135":1}}],["函数来实现",{"2":{"141":1}}],["为mysql服务器运行时状态提供了一个底层监控功能",{"2":{"282":1}}],["为删除并且它的空间变得允许被其他记录声明使用",{"2":{"262":1}}],["为4",{"2":{"256":1}}],["为5",{"2":{"256":1}}],["为了保证页的连续性",{"2":{"274":1}}],["为了保证处理器资源的充分利用",{"2":{"146":1}}],["为了避免dml在执行时",{"2":{"271":1}}],["为了避免dml与ddl冲突",{"2":{"271":1}}],["为了避免无用自旋消耗cpu",{"2":{"191":1}}],["为了确定检查的范围",{"2":{"264":1}}],["为了优化程序性能",{"2":{"146":1}}],["为了提高效率会将数据先取到缓存中",{"2":{"145":1}}],["为0",{"2":{"141":1}}],["为什么会有公平锁",{"0":{"198":1}}],["为什么还要inheritablethreadlocal",{"2":{"154":1}}],["为什么execute也可以执行带返回值的线程",{"2":{"127":1}}],["为什么用线程池",{"0":{"112":1},"1":{"113":1,"114":1,"115":1,"116":1,"117":1,"118":1}}],["换句话说",{"2":{"141":1}}],["状态码",{"2":{"265":1}}],["状态信息",{"2":{"259":1}}],["状态切换",{"2":{"141":5}}],["状态说明",{"2":{"141":5}}],["help",{"2":{"283":1}}],["helper",{"2":{"162":9}}],["host=name\\t\\t\\t\\t指定服务器ip或域名",{"2":{"283":1}}],["host=name",{"2":{"283":1}}],["h",{"2":{"217":1,"283":2}}],["https",{"2":{"210":1}}],["high",{"2":{"141":1,"210":1}}],["have",{"2":{"259":1}}],["having",{"2":{"220":2,"264":1}}],["happens",{"2":{"143":1}}],["hash",{"2":{"256":1,"276":2}}],["hash索引是存储引擎根据b+tree索引在指定条件下自动构建的",{"2":{"256":1}}],["hash索引只能用于对等比较",{"2":{"256":1}}],["hash索引的特点",{"2":{"256":1}}],["hash索引",{"2":{"248":1,"256":1}}],["has",{"2":{"139":2}}],["handler",{"0":{"135":1},"2":{"265":4}}],["移除工作线程",{"2":{"140":1}}],["移除该工作线程",{"2":{"140":1}}],["包含了一系列方便dba和开发人员利用performance",{"2":{"282":1}}],["包含数据库",{"2":{"282":1}}],["包含读取数据语句",{"2":{"266":1}}],["包含以下几种",{"2":{"256":1}}],["包中的很多并发工具类都是依赖",{"2":{"180":1}}],["包括在select语句执行过程中表如何连接和连接的顺序",{"2":{"259":1}}],["包括但不限于直接访问对象字段",{"2":{"180":1}}],["包括更新已完成任务数",{"2":{"140":1}}],["包结构如下",{"0":{"5":1}}],["以循环方式写入重做日志文件",{"2":{"277":1}}],["以及重做日志文件",{"2":{"277":1,"279":1}}],["以及对已添加的任务进行处理",{"2":{"141":1}}],["以防止幻读",{"2":{"272":1}}],["以使其符合视图的定义",{"2":{"264":1}}],["以一颗最大度数",{"2":{"256":2}}],["以下插件不安装并不会影响整体使用体验",{"2":{"211":1}}],["以上代码主要是处理工作线程退出的过程",{"2":{"140":1}}],["以允许具有相同优先级的其他线程获得运行机会",{"2":{"63":1}}],["说明事务是在readview生成后才开启",{"2":{"280":1}}],["说明数据已经提交",{"2":{"280":1}}],["说明数据已经提交了",{"2":{"280":1}}],["说明数据是当前这个事务更改的",{"2":{"280":1}}],["说明这玩意更可靠",{"2":{"178":1}}],["说明",{"2":{"164":1,"207":1,"208":1,"209":1,"210":1,"212":1,"213":1,"214":1,"215":1,"216":1,"271":1,"272":1}}],["说明不需要替换新的工作线程",{"2":{"140":1}}],["说白了就是并发场景进行多线程编程的工具类",{"0":{"5":1}}],["允许获取排他锁的事务更新数据",{"2":{"272":1}}],["允许一个事务去读一行",{"2":{"272":1}}],["允许核心线程超时的情况下",{"2":{"140":1}}],["允许中断",{"2":{"140":1}}],["进去",{"2":{"262":1}}],["进行数据恢复使用",{"2":{"277":1,"279":1}}],["进行相应的处理",{"2":{"141":1}}],["进行以下操作",{"2":{"140":1}}],["进程才会结束",{"0":{"74":1}}],["进程需要等待所有的线程执行完毕后",{"0":{"74":1}}],["进程之间不共享全局变量",{"0":{"22":1}}],["进程是基本的资源分配单位",{"0":{"9":1}}],["进程",{"0":{"7":1},"1":{"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1}}],["释放锁资源不同",{"2":{"184":1}}],["释放锁",{"2":{"140":1,"271":1}}],["需要通过create",{"2":{"277":1}}],["需要通过关键字delimiter指定sql语句的结束符",{"2":{"265":1}}],["需要手动在select之后加for",{"2":{"272":1}}],["需要手动在select之后加lock",{"2":{"272":1}}],["需要declare声明",{"2":{"265":1}}],["需要把数据一行一行地从索引里面读出来",{"2":{"262":1}}],["需要在mysql的配置文件",{"2":{"259":1}}],["需要比较当前线程threadid和对象mark",{"2":{"191":1}}],["需要从操作系统的cpu",{"2":{"145":1}}],["需要保证这种不可分割操作的原子性",{"2":{"144":1}}],["需要进入阻塞状态等待操作结束",{"2":{"144":1}}],["需要减一",{"2":{"140":1}}],["需要按照先后顺序执行",{"0":{"32":1}}],["则建立hash索引",{"2":{"276":1}}],["则从磁盘加载并缓存",{"2":{"275":1}}],["则继续下一次循环",{"2":{"265":1}}],["则退出",{"2":{"265":1}}],["则执行逻辑",{"2":{"265":1}}],["则该视图不可更新",{"2":{"264":1}}],["则不使用索引",{"2":{"260":1}}],["则不是这样",{"2":{"197":1}}],["则没有使用索引",{"2":{"259":1}}],["则innodb会自动生成一个rowid作为隐藏的聚集索引",{"2":{"257":1}}],["则需要在此补齐",{"2":{"189":1}}],["则根据不同的实现方式执行不同的操作",{"2":{"176":1}}],["则会阻塞等待",{"2":{"140":1}}],["则中断线程",{"2":{"140":1}}],["继续执行当前程序",{"2":{"265":1}}],["继续循环",{"2":{"140":1}}],["继承关系如下",{"2":{"154":1}}],["继承thread类并重写run的方法",{"0":{"101":1}}],["超时时间等待获取任务",{"2":{"140":1}}],["超时",{"2":{"140":1}}],["超出数量的线程排队等候",{"0":{"114":1}}],["或没有合适的唯一索引",{"2":{"257":1}}],["或多个",{"2":{"256":1}}],["或断电问题的影响",{"2":{"248":1}}],["或允许核心线程超时并且上一次poll",{"2":{"140":1}}],["或者",{"2":{"140":1}}],["或者当join的线程执行结束",{"0":{"89":1}}],["或者被中断时可以进入runnable状态",{"0":{"86":1}}],["或者join的线程运行结束",{"0":{"86":1}}],["或者使用第三方协程库quasar",{"0":{"19":1}}],["query",{"2":{"210":1,"259":7}}],["queue",{"2":{"140":1}}],["quot",{"0":{"34":2},"2":{"199":1}}],["lnnodb使用next",{"2":{"272":1}}],["lnnodb在repeatable",{"2":{"272":1}}],["lnnodb",{"2":{"271":1}}],["leaf",{"2":{"274":2}}],["leave",{"2":{"265":1}}],["level",{"2":{"240":1}}],["left",{"2":{"226":1}}],["length",{"2":{"251":1}}],["len",{"2":{"221":1,"259":1}}],["lpad",{"2":{"221":1}}],["list",{"2":{"265":5}}],["list1",{"2":{"265":1}}],["lines",{"2":{"262":1}}],["linux版",{"0":{"251":1}}],["lib",{"2":{"259":1}}],["like",{"2":{"220":1,"246":1,"259":1,"265":1}}],["limit优化",{"2":{"262":1}}],["limit",{"2":{"220":2,"262":1}}],["lt",{"2":{"220":3,"231":3,"233":1,"256":1,"260":1,"262":2,"280":3}}],["ltos",{"2":{"165":2}}],["ll",{"2":{"204":1}}],["lbit+锁标志位",{"2":{"191":1}}],["label",{"2":{"265":4}}],["language",{"2":{"210":1}}],["lang",{"2":{"196":1}}],["lambda表达式",{"2":{"172":1}}],["lazyset",{"2":{"168":3}}],["lazyinitdemo",{"2":{"162":1}}],["last",{"2":{"140":1}}],["loop可以配合一下两个语句使用",{"2":{"265":1}}],["loop实现简单的循环",{"2":{"265":1}}],["loop",{"2":{"265":3}}],["log版本链",{"2":{"280":1}}],["log采用段的方式进行管理和记录",{"2":{"279":1}}],["log存储",{"2":{"279":1}}],["log因为这些日志可能还用于mvcc",{"2":{"279":1}}],["log在事务执行时产生",{"2":{"279":1}}],["log销毁",{"2":{"279":1}}],["log中的逻辑记录读取到相应的内容并进行回滚",{"2":{"279":1}}],["log中会记录一条对应的insert记录",{"2":{"279":1}}],["log记录物理日志不一样",{"2":{"279":1}}],["log和redo",{"2":{"279":1}}],["log可能不用了",{"2":{"278":1}}],["logfile1",{"2":{"277":1}}],["logfile0",{"2":{"277":1}}],["log日志",{"2":{"277":1,"280":1}}],["log",{"2":{"259":1,"262":1,"276":3,"277":3,"278":2,"279":5,"280":1,"283":2}}],["log=1",{"2":{"259":1}}],["local",{"2":{"262":4,"264":2}}],["localhost",{"2":{"259":1}}],["lock退化为间隙锁",{"2":{"272":1}}],["lock锁适合大量同步的代码同步问题",{"2":{"204":1}}],["lock中断方式",{"2":{"204":1}}],["lock可以判断是否获取到锁",{"2":{"204":1}}],["lock是个java类",{"2":{"204":1}}],["lock是显示锁",{"2":{"193":1}}],["lockinterruptibly",{"2":{"196":5}}],["locking",{"2":{"162":1}}],["lock=lock",{"2":{"196":1}}],["lock2",{"2":{"196":5}}],["locks",{"2":{"196":4,"271":2,"272":1}}],["locksupport",{"0":{"90":1}}],["lock1",{"2":{"195":4,"196":5}}],["lock指令不是一种内存屏障",{"2":{"161":1}}],["lock前缀",{"2":{"161":1}}],["lock等等",{"2":{"146":1}}],["lock和原子类",{"2":{"144":1}}],["lock",{"2":{"140":2,"143":3,"158":1,"175":2,"190":2,"191":1,"196":3,"271":13,"272":7,"280":1}}],["lower",{"2":{"221":1}}],["loadstore屏障",{"2":{"165":1}}],["loadstore",{"2":{"164":2}}],["load2及其后的操作才能执行",{"2":{"164":1}}],["load2",{"2":{"164":2}}],["load1",{"2":{"164":2}}],["loadload屏障",{"2":{"165":1}}],["loadload",{"2":{"164":2}}],["load",{"2":{"158":1,"262":1}}],["longvalue",{"2":{"172":1}}],["longaccumulator",{"2":{"167":1,"172":3}}],["longadder适合的场景是统计求和计数的场景",{"2":{"172":1}}],["longadder把不同线程对应到不同的cell上进行修改",{"2":{"172":1}}],["longadder",{"2":{"167":1,"172":3}}],["long",{"2":{"126":1,"165":3,"179":5,"204":1,"259":2}}],["处理器不做任何操作",{"2":{"178":1}}],["处理器和运行时会对代码指令进行重排",{"2":{"146":1}}],["处理任务的异常情况",{"2":{"140":1}}],["处理worker退出",{"2":{"140":1}}],["处理过程中将任务放入队列",{"0":{"114":1}}],["已经更新操作的事务提交语句都将被阻塞",{"2":{"270":1}}],["已完成的任务数加1",{"2":{"140":1}}],["已达到",{"0":{"34":1}}],["抛出异常",{"2":{"140":1}}],["x版本中还包含innodb数据字典",{"2":{"277":1}}],["xml",{"2":{"189":1}}],["x+y",{"2":{"172":1}}],["x",{"2":{"172":1,"221":5,"272":3}}],["xushu=new",{"2":{"171":1}}],["xushu",{"2":{"170":2,"171":3}}],["xxxxx",{"2":{"283":1}}],["xxxx",{"2":{"260":1,"277":1}}],["xxx代表的是表名",{"2":{"246":1}}],["xxx",{"2":{"246":1,"247":3,"248":1,"265":1,"271":1,"277":1}}],["xx",{"2":{"160":3}}],["xcomp",{"2":{"160":1}}],["x26",{"2":{"140":12,"165":2}}],["x3c",{"2":{"96":1,"97":4,"126":1,"127":3,"136":2,"138":2,"141":12,"144":1,"152":7,"153":3,"154":4,"170":2,"171":1,"189":10,"260":3,"264":5,"283":16}}],["上下合并",{"2":{"228":1}}],["上下文非常频繁",{"0":{"42":1}}],["上下文切换",{"0":{"41":1},"1":{"42":1,"43":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1,"50":1,"51":1}}],["上面三个方法都是类似的",{"2":{"179":1}}],["上锁worker",{"2":{"140":1}}],["获得了共享锁以后可以查看但无法修改和删除数据",{"2":{"203":1}}],["获得了以后既能读又能写",{"2":{"202":1}}],["获得当前的cpu核心数在并发编程中很重要",{"0":{"40":1}}],["获取游标记录",{"2":{"265":1}}],["获取日期中的日",{"2":{"221":1}}],["获取日期中的月",{"2":{"221":1}}],["获取日期中的年",{"2":{"221":1}}],["获取倒锁后",{"2":{"195":1}}],["获取到了锁",{"2":{"195":1}}],["获取并且递增",{"2":{"168":1}}],["获取值",{"2":{"168":1}}],["获取锁时",{"2":{"196":1}}],["获取锁的时间我们是不知道的",{"2":{"194":1}}],["获取锁的顺序按照线程到达的先后顺序获取",{"2":{"193":1}}],["获取锁",{"2":{"140":1}}],["获取当前工作的worker数量",{"2":{"140":1}}],["获取当前线程",{"2":{"140":1}}],["获取ctl的值",{"2":{"140":1}}],["获取worker的第一个任务",{"2":{"140":1}}],["缺点是可能会导致主线程阻塞",{"2":{"139":1}}],["缺点是在某些情况下可能会丢失一些重要数据",{"2":{"139":1}}],["伪",{"2":{"138":1}}],["n行数据",{"2":{"262":1}}],["n为字符数",{"2":{"260":1}}],["number",{"2":{"177":2,"214":1}}],["null约束",{"2":{"262":2}}],["null约束它",{"2":{"261":1}}],["null",{"2":{"137":1,"138":1,"140":9,"152":1,"162":4,"218":1,"220":1,"222":1}}],["navigation",{"2":{"216":1}}],["name",{"2":{"195":2,"196":2,"218":1,"258":6,"260":7,"262":2,"264":6,"265":8,"267":5,"271":3,"272":2,"277":3,"283":5}}],["name=",{"2":{"170":2}}],["native",{"2":{"179":3,"221":1}}],["nanoseconds",{"2":{"140":1}}],["non",{"2":{"274":1}}],["nonfairsync",{"2":{"197":2}}],["node",{"2":{"274":2}}],["now",{"2":{"221":1}}],["no取值还是1",{"2":{"144":1}}],["no初始值是1",{"2":{"144":1}}],["no可见性的问题在下一个小结讨论",{"2":{"144":1}}],["no++",{"2":{"144":1}}],["no",{"2":{"144":2,"266":1,"271":1,"283":3}}],["note",{"0":{"214":1},"2":{"214":1,"215":1}}],["notify时会分析",{"2":{"187":1}}],["notify基于monitor做的",{"2":{"187":1}}],["notifyall",{"2":{"187":1}}],["notify",{"2":{"187":1}}],["not",{"2":{"140":1,"218":2,"220":1,"222":1,"232":1,"233":1}}],["nothing",{"2":{"139":1}}],["nekomeowww",{"2":{"208":1}}],["needed",{"2":{"140":1}}],["necessary",{"2":{"140":1}}],["next",{"2":{"139":1,"272":2}}],["new表示将要或已经修改后的数据",{"2":{"267":1}}],["new表示将要或者已经新增的数据",{"2":{"267":1}}],["new和old",{"2":{"267":1}}],["newupdater",{"2":{"171":1}}],["newfixedthreadpool",{"2":{"153":1}}],["newfixedthreadpool创建一个固定长度的线程池",{"0":{"122":1}}],["newscheduledthreadpool创建一个固定长度的线程池",{"0":{"125":1}}],["newsinglethreadpoolexecutor创建一个单线程的executor",{"0":{"124":1}}],["newcachedthreadpool创建一个可缓存的线程池",{"0":{"123":1}}],["new",{"2":{"54":3,"97":5,"127":1,"136":4,"138":3,"139":1,"141":2,"144":2,"146":4,"152":5,"153":2,"154":6,"157":2,"162":1,"168":1,"169":2,"170":3,"172":3,"175":1,"176":1,"177":1,"178":1,"190":1,"191":6,"195":4,"196":4,"197":3}}],["n",{"2":{"137":1,"221":2,"260":1,"262":1,"283":1}}],["n=0",{"2":{"137":1}}],["general",{"2":{"277":2}}],["getnumber",{"2":{"177":1}}],["getname",{"2":{"136":1,"195":3}}],["getandadd",{"2":{"169":1}}],["getandset",{"2":{"168":3,"169":2}}],["getandincrement",{"2":{"168":3,"171":1,"177":1}}],["gethelper",{"2":{"162":1}}],["getmap",{"2":{"152":2}}],["gettask",{"2":{"140":2}}],["getqueue",{"2":{"139":1}}],["get",{"2":{"97":1,"127":3,"140":4,"152":2,"154":2,"168":24,"169":6,"170":6,"171":1,"172":1,"177":1,"178":2}}],["getruntime",{"0":{"39":1}}],["gap",{"2":{"272":1}}],["global级别开启profiling",{"2":{"259":1}}],["global",{"2":{"251":2,"259":1,"262":1,"265":7}}],["grant",{"2":{"221":1}}],["grants",{"2":{"221":1}}],["group",{"2":{"220":2,"261":1,"262":4,"264":1}}],["groupid>",{"2":{"189":1}}],["groupid>org",{"2":{"189":1}}],["git",{"0":{"212":1},"2":{"212":3}}],["given",{"2":{"139":1}}],["gt",{"2":{"136":4,"141":5,"145":3,"188":3,"196":2,"220":3,"221":1,"231":3,"233":1,"256":1,"260":1,"280":5}}],["个人理解",{"2":{"144":1}}],["个项目",{"2":{"136":1}}],["个菜",{"0":{"25":1}}],["+this",{"2":{"195":3,"196":1}}],["+classlayout",{"2":{"191":6}}],["+atomicref",{"2":{"170":2}}],["+aia",{"2":{"169":2}}],["+ai",{"2":{"168":12}}],["+value",{"2":{"169":1}}],["+printassembly",{"2":{"160":1}}],["+unlockdiagnosticvmoptions",{"2":{"160":1}}],["+=",{"2":{"140":1}}],["+",{"2":{"136":3,"139":3,"154":2,"178":4,"195":6}}],["0或者low",{"2":{"251":1}}],["01",{"2":{"190":1,"191":1}}],["00000001",{"2":{"190":1}}],["0",{"2":{"136":1,"140":2,"141":3,"144":1,"152":2,"153":1,"165":2,"168":3,"169":9,"177":1,"187":1,"190":1,"221":1,"237":1,"251":1,"276":2}}],["0l",{"2":{"136":1}}],["默认开启",{"2":{"283":1}}],["默认个数",{"2":{"278":1}}],["默认大小为16mb",{"2":{"276":1}}],["默认使用innodb存储引擎",{"2":{"275":1}}],["默认情况下",{"2":{"272":2,"274":1}}],["默认情况下我们创建的线程都是用户线程",{"0":{"74":1}}],["默认是session",{"2":{"265":1}}],["默认是开启指针压缩所以是四个字节",{"2":{"189":1}}],["默认值为cascaded",{"2":{"264":1}}],["默认256k",{"2":{"262":1}}],["默认为当前数据库",{"2":{"267":1}}],["默认为页的50",{"2":{"262":1}}],["默认为1",{"2":{"222":1}}],["默认profile是关闭的",{"2":{"259":1}}],["默认10秒",{"2":{"259":1}}],["默认自动创建",{"2":{"257":1}}],["默认",{"2":{"248":1,"265":1}}],["默认约束",{"2":{"222":1}}],["默认拒绝策略",{"2":{"136":1}}],["默认线程工厂",{"2":{"136":1}}],["由insert",{"2":{"271":1}}],["由语句select",{"2":{"271":1}}],["由于服务器生成的二进制日志文件以二进制格式保存",{"2":{"283":1}}],["由于收到硬件影响",{"2":{"248":1}}],["由于现在大多计算机都是多核cpu",{"0":{"42":1}}],["由四部分组成",{"2":{"189":1}}],["由调用线程处理该任务",{"2":{"135":1}}],["丢弃队列最前面的任务",{"2":{"135":1}}],["拒绝策略",{"0":{"135":1}}],["when",{"2":{"221":4,"265":4}}],["where之后包含了子查询",{"2":{"259":1}}],["where",{"2":{"219":2,"220":3,"225":1,"229":1,"259":1,"260":6,"261":1,"262":3,"264":6,"265":1}}],["while循环是有条件的循环控制语句",{"2":{"265":1}}],["while",{"2":{"140":1,"157":1,"181":1,"265":3}}],["which",{"2":{"139":3,"208":1}}],["within",{"2":{"214":1}}],["with",{"2":{"212":1,"221":1,"264":6}}],["waitset中的thread",{"2":{"187":1}}],["waitset",{"2":{"187":1}}],["wait可以不设置时间",{"2":{"184":1}}],["wait",{"0":{"184":1},"2":{"187":1}}],["waiting有时限等待状态",{"2":{"184":1}}],["waiting",{"2":{"157":1}}],["waiting而言",{"0":{"89":1}}],["waiting中执行notify",{"0":{"88":1}}],["waiting进入runnable",{"0":{"85":1,"87":1},"1":{"86":1,"88":1,"89":1,"90":1}}],["write兼容",{"2":{"271":2}}],["write",{"2":{"158":1,"271":7,"278":1}}],["weakrefenrence",{"2":{"152":1}}],["wc",{"2":{"140":4}}],["wt",{"2":{"140":4}}],["w",{"2":{"140":11}}],["word中的指针指向的是monitor对象",{"2":{"191":1}}],["word中的threadld是否一致",{"2":{"191":1}}],["word中",{"2":{"191":1}}],["word中就被设置monitor对象的指针",{"2":{"187":1}}],["workers",{"2":{"140":2}}],["workercountof",{"2":{"140":2}}],["worker",{"2":{"140":4}}],["workqueue",{"0":{"133":1},"2":{"140":5}}],["would",{"2":{"139":1}}],["秒",{"2":{"132":1,"259":1}}],["千分之一秒",{"2":{"132":1}}],["毫秒",{"2":{"132":1}}],["百万分之一秒",{"2":{"132":1}}],["微秒",{"2":{"132":1}}],["​\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t⬆️",{"2":{"264":3}}],["​\\t乐观锁认为自己在使用数据时不会有别的线程修改数据",{"2":{"176":1}}],["​\\tthreadpoolexecutor",{"2":{"135":4}}],["​\\tpriorityblockingqueue",{"2":{"133":1}}],["​\\tlinkedblockingqueue",{"2":{"133":1}}],["​\\tarrayblockingqueue",{"2":{"133":1}}],["​\\tdays",{"2":{"132":1}}],["​\\thours",{"2":{"132":1}}],["​\\tseconds",{"2":{"132":1}}],["​\\tminutes",{"2":{"132":1}}],["​\\tmilliseconds",{"2":{"132":1}}],["​\\tmicroseconds",{"2":{"132":1}}],["​\\tnanoseconds",{"2":{"132":1}}],["十亿分之一秒",{"2":{"132":1}}],["纳秒",{"2":{"132":1}}],["天",{"0":{"132":1},"2":{"132":1}}],["最小活跃事务id",{"2":{"280":1}}],["最小值为0",{"2":{"140":1}}],["最近修改事务id",{"2":{"280":1}}],["最近更新",{"2":{"1":1}}],["最左列开始",{"2":{"260":1}}],["最左前缀法则指的是查询从索引的",{"2":{"260":1}}],["最左前缀法则",{"2":{"260":1}}],["最常见的索引类型",{"2":{"256":1}}],["最常采用的是cas算法",{"2":{"176":1}}],["最终还是可以等到资源的",{"2":{"197":1}}],["最终导致的结果是",{"2":{"197":1}}],["最终只有2种结果",{"2":{"196":1}}],["最多只能有一个保持者",{"2":{"182":1}}],["最后返回累加值",{"2":{"262":1}}],["最后结果是2",{"2":{"144":1}}],["最后的结果为什么不是1000呢",{"2":{"144":1}}],["最后处理",{"2":{"140":1}}],["最大21",{"2":{"136":2}}],["最大线程数",{"2":{"136":1}}],["最大线程数量",{"0":{"130":1}}],["核心后台线程",{"2":{"278":1}}],["核心1",{"2":{"136":2}}],["核心线程在首次使用被创建的时候正确复制父线程的上下文",{"2":{"154":1}}],["核心线程数",{"2":{"136":1}}],["核心线程池数量",{"0":{"129":1}}],["核越多",{"0":{"29":1}}],["原子变量可以把竞争范围缩小到变量级别",{"2":{"166":1}}],["原子类的作用和锁类似",{"2":{"166":1}}],["原子类",{"0":{"166":1},"1":{"167":1}}],["原子性针对完整的操作过程",{"2":{"146":1}}],["原子性的操作是不可被中断的一个或一系列操作",{"2":{"144":1}}],["原子性",{"0":{"144":1},"2":{"143":1,"161":1,"238":1,"279":1}}],["原理",{"0":{"128":1},"1":{"129":1,"130":1,"131":1,"132":1,"133":1,"134":1,"135":1}}],["原因就在于线程不能被重复启动",{"2":{"60":1}}],["异常",{"2":{"127":1}}],["返回给服务层",{"2":{"262":3}}],["返回default默认值",{"2":{"221":1}}],["返回date1到date2的天数",{"2":{"221":1}}],["返回res1",{"2":{"221":1}}],["返回value2",{"2":{"221":1}}],["返回value1",{"2":{"221":1}}],["返回当前时间日期",{"2":{"221":1}}],["返回当前时间",{"2":{"221":1}}],["返回当前日期",{"2":{"221":1}}],["返回当前线程的中断状态",{"0":{"69":1}}],["返回",{"2":{"221":2}}],["返回时非常方便",{"2":{"215":1}}],["返回false",{"2":{"195":1}}],["返回获取到的任务",{"2":{"140":1}}],["返回null表示没有任务可执行",{"2":{"140":2}}],["返回值",{"2":{"127":1,"168":1}}],["参数完成不加锁的一致性数据备份",{"2":{"270":1}}],["参数类型",{"2":{"265":1}}],["参数名",{"2":{"265":1}}],["参数列表",{"2":{"265":1,"266":1}}],["参数不同",{"2":{"184":1}}],["参数",{"2":{"127":1,"246":1,"265":2,"276":2,"277":2}}],["了",{"2":{"126":1}}],["终止执行当前程序",{"2":{"265":1}}],["终止",{"2":{"126":1}}],["等",{"2":{"259":1,"264":1}}],["等future",{"2":{"127":1}}],["等待线程池中所有的线程执行完",{"2":{"126":1}}],["等待线程池关闭",{"2":{"126":1}}],["等其他线程执行完毕",{"0":{"114":1}}],["问题",{"2":{"126":1}}],["fetch和close",{"2":{"265":1}}],["flush",{"2":{"276":1}}],["flaged",{"2":{"262":1}}],["floor",{"2":{"221":1}}],["float",{"2":{"165":3}}],["free",{"2":{"275":1}}],["frm",{"2":{"246":1}}],["from\\t\\t\\t\\t",{"2":{"283":1}}],["from",{"2":{"139":1,"219":1,"220":8,"221":2,"225":2,"226":2,"227":1,"228":2,"229":2,"258":1,"259":1,"260":7,"262":9,"264":7,"265":3,"271":2,"272":1,"283":1}}],["f",{"2":{"221":2}}],["fulltext",{"2":{"257":1}}],["full",{"2":{"256":1}}],["function",{"2":{"266":1}}],["fun",{"2":{"209":1}}],["future",{"2":{"97":3,"127":7}}],["futuretask",{"2":{"97":2,"127":2}}],["future本身也是一种设计模式",{"0":{"96":1}}],["future这几个类",{"0":{"96":1}}],["found捕获的sqlstate代码的简写",{"2":{"265":1}}],["found",{"2":{"265":1}}],["folder",{"2":{"214":1}}],["footnotes",{"0":{"209":1},"2":{"209":2}}],["force",{"2":{"260":2}}],["foreign",{"2":{"222":1}}],["formatting",{"2":{"216":1}}],["for",{"2":{"136":1,"139":1,"140":1,"144":1,"152":2,"153":1,"207":1,"210":1,"214":1,"215":1,"221":1,"259":2,"265":2,"267":1,"271":2,"272":1,"280":1}}],["fairsync",{"2":{"197":1}}],["fair",{"2":{"197":2}}],["false表示获取锁失败",{"2":{"194":1}}],["false",{"2":{"140":4,"155":1,"157":2,"195":1,"196":5}}],["ftos",{"2":{"165":2}}],["filtered的值越大越好",{"2":{"259":1}}],["filtered",{"2":{"259":1}}],["file=name\\t\\t",{"2":{"283":1}}],["file",{"0":{"214":1},"2":{"214":2,"246":2,"277":4,"279":1}}],["files2",{"2":{"283":1}}],["files1",{"2":{"283":1}}],["filesort",{"2":{"262":1}}],["files",{"2":{"208":2,"210":1,"277":1}}],["fianlly",{"2":{"175":1}}],["fieldupdater升级类型原子类",{"2":{"167":1}}],["field",{"2":{"165":32}}],["fields",{"2":{"162":1,"262":1}}],["finish",{"2":{"146":4}}],["final",{"2":{"140":1,"141":9,"149":1,"153":1,"179":3}}],["finally",{"2":{"126":1,"136":1,"140":3,"195":1,"196":1}}],["firsttask",{"2":{"140":2}}],["db\\t\\t\\t不包含数据库的创建语句",{"2":{"283":1}}],["db3",{"2":{"283":1}}],["db2",{"2":{"283":1}}],["db1",{"2":{"283":1}}],["db",{"2":{"280":3,"283":3}}],["durabillity",{"2":{"279":1}}],["duration",{"2":{"271":1}}],["day",{"2":{"221":1}}],["datetime=date2",{"2":{"283":1}}],["date2",{"2":{"221":1}}],["date1",{"2":{"221":1}}],["datediff",{"2":{"221":1}}],["date",{"2":{"221":5,"265":1,"266":1}}],["data\\t\\t\\t\\t不包含数据",{"2":{"283":1}}],["datatime=date1",{"2":{"283":1}}],["datafile",{"2":{"277":1}}],["database语句",{"2":{"283":1}}],["database\\t\\t\\t在每个数据库创建语句前加上drop",{"2":{"283":1}}],["database=name",{"2":{"283":1}}],["database",{"2":{"218":3,"283":2}}],["databases",{"2":{"218":1,"283":1}}],["dataview",{"0":{"210":1},"2":{"210":1}}],["data",{"2":{"153":2,"157":3,"210":1,"262":1,"271":4,"272":2,"277":1}}],["dcl",{"0":{"221":1}}],["dql",{"0":{"220":1}}],["dml操作遵循acid模型",{"2":{"246":1}}],["dml",{"0":{"219":1}}],["drop",{"2":{"218":3,"221":1,"262":1,"283":4}}],["ddl语句",{"2":{"270":1}}],["ddl",{"0":{"218":1}}],["dy",{"2":{"215":1}}],["deterministic",{"2":{"266":1}}],["degree",{"2":{"256":2}}],["delete型触发器",{"2":{"267":1}}],["delete之前或之后",{"2":{"267":1}}],["delete时",{"2":{"255":1}}],["delete",{"2":{"219":1,"229":1,"259":1,"267":1,"271":2,"272":1,"280":1}}],["desc",{"2":{"218":1,"220":1,"259":1,"262":3}}],["default",{"2":{"218":1,"221":2,"222":1,"265":1}}],["defaultthreadfactory",{"2":{"136":1}}],["denolehov",{"2":{"212":1}}],["dependency>",{"2":{"189":2}}],["demo6$t",{"2":{"196":1}}],["demo6",{"2":{"196":2}}],["demo",{"2":{"144":2,"154":2}}],["decrementworkercount",{"2":{"140":2}}],["dirty",{"2":{"275":1}}],["distinct",{"2":{"220":2,"260":2,"264":1}}],["discarded",{"2":{"139":2}}],["discarding",{"2":{"139":1}}],["discardoldestpolicy",{"2":{"135":1,"139":4}}],["discardpolicy",{"2":{"135":1,"139":4}}],["did",{"2":{"140":1}}],["do",{"2":{"265":1}}],["doacquireinterruptibly",{"2":{"196":1}}],["doublewrite",{"2":{"277":1}}],["doubleaccumulator",{"2":{"167":1}}],["doubleadder",{"2":{"167":1}}],["double",{"2":{"162":1,"165":3}}],["down",{"2":{"139":2}}],["does",{"2":{"139":1}}],["d",{"0":{"125":1},"2":{"283":2}}],["会对读取的记录进行加锁",{"2":{"280":1}}],["会对机器指令重排优化",{"2":{"161":1}}],["会造成大量的磁盘io",{"2":{"276":1}}],["会造成数据混乱",{"2":{"143":1}}],["会访问到不满足条件的第一个值为止",{"2":{"272":1}}],["会导致该记录的undolog生成一条记录版本链表",{"2":{"280":1}}],["会导致主从延迟",{"2":{"270":1}}],["会导致内存泄漏",{"2":{"153":1}}],["会话变量",{"2":{"265":2}}],["会行溢出",{"2":{"262":1}}],["会影响增删改的效率",{"2":{"261":1}}],["会选择该索引完成本次查询",{"2":{"260":1}}],["会直接加轻量级锁",{"2":{"191":1}}],["会由jvm用户态切换到操作系统的管程来实现互斥",{"2":{"186":1}}],["会让没有得到锁资源的线程进入blocked状态",{"2":{"182":1}}],["会一直进行尝试",{"2":{"181":1}}],["会判断当前系统是否为多核系统",{"2":{"178":1}}],["会将预期值跟当前比较",{"2":{"168":1}}],["会将当前处理器缓存行的数据立即写回到系统内存",{"2":{"160":1}}],["会在每个线程内存中被创建多份",{"2":{"150":1}}],["会在子线程中抛出异常",{"2":{"127":1}}],["会把共享变量重新刷新到主内存中",{"2":{"145":1}}],["会清空工作内存中共享变量的值",{"2":{"145":1}}],["会执行钩子函数terminated",{"2":{"141":1}}],["会等待所有的任务执行完成之后才彻底关闭",{"2":{"126":1}}],["会增加线程数量",{"0":{"123":1}}],["会抛出interruptedexception",{"2":{"62":1}}],["将输出的文本格式输出到指定文件",{"2":{"283":1}}],["将会会生成该隐藏字段",{"2":{"280":1}}],["将会自动优化为行锁",{"2":{"272":1}}],["将page分为三种类型",{"2":{"275":1}}],["将使用第一个唯一索引",{"2":{"257":1}}],["将数据与索引分开存储",{"2":{"257":1}}],["将数据存储与索引放到了一块",{"2":{"257":1}}],["将键值换算成新的hash值",{"2":{"256":1}}],["将所用数据保存再内存中",{"2":{"250":1}}],["将s1",{"2":{"221":1}}],["将store过去的变量赋值给主内存中的变量",{"2":{"158":1}}],["将警告块样式的内容添加到",{"2":{"207":1}}],["将它new",{"2":{"189":1}}],["将内存值v修改为b",{"2":{"178":1}}],["将内存位置的值与预期原值比较",{"2":{"178":1}}],["将内存读取到数据写入到工作内存",{"2":{"158":1}}],["将主内存变量解锁",{"2":{"158":1}}],["将主内存变量加锁",{"2":{"158":1}}],["将工作内存数据写入主内存中",{"2":{"158":1}}],["将计算好的值重新赋值到工作内存中",{"2":{"158":1}}],["将回收空的线程",{"0":{"123":1}}],["将当前线程的中断状态设为false",{"0":{"70":1}}],["官方建议使用executors工厂类来创建线程池对象",{"0":{"120":1}}],["尤其是对于线程池的原理不是很清楚的情况下",{"0":{"120":1}}],["真正的线程池接口是java",{"0":{"120":1}}],["调优和监控",{"0":{"118":1}}],["调用",{"2":{"265":1}}],["调用存储过程可以简化应用开发人员的很多工作",{"2":{"265":1}}],["调用lockinterruptibly",{"2":{"204":1}}],["调用设置超时方法trylock",{"2":{"204":1}}],["调用sleep方法线程会进入timed",{"2":{"184":1}}],["调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁",{"2":{"182":1}}],["调用线程池的shutdownnow",{"2":{"141":1}}],["调用线程池的shutdown",{"2":{"141":1}}],["调用了",{"0":{"89":1}}],["调用次数",{"0":{"60":1}}],["还需要依赖于数据库记录中的三个隐式字段",{"2":{"280":1}}],["还包括脏页的刷新",{"2":{"278":1}}],["还包含很多的更新",{"2":{"250":1}}],["还负责将缓冲池中的数据异步刷新到磁盘中",{"2":{"278":1}}],["还可以根据实际情况选择多种存储引擎进行组合",{"0":{"250":1}}],["还是自旋锁",{"2":{"182":1}}],["还是加锁",{"2":{"146":1}}],["还是由调度器决定",{"2":{"63":1}}],["还未同步到内存时",{"2":{"145":1}}],["还会降低系统的稳定性",{"0":{"118":1}}],["当执行rollback时",{"2":{"279":1}}],["当update",{"2":{"279":1}}],["当事务提交之后会把所有修改信息都存到该日志文件中",{"2":{"279":1}}],["当事务提交之后会把所有修改信息都会存到该日志中",{"2":{"277":1}}],["当对表结构进行变更操作的时候",{"2":{"271":1}}],["当对一张表进行增删改查的时候",{"2":{"271":1}}],["当满足条件的时候退出循环",{"2":{"265":1}}],["当使用with",{"2":{"264":1}}],["当页中删除的记录达到merge",{"2":{"262":1}}],["当删除一行记录时",{"2":{"262":1}}],["当优化器知道每列是否包含null值时",{"2":{"261":1}}],["当字段类型为字符串",{"2":{"260":1}}],["当1个线程请求锁获取同步状态",{"2":{"198":1}}],["当采用非公平锁时",{"2":{"198":1}}],["当两个或以上线程",{"2":{"191":1}}],["当一个对象被创建出来后它在内存中的布局如下",{"2":{"189":1}}],["当thread",{"2":{"187":1}}],["当地一个线程执行cas",{"2":{"183":1}}],["当且仅当",{"2":{"180":1}}],["当前最大事务id+1",{"2":{"280":1}}],["当前活跃的事务id集合",{"2":{"280":1}}],["当前读",{"2":{"280":1}}],["当前锁类型",{"2":{"272":1}}],["当前仅当旧的预期值a和内存值v相同时",{"2":{"178":1}}],["当前线程将自己修改的数据成功写入",{"2":{"176":1}}],["当前工作的worker数量大于最大pool",{"2":{"140":1}}],["当其中某个cpu修改了缓存里的数据",{"2":{"159":1}}],["当多线程并发访问临界资源时",{"2":{"143":1}}],["当线程池在stop状态下",{"2":{"141":1}}],["当线程池在shutdown状态下",{"2":{"141":1}}],["当线程池变为tidying状态时",{"2":{"141":1}}],["当线程池处于shutdown或stop状态时",{"2":{"140":1}}],["当所有的任务已终止",{"2":{"141":1}}],["当所有的用户线程退出后",{"0":{"77":1}}],["当运行状态小于stop时",{"2":{"140":1}}],["当任务不为空时循环执行",{"2":{"140":1}}],["当任务到达时",{"0":{"117":1}}],["当阻塞队列为空",{"2":{"138":1}}],["当需求增加时",{"0":{"123":1}}],["当到达线程最大数量时",{"0":{"122":1}}],["控制最大并发数",{"0":{"115":1}}],["井不被销毁",{"0":{"109":1}}],["那些被经常使用的查询可以被定义为视图",{"2":{"264":1}}],["那就非常好了",{"2":{"194":1}}],["那要怎么做才能保证原子性呢",{"2":{"144":1}}],["那么innodb将对表中的所有记录加锁",{"2":{"272":1}}],["那么innodb存储引擎是比较合适的选择",{"2":{"250":1}}],["那么份期间从库不能执行主库同步过来的二进制日志",{"2":{"270":1}}],["那么在备份期间都不能执行更新",{"2":{"270":1}}],["那么涉及的索引都不会被用到",{"2":{"260":1}}],["那么选择这个存储引擎是非常合适的",{"2":{"250":1}}],["那么当锁a可用时",{"2":{"197":1}}],["那么它依然可以收到一个通知",{"2":{"196":1}}],["那么你一定达到回府",{"2":{"196":1}}],["那么该线程将循环等待",{"2":{"182":1}}],["那么处理器会自动将该位置值个更新为新值",{"2":{"178":1}}],["那么访问这个变量的每个线程都会有这个变量的一个本地拷贝",{"2":{"152":1}}],["那么怎么保证多个线程中的代码顺序一致性呢",{"2":{"146":1}}],["那么workercount没有进行调整",{"2":{"140":1}}],["那么有没有一种办法使得线程可以复用",{"0":{"109":1}}],["那是因为分时交替运行的时间是非常短的",{"0":{"26":1}}],["类似于lucene",{"2":{"256":1}}],["类似于timer",{"0":{"125":1}}],["类",{"2":{"180":1}}],["类的功能过于强大",{"2":{"180":1}}],["类的存在就是为了绕过",{"2":{"180":1}}],["类仅支持单继承",{"0":{"104":1}}],["类型",{"0":{"57":1},"2":{"167":1,"207":1,"208":1,"209":1,"210":1,"212":1,"213":1,"214":1,"215":1,"216":1,"218":2,"265":1}}],["e选项可以在mysql客户端执行sql语句",{"2":{"283":1}}],["ete一条记录时",{"2":{"279":1}}],["etc",{"2":{"259":1,"265":1}}],["eq",{"2":{"259":1}}],["es",{"2":{"256":1}}],["each",{"2":{"214":1,"215":1,"267":1}}],["elements",{"2":{"214":1}}],["else\\t\\t\\t\\t\\t",{"2":{"265":1}}],["elseif",{"2":{"265":1}}],["else",{"2":{"152":1,"165":15,"195":1,"196":1,"221":4,"265":2}}],["email",{"2":{"260":2}}],["embedding",{"2":{"208":1}}],["empty",{"2":{"140":1}}],["engines",{"2":{"244":1}}],["engine",{"2":{"243":1,"277":2}}],["end块",{"2":{"265":1}}],["end",{"2":{"157":1,"191":1,"221":4,"265":9,"266":1,"267":1}}],["entrylist",{"2":{"187":1}}],["entry对象也就被回收",{"2":{"153":1}}],["entry",{"2":{"152":2}}],["effect",{"2":{"139":1}}],["e",{"2":{"97":4,"126":3,"136":4,"139":13,"183":1,"191":4,"195":2,"196":2,"283":2}}],["exclusive",{"2":{"271":1}}],["exception",{"2":{"96":1,"97":1,"126":1,"136":2}}],["exist",{"2":{"218":2}}],["exists",{"2":{"218":1,"264":1,"265":1}}],["explain",{"2":{"259":1,"262":6}}],["explain或者desc命令获取mysql如何执行select语句的信息",{"2":{"259":1}}],["explain执行计划各字段的含义",{"2":{"259":1}}],["explain执行计划",{"2":{"259":1}}],["explorer",{"0":{"214":1},"2":{"214":2}}],["expr",{"2":{"221":2,"265":6}}],["expect",{"0":{"179":1}}],["extends",{"2":{"195":1,"196":1}}],["extend",{"2":{"152":1}}],["ex",{"2":{"140":3}}],["execution",{"2":{"139":1}}],["executionexception",{"2":{"97":1}}],["execute=name",{"2":{"283":1}}],["executes",{"2":{"139":1}}],["executed",{"2":{"139":4}}],["execute方法和submit有什么区别",{"2":{"127":1}}],["execute方法和submit方法区别",{"0":{"127":1}}],["execute",{"2":{"126":1,"127":4,"136":1,"139":6,"153":1}}],["executors",{"2":{"136":1,"153":1}}],["executors线程工厂类里面提供了一些静态工厂",{"0":{"120":1}}],["executorservice",{"0":{"120":1},"2":{"136":1,"153":5}}],["executor",{"0":{"120":1},"2":{"139":8}}],[">double",{"2":{"165":1}}],[">float",{"2":{"165":1}}],[">short",{"2":{"165":1}}],[">char",{"2":{"165":1}}],[">long",{"2":{"165":1}}],[">byte",{"2":{"165":1}}],[">obj",{"2":{"165":1}}],[">int",{"2":{"165":1}}],[">is",{"2":{"165":1}}],[">release",{"2":{"165":8}}],[">>",{"2":{"152":1,"165":2}}],[">=",{"2":{"140":1,"264":1}}],[">",{"2":{"97":2,"127":2,"138":1,"140":3,"152":4,"153":3,"154":2,"155":1,"157":2,"170":1,"172":1}}],["第三",{"0":{"118":1}}],["第二",{"0":{"117":1}}],["第一个获取锁的线程通过cas将自己的threadid写入到该对象的mark",{"2":{"191":1}}],["第一",{"0":{"116":1}}],["第一步",{"2":{"97":1}}],["第4步",{"2":{"97":1}}],["第3步",{"2":{"97":1}}],["第2步",{"2":{"97":1}}],["rr隔离级别下都支持",{"2":{"272":1}}],["ram",{"2":{"269":1}}],["range",{"2":{"259":1}}],["rand",{"2":{"221":1}}],["roll",{"2":{"274":1,"280":1}}],["rollback",{"2":{"237":1,"274":1}}],["row",{"2":{"267":1,"280":1}}],["rows",{"2":{"259":1}}],["routines",{"2":{"265":2}}],["round",{"2":{"221":1}}],["root",{"2":{"262":2,"283":1}}],["right",{"2":{"226":1}}],["rpad",{"2":{"221":1}}],["r",{"2":{"139":15,"140":3,"256":1,"283":1}}],["result",{"2":{"283":1}}],["res1",{"2":{"221":2}}],["redo",{"2":{"277":3,"279":3}}],["redolog",{"2":{"276":1}}],["record",{"2":{"272":1}}],["ref",{"2":{"259":2}}],["reference引用类型原子类",{"2":{"167":1}}],["replace",{"2":{"264":2}}],["replacement",{"2":{"140":1}}],["repeatable",{"2":{"280":2}}],["repeat是有条件的循环控制语句",{"2":{"265":1}}],["repeat",{"2":{"265":3}}],["repe",{"2":{"240":1}}],["revoke",{"2":{"221":1}}],["rename",{"2":{"218":1}}],["renmu123",{"2":{"213":1}}],["remember",{"0":{"215":1},"2":{"215":2}}],["remove",{"2":{"140":1,"153":1}}],["reentrantreadwritelock中读锁就是共享锁",{"2":{"203":1}}],["reentrantlock获取锁的过程是可以中断的",{"0":{"196":1}}],["reentrantlock刚好提供了这样功能",{"2":{"194":1}}],["reentrantlock锁申请等待限时",{"0":{"194":1}}],["reentrantlock是可中断的",{"2":{"193":1}}],["reentrantlock是lock的默认实现",{"2":{"193":1}}],["reentrantlock和关键字synchronized都是可重入锁",{"2":{"193":1}}],["reentrantlock",{"0":{"193":1},"1":{"194":1},"2":{"140":1,"175":2,"195":2,"196":7,"197":2}}],["reentranklock中必须使用实例方法locklnterruptibly",{"2":{"196":1}}],["release",{"2":{"165":2}}],["readview创建者的事务id",{"2":{"280":1}}],["readview中包了四个核心字段",{"2":{"280":1}}],["readview",{"2":{"280":2}}],["read事务隔离级别运行",{"2":{"272":2}}],["reads",{"2":{"266":1}}],["read",{"2":{"158":1,"240":3,"271":10,"278":1,"280":5}}],["retry",{"2":{"140":1}}],["retries",{"2":{"139":1}}],["returns",{"2":{"266":1}}],["return",{"2":{"97":2,"127":1,"140":4,"152":1}}],["rejected",{"2":{"139":1}}],["rejectedexecution",{"2":{"139":4}}],["rejectedexecutionexception",{"2":{"139":3}}],["rejectedexecutionhandler",{"2":{"139":4}}],["requested",{"2":{"139":4}}],["running",{"2":{"141":5}}],["runnable>",{"2":{"136":1,"138":1}}],["runnable",{"2":{"54":1,"127":1,"136":1,"138":1,"139":8,"140":3,"144":1,"146":4,"154":2,"191":3}}],["runstate",{"2":{"141":1}}],["runstatelessthan",{"2":{"140":1}}],["runstateatleast",{"2":{"140":4}}],["runworker",{"2":{"140":1}}],["runtimeexception",{"2":{"97":2,"195":1}}],["run方法可以被执行无数次",{"2":{"60":1}}],["run方法的作用是存放任务代码",{"2":{"58":1}}],["run方法是同步方法",{"2":{"57":1}}],["run",{"2":{"54":1,"127":1,"136":1,"138":2,"139":1,"140":1,"144":1,"146":3,"154":2,"191":3,"195":1,"196":2}}],["runable匿名内部类",{"2":{"54":1}}],["创建并删除数据库等",{"2":{"283":1}}],["创建",{"2":{"264":1,"265":1,"267":1}}],["创建索引后",{"2":{"262":2}}],["创建索引",{"2":{"258":1,"262":2}}],["创建用户",{"2":{"221":1}}],["创建表结构的语句",{"2":{"283":1}}],["创建表",{"2":{"218":1,"277":1}}],["创建数据库",{"2":{"218":1}}],["创建的对象状态为",{"2":{"191":1}}],["创建优先",{"2":{"136":1}}],["创建callable实现类实例",{"2":{"97":1}}],["创建callable实现的实例",{"2":{"97":1}}],["创建线程",{"0":{"52":1,"134":1},"1":{"53":1,"54":1,"55":1}}],["是快照读sql执行时mvcc提取数据的依据",{"2":{"280":1}}],["是非阻塞读",{"2":{"280":1}}],["是非公平锁",{"2":{"197":1}}],["是用来实现事务的持久性",{"2":{"277":1,"279":1}}],["是用来存储查询结果集的数据类型",{"2":{"265":1}}],["是系统根据情况自动完成",{"2":{"276":1}}],["是innodb存储引擎磁盘管理的最小单元",{"2":{"274":1}}],["是根据需要定义的在局部生效的变量",{"2":{"265":1}}],["是mysql服务提供",{"2":{"265":1}}],["是mysql的默认存储引擎",{"2":{"250":1}}],["是优化数据库的一个重要手段",{"2":{"260":1}}],["是帮助mysql高效获取数据的数据结构",{"2":{"253":1}}],["是线程1可获得锁还是线程2可获得锁呢",{"2":{"197":1}}],["是可以被中断的",{"2":{"196":1}}],["是指在同一个线程在外层方法获取锁的时候",{"2":{"192":1}}],["是指当一个线程在获取锁的时候",{"2":{"182":1}}],["是jvm层面实现的",{"2":{"187":1}}],["是一个比较重的操作",{"2":{"270":1}}],["是一个聚合函数",{"2":{"262":1}}],["是一个估计值",{"2":{"259":1}}],["是一个效率比较低下的锁",{"2":{"186":1}}],["是一组操作的集合",{"0":{"236":1},"1":{"255":1}}],["是一种虚拟存在的表",{"2":{"264":1}}],["是一种通过建立倒排序索引",{"2":{"256":1}}],["是一种无锁算法",{"2":{"176":1,"180":1}}],["是一种全能型的屏障",{"2":{"161":1}}],["是一种store",{"2":{"161":1}}],["是一种load",{"2":{"161":1}}],["是",{"2":{"180":1}}],["是否可以相应线程中断操作",{"2":{"193":1}}],["是否成功",{"2":{"168":1}}],["是否执行完成等信息",{"0":{"105":1}}],["是为了保证并发情况下的线程安全",{"2":{"166":1}}],["是相互不影响的",{"2":{"146":1}}],["是通过使用unsafe的compareandswap方法实现cas操作保证原子性的",{"2":{"144":1}}],["是范型",{"0":{"97":1}}],["是cpu快速的在多个线程之间的切换",{"0":{"48":1}}],["是cpu调度和分派的基本单位",{"0":{"11":1}}],["v3",{"2":{"264":2}}],["v2",{"2":{"264":4}}],["v1",{"2":{"264":4}}],["view",{"2":{"264":12,"280":1}}],["viewing",{"2":{"214":1}}],["visibilitytest",{"2":{"155":1}}],["version",{"2":{"280":1,"283":1}}],["version>",{"2":{"189":1}}],["version>0",{"2":{"189":1}}],["verify",{"2":{"165":2}}],["vault",{"2":{"212":1}}],["varchar",{"2":{"260":1,"265":1}}],["var",{"2":{"259":1,"265":8}}],["variables",{"2":{"246":1,"265":2}}],["var6",{"2":{"179":2}}],["var5",{"2":{"179":3}}],["var4",{"2":{"179":4}}],["var2",{"2":{"179":4}}],["var1为true",{"2":{"221":1}}],["var1",{"2":{"179":4,"221":2}}],["validate",{"2":{"251":2}}],["valentine195",{"2":{"207":1}}],["val为null的情况了",{"2":{"146":1}}],["val",{"2":{"146":4}}],["value2",{"2":{"221":1,"265":1}}],["value1为不为空",{"2":{"221":1}}],["value1",{"2":{"221":1,"265":1}}],["value为true",{"2":{"221":1}}],["values",{"2":{"219":4,"262":4}}],["value",{"2":{"97":1,"126":1,"152":5,"153":1,"154":6,"169":4,"221":1,"265":5}}],["v",{"2":{"152":2,"180":3,"183":1}}],["volatile保证了可见性",{"2":{"168":1}}],["volatile保证可见性与有序性",{"2":{"161":1}}],["volatile读",{"2":{"165":1}}],["volatile写",{"2":{"165":1}}],["volatilevisibilitytest",{"2":{"160":1}}],["volatilevisibiltitytest",{"2":{"157":1}}],["volatile缓存可见性实现原理",{"2":{"160":1}}],["volatile可见性底层实现原理",{"0":{"160":1}}],["volatile修饰的共享变量在修改后会立即被更新到内存中",{"2":{"145":1}}],["volatile",{"0":{"155":1},"2":{"143":1,"146":1,"155":1,"157":1,"162":2,"165":1}}],["volatile关键字具备两个特性",{"2":{"155":1}}],["volatile关键字",{"2":{"143":1}}],["void",{"2":{"54":2,"62":1,"64":1,"97":1,"127":1,"136":2,"138":1,"139":4,"140":2,"144":2,"146":4,"152":2,"153":1,"154":4,"155":1,"157":2,"168":1,"169":1,"170":1,"171":1,"172":1,"175":2,"177":2,"178":1,"191":5,"195":2,"196":2}}],["v>",{"2":{"96":1}}],["想要从blocked状态进入runable状态",{"0":{"84":1}}],["想要查看线程到底是用户线程还是守护线程",{"0":{"76":1}}],["book",{"2":{"283":1}}],["boolean",{"2":{"65":1,"66":1,"140":4,"146":1,"155":1,"157":2,"179":3,"197":1}}],["bdb等存储引擎中",{"2":{"271":1}}],["buffersize",{"2":{"276":1}}],["buffer之后",{"2":{"276":1}}],["buffer的意义是什么",{"2":{"276":1}}],["buffer中",{"2":{"276":1}}],["buffer中完成排序操作",{"2":{"262":1}}],["buffer",{"2":{"262":1,"275":1,"276":2,"277":2,"278":1,"279":1}}],["b+树",{"2":{"256":1}}],["b+tree",{"2":{"256":1}}],["b+tree索引",{"2":{"256":1}}],["b树",{"2":{"256":1}}],["by优化",{"2":{"262":2}}],["by",{"2":{"220":4,"221":2,"261":2,"262":9,"264":1}}],["byte",{"2":{"153":3,"165":3}}],["blacksmithgu",{"2":{"210":1}}],["block",{"2":{"207":1}}],["blockingqueue",{"2":{"138":2}}],["blocked进入runnable",{"0":{"83":1},"1":{"84":1}}],["b线程执行过程中发生异常会释放锁",{"2":{"204":1}}],["binlog",{"2":{"270":1}}],["bigint",{"2":{"265":1}}],["bit+锁标志位",{"2":{"190":1}}],["bits",{"2":{"141":8}}],["biased",{"2":{"190":1,"191":1}}],["btos",{"2":{"165":2}}],["backup",{"2":{"212":1}}],["base",{"2":{"165":2,"196":3}}],["barrier写屏障",{"2":{"161":1}}],["barrier读屏障",{"2":{"161":1}}],["bailithreadlocalmemoryleakdemo",{"2":{"153":1}}],["b操作no+1结果是2",{"2":{"144":1}}],["b一起来操作no",{"2":{"144":1}}],["begin",{"2":{"265":3,"266":1,"267":1}}],["between",{"2":{"220":1,"256":1}}],["before",{"2":{"267":1}}],["before原则",{"2":{"143":1,"161":1}}],["beforeexecute",{"2":{"140":1}}],["been",{"2":{"139":1}}],["be",{"2":{"139":4}}],["b",{"0":{"123":1},"2":{"146":2,"165":1,"180":2,"256":1,"283":1}}],["垃圾回收线程属于守护线程",{"0":{"79":1}}],["可用作存储过程内的局部变量和输入参数",{"2":{"265":1}}],["可能并不总是准确的",{"2":{"259":1}}],["可能会给cpu带来很大的开销",{"2":{"181":1}}],["可能会造成数据不一致",{"2":{"143":1}}],["可省略",{"2":{"225":1,"226":2}}],["可选",{"0":{"211":1},"1":{"212":1,"213":1,"214":1,"215":1,"216":1},"2":{"265":2}}],["可公平",{"2":{"204":1}}],["可中断",{"2":{"204":1}}],["可中断锁时子线程在获取锁的过程中",{"2":{"193":1}}],["可中断锁",{"2":{"193":1}}],["可重入锁是指同一个线程可以多次获得同一把锁",{"2":{"193":1}}],["可重入锁的一个优点是可一定程度避免死锁",{"2":{"192":1}}],["可重入锁",{"0":{"192":1},"2":{"193":1}}],["可是我的运行最终结果只有996",{"2":{"144":1}}],["可见性主要是变量修改",{"2":{"146":1}}],["可见性",{"0":{"145":1},"2":{"143":2,"146":1,"161":1}}],["可盈通过thread",{"0":{"76":1}}],["可以使用mysql中的source指令",{"2":{"283":1}}],["可以使线程休眠指定的毫秒数",{"2":{"61":1}}],["可以访问该版本",{"2":{"280":2}}],["可以认为当de",{"2":{"279":1}}],["可以认为这里返回v就是线程返回的结果",{"0":{"97":1}}],["可以指定该表空间",{"2":{"277":1}}],["可以用它来检查服务器的配置和当前状态",{"2":{"283":1}}],["可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤",{"2":{"265":1}}],["可以用其来实现简单的死循环",{"2":{"265":1}}],["可以用户空间内实现协作式多任务处理",{"0":{"16":1}}],["可以在",{"2":{"265":1}}],["可以接受参数",{"2":{"265":1}}],["可以适当增大排序缓冲区大小sort",{"2":{"262":1}}],["可以自己设置",{"2":{"262":1}}],["可以针对于字段的特点",{"2":{"261":1}}],["可以根据索引的选择性来决定",{"2":{"260":1}}],["可以查看当前数据库的insert",{"2":{"259":1}}],["可以存在多个",{"2":{"257":1}}],["可以有多个",{"2":{"257":3}}],["可以是内连接查询",{"2":{"227":1}}],["可以停止工作了",{"2":{"196":1}}],["可以选择传入时间参数",{"2":{"194":1}}],["可以通过它来找到该记录修改前的信息",{"2":{"274":1}}],["可以通过以下slq",{"2":{"272":1}}],["可以通过以下sql",{"2":{"271":1}}],["可以通过like模糊匹配方式查找变量",{"2":{"265":1}}],["可以通过覆盖索引加子查询形式进行优化",{"2":{"262":1}}],["可以通过索引来提高效率",{"2":{"262":1}}],["可以通过set语句在session",{"2":{"259":1}}],["可以通过链表来解决",{"2":{"256":1}}],["可以通过jvm参数取消这个延迟时间",{"2":{"191":1}}],["可以通过一个小工具来查看下这个t类在内存中的对象布局",{"2":{"189":1}}],["可以通过重载terminated",{"2":{"141":1}}],["可以避免inheritablethreadlocal在多线程中出现不一致的情况",{"2":{"154":1}}],["可以利用该机制将数据缓存在某个线程内部",{"2":{"152":1}}],["可以简单的认为每个线程都有自己的本地工作内存",{"2":{"145":1}}],["可以分为三步",{"2":{"144":1}}],["可以获取到线程执行的返回值",{"0":{"105":1}}],["可以创建匿名对象",{"2":{"97":1}}],["可以加入sleep让线程阻塞时间",{"2":{"62":1}}],["可以让我们获取当前的cpu核心数",{"0":{"39":1}}],["可以更高效地利用系统资源",{"0":{"16":1}}],["守护线程会立马结束",{"0":{"77":1}}],["守护线程",{"0":{"73":1,"75":1},"1":{"74":1,"75":1,"76":1,"77":1,"78":1,"79":1,"80":1}}],["也更加复杂",{"2":{"269":1}}],["也遵循最左前缀法则",{"2":{"262":1}}],["也称hash碰撞",{"2":{"256":1}}],["也没有机会获取到锁",{"2":{"199":1}}],["也顾及不上谁先谁后",{"2":{"197":1}}],["也被称为管程或监视器锁",{"2":{"191":1}}],["也将2赋值给no",{"2":{"144":1}}],["也是丢弃任务",{"2":{"135":1}}],["也是一样的道理",{"0":{"88":1}}],["也可以作为输出参数",{"2":{"265":1}}],["也可以返回数据",{"2":{"265":1}}],["也可以简化他们的操作",{"2":{"264":1}}],["也可以填充100",{"2":{"262":1}}],["也可以填充一半",{"2":{"262":1}}],["也可以是外连接查询",{"2":{"227":1}}],["也可以查看但不能修改和删除数据",{"2":{"203":1}}],["也可以直接用lambda省略1",{"2":{"97":1}}],["也可以通过返回的future对象查询执行状态",{"0":{"96":1}}],["也即是说这个方法做了两件事",{"0":{"68":1}}],["也就是该参数可以作为返回值",{"2":{"265":1}}],["也就是需要调用时传入值",{"2":{"265":1}}],["也就是entry对象进行回收",{"2":{"153":1}}],["也就是这两个状态不会参与相互转化",{"0":{"94":1}}],["也就是说在等待锁的过程中",{"2":{"196":1}}],["也就是说在jvm启动后4秒后创建的对象才会开启偏向锁",{"2":{"191":1}}],["也就是说偏向锁不会主动释放",{"2":{"191":1}}],["也就是说只能进行锁升级",{"2":{"188":1}}],["也就是说",{"2":{"182":1,"197":1}}],["也就是说cas的原子性实际上是cpu实现的",{"2":{"178":1}}],["也就是说这玩意效率更高且通过硬件保证",{"2":{"178":1}}],["也就是说如果超时时间到了那么就会系统自动直接拿到锁",{"0":{"89":1}}],["也就是说8核cpu同时可以执行8个线程的代码",{"0":{"12":1,"38":1}}],["也就是不会主动进入",{"0":{"84":1}}],["也就是cpu内核和同时运行的线程数是1",{"0":{"12":1,"38":1}}],["判断线程池是否真正的",{"2":{"126":1}}],["判断线程是否被中断",{"0":{"67":1}}],["判断当前线程是否被中断",{"0":{"66":1}}],["静态方法",{"0":{"67":1}}],["ib",{"2":{"277":2}}],["ibd文件",{"2":{"274":1}}],["ibd",{"2":{"246":1}}],["ix",{"2":{"271":2}}],["iterate",{"2":{"265":2}}],["itos",{"2":{"165":2}}],["io",{"2":{"278":1}}],["iot",{"2":{"262":1}}],["iock",{"2":{"191":1}}],["ignore",{"2":{"260":2}}],["ignores",{"2":{"139":1}}],["id不在m",{"2":{"280":1}}],["id不同",{"2":{"259":1}}],["ids中是可以访问该版本的",{"2":{"280":1}}],["ids",{"2":{"280":1}}],["id隐藏列",{"2":{"274":1}}],["id>=10",{"2":{"264":1}}],["idx",{"2":{"260":2,"262":4}}],["id相同",{"2":{"259":1}}],["id的sql语句cpu的使用情况",{"2":{"259":1}}],["id的sql语句各个阶段的耗时情况",{"2":{"259":1}}],["identified",{"2":{"221":2}}],["id",{"2":{"218":1,"221":2,"259":3,"262":7,"264":11,"274":1,"280":16}}],["ip",{"2":{"217":1}}],["ia",{"2":{"159":1,"160":1,"172":1}}],["i=0",{"2":{"144":1}}],["i=1",{"2":{"126":1}}],["inout",{"2":{"265":2}}],["info\\t\\t\\t不包含数据库的创建语句",{"2":{"283":1}}],["information",{"2":{"282":1}}],["infomation",{"2":{"265":1}}],["infile=1",{"2":{"262":1}}],["infile为1",{"2":{"262":1}}],["infile",{"2":{"262":3}}],["innodb使用会话临时表空间和全局临时表空间",{"2":{"277":1}}],["innodb使用next",{"2":{"272":1}}],["innodb存储引擎会监控对表上各索引页的查询",{"2":{"276":1}}],["innodb存储引擎数据是按行进行存放的",{"2":{"274":1}}],["innodb存储引擎每次从磁盘申请4",{"2":{"274":1}}],["innodb存储引擎页大小为16k",{"2":{"274":1}}],["innodb在repeatable",{"2":{"272":1}}],["innodb实现了以下两种类型的行锁",{"2":{"272":1}}],["innodb的行锁是针对于索引加的锁",{"2":{"272":1}}],["innodb的行锁是针对索引加的锁",{"2":{"262":1}}],["innodb的数据是基于索引组织的",{"2":{"272":1}}],["innodb引擎将数据页从buffer",{"2":{"277":1}}],["innodb引擎",{"0":{"273":1},"1":{"274":1,"275":1,"276":1,"277":1,"278":1,"279":1,"280":1}}],["innodb引擎并不会把全部字段取出来",{"2":{"262":1}}],["innodb引擎便利整张表",{"2":{"262":1}}],["innodb引擎会遍历整张表把每一行的字段值都取出来",{"2":{"262":2}}],["innodb引擎会遍历整张表",{"2":{"262":1}}],["innodb引擎就麻烦了",{"2":{"262":1}}],["innodb引擎的每一张表都会对应这样一个空间文件",{"2":{"246":1}}],["innodb会开始寻找最靠近的页",{"2":{"262":1}}],["innodb是索引组织表",{"2":{"274":1}}],["innodb是默认的mysql存储引擎",{"2":{"246":1}}],["innodb是一种兼顾高可靠性和高性能的通用存储引擎",{"2":{"246":1}}],["innodb",{"0":{"246":1},"2":{"243":1,"246":2,"250":1,"276":1,"277":2}}],["inner",{"2":{"225":2}}],["insert型触发器",{"2":{"267":1}}],["insert优化",{"2":{"262":1}}],["insert",{"2":{"219":4,"262":3,"267":1,"271":1,"272":1,"278":1,"280":1}}],["instead",{"2":{"139":1}}],["index",{"2":{"210":1,"253":1,"257":2,"258":6,"259":1,"260":13,"262":6,"271":1,"272":1,"276":2}}],["increment自增主键",{"2":{"262":1}}],["increment",{"2":{"172":2}}],["incrementandget",{"2":{"168":3,"176":1}}],["initflag",{"2":{"157":4}}],["inherruptedexception",{"2":{"155":1}}],["inheritablethreadlocal",{"2":{"154":2}}],["inheritablethreadlocal是threadlocal子类",{"2":{"154":1}}],["inheritablethreadlocal是什么",{"0":{"154":1}}],["in",{"2":{"139":3,"141":1,"209":1,"216":1,"220":1,"232":2,"233":2,"234":1,"256":1,"265":2,"271":2,"272":2,"280":1}}],["into",{"2":{"208":1,"219":4,"262":5,"265":3}}],["intgetatomicinteger",{"2":{"177":1}}],["int",{"0":{"179":2},"2":{"126":1,"136":3,"137":1,"140":4,"141":7,"144":2,"146":6,"152":2,"153":1,"165":9,"169":2,"177":2,"179":2,"196":2,"218":1,"265":1}}],["intel",{"2":{"161":1}}],["integer",{"2":{"97":2,"127":6,"141":1}}],["integer>",{"2":{"97":3,"127":2}}],["interval",{"2":{"221":1}}],["interger>",{"2":{"127":1}}],["interface",{"2":{"96":1}}],["interruptedexception",{"2":{"97":1,"126":1,"140":1,"153":1,"154":2,"157":1,"178":1,"191":4,"195":1,"196":3}}],["interrupted",{"2":{"66":1,"140":1}}],["interrupt",{"2":{"64":1,"140":1,"196":1}}],["improved",{"2":{"216":1}}],["import",{"2":{"196":1}}],["implements",{"2":{"97":1,"136":1,"139":4,"144":1}}],["immediately",{"2":{"139":1}}],["ifnull",{"2":{"221":1}}],["ifence",{"2":{"161":1}}],["if",{"2":{"139":3,"140":12,"146":2,"152":1,"161":1,"165":14,"195":2,"196":3,"218":3,"221":1,"264":1,"265":3}}],["i++",{"2":{"126":1,"136":1,"144":1,"152":2,"153":1}}],["i",{"2":{"126":1,"136":8,"144":1,"145":1,"152":4,"153":2,"269":1,"283":1}}],["isolaction",{"2":{"240":1}}],["isolation",{"2":{"240":1,"279":1}}],["isheldbycurrentthread",{"2":{"195":1,"196":2}}],["isempty",{"2":{"140":3}}],["isshutdown",{"2":{"139":2}}],["is",{"2":{"139":4,"141":1,"208":1,"220":1,"271":2}}],["isterminated",{"2":{"126":1}}],["isdeamon",{"0":{"76":1}}],["isalive",{"0":{"72":1}}],["isinterrupted",{"2":{"65":1,"140":1,"196":1}}],["告诉调度器当前线程愿意让出cpu资源",{"2":{"63":1}}],["它记录一条对应相反的update记录",{"2":{"279":1}}],["它可以减轻master",{"2":{"278":1}}],["它可以更好地确定哪个索引最有效地用于查询",{"2":{"261":1}}],["它也可能包含表和索引数据",{"2":{"277":1}}],["它擅长事务处理",{"2":{"275":1}}],["它还会检查依赖视图中的规则以保持一致性",{"2":{"264":1}}],["它执行count",{"2":{"262":1}}],["它对数据库中的数据的改变就是永久的",{"2":{"238":1,"279":1}}],["它支持将",{"2":{"208":1}}],["它不会产生饥饿现象",{"2":{"197":1}}],["它们都是为了解决对某项资源的互斥使用",{"2":{"182":1}}],["它们会先进入blocked状态",{"0":{"88":1}}],["它通过硬件保证了比较",{"2":{"178":1}}],["它包含三个操作数",{"2":{"178":1}}],["它在那些场景中可以用",{"2":{"154":1}}],["它将减少正在运行的工作者的数量并返回null",{"2":{"140":1}}],["它用于执行",{"2":{"140":1}}],["它会按照到达的先后顺序获得资源",{"2":{"197":1}}],["它会锁定这块内存区域的缓存",{"2":{"160":1}}],["它会在调用方的线程中执行该任务",{"2":{"139":1}}],["它会移除队列中最老的任务",{"2":{"139":1}}],["它会默默地丢弃这个任务",{"2":{"139":1}}],["它会立即抛出一个异常",{"2":{"139":1}}],["它的主要特点为",{"0":{"115":1}}],["它只有一个call方法",{"0":{"97":1}}],["它只是一个提示",{"2":{"63":1}}],["它是逻辑日志",{"2":{"279":1}}],["它是一个不可分割的工作单位",{"0":{"236":1},"1":{"255":1},"2":{"279":1}}],["它是非阻塞的且自身原子性",{"2":{"178":1}}],["它是用来取得异步任务的结果看看其源码",{"0":{"96":1}}],["它是进程中的一个实体",{"0":{"11":1}}],["它存在超时机制",{"0":{"89":1}}],["因为事务id是自增的",{"2":{"280":1}}],["因为执行count",{"2":{"262":1}}],["因为多个读操作同时进行并没有线程安全问题",{"2":{"203":1}}],["因为节省很多线程切换时间",{"2":{"200":1}}],["因为不需要考虑是否还有前驱节点",{"2":{"198":1}}],["因为当threadlocal对象使用完成之后",{"2":{"153":1}}],["因为频繁创建线程和销毁线程需要时间",{"0":{"108":1}}],["因为它是没有超时机制的",{"0":{"84":1}}],["因为让步的线程还有可能被线程调度程序再次选中",{"2":{"63":1}}],["因此不能保证其公平性",{"2":{"197":1}}],["因此不存在共享",{"2":{"150":1}}],["因此在实际开发中应该尽量避免直接使用",{"2":{"180":1}}],["因此在获取数据的时候会先加锁",{"2":{"175":1}}],["因此再java",{"0":{"120":1}}],["因此",{"0":{"104":1},"2":{"63":1}}],["因此纤程的创建和销毁开销很小",{"0":{"16":1}}],["达到让步目的",{"2":{"63":1}}],["达到雨露均沾",{"0":{"25":1}}],["实例对象中的成员属性大小",{"2":{"189":1}}],["实例方法interrupt",{"0":{"65":1}}],["实际上记录并没有被物理删除",{"2":{"262":1}}],["实际使用的索引",{"2":{"259":1}}],["实际是操作自己本地内存里面的变量",{"2":{"152":1}}],["实际中无法保证yield",{"2":{"63":1}}],["实现并发算法时常用到的一种技术",{"2":{"178":1}}],["实现延迟初始化需要将目标属性声明为volatile型",{"2":{"162":1}}],["实现storestore屏障",{"2":{"161":1}}],["实现loadload屏障",{"2":{"161":1}}],["实现方式观察threadlocal的set方法",{"2":{"152":1}}],["实现callable接口的方式",{"0":{"102":1}}],["实现runnable接口的run方法",{"0":{"100":1}}],["实现多任务并行执行",{"0":{"29":1}}],["的争用以外",{"2":{"269":1}}],["的时候",{"2":{"262":1}}],["的时候会直接返回这个数",{"2":{"262":1}}],["的时间",{"0":{"45":1}}],["的所有sql语句的日志",{"2":{"259":1}}],["的b+tree为例",{"2":{"256":1}}],["的b",{"2":{"256":1}}],["的语法查询数据然后可视化结果",{"2":{"210":1}}],["的起始地址",{"2":{"191":1}}],["的值修改为",{"2":{"180":1}}],["的值等于",{"2":{"180":1}}],["的核心方法之一",{"2":{"140":1}}],["的线程池拒绝执行任务时",{"2":{"139":4}}],["的目的是让相同优先级的线程之间能适当的轮转执行",{"2":{"63":1}}],["做的是让当前运行的线程回到可运行状态",{"2":{"63":1}}],["暂停当前正在执行的线程对象",{"2":{"63":1}}],["after",{"2":{"267":1}}],["afterexecute",{"2":{"140":2}}],["aa",{"2":{"262":1}}],["avg",{"2":{"220":2}}],["available",{"2":{"139":1}}],["avaiiableprocessors",{"0":{"39":1}}],["autocommit",{"2":{"237":2}}],["auto",{"0":{"213":1},"2":{"213":1}}],["akaalias",{"2":{"209":1}}],["as",{"2":{"220":1,"264":9}}],["asc",{"2":{"220":1,"262":1}}],["asciicast",{"2":{"208":2}}],["asciinema",{"0":{"208":1},"2":{"208":1}}],["assign",{"2":{"158":1}}],["adll",{"2":{"283":1}}],["adaptive",{"2":{"276":2}}],["advanced",{"0":{"216":1},"2":{"216":1}}],["admonition",{"0":{"207":1},"2":{"207":2}}],["add",{"2":{"218":1,"221":1,"277":1,"283":3}}],["adds",{"2":{"207":1}}],["addandget",{"2":{"168":3,"172":1}}],["adder累加器",{"0":{"172":1},"2":{"167":1}}],["addworker",{"2":{"137":1,"140":1}}],["a线程执行完同步代码会释放锁",{"2":{"204":1}}],["action",{"2":{"265":2}}],["acquireinterruptibly",{"2":{"196":1}}],["accumulate",{"2":{"172":3}}],["accumulate积累器",{"0":{"172":1}}],["accumulator积累器",{"2":{"167":1}}],["abstractqueuedsynchronizer",{"2":{"196":4}}],["aba问题",{"0":{"183":1}}],["abortpolicy",{"2":{"136":1,"139":4}}],["abortpolicy丢弃任务并抛出rejectedexception异常",{"2":{"135":1}}],["age",{"2":{"171":1,"189":1,"262":11}}],["age=22",{"2":{"170":1}}],["age=20",{"2":{"170":1}}],["age++",{"2":{"152":2}}],["aia",{"2":{"169":9}}],["ai",{"2":{"168":32,"169":2}}],["a为volatile变量",{"2":{"165":1}}],["a=1",{"2":{"165":1}}],["a=2",{"2":{"146":2}}],["a+b",{"2":{"146":2}}],["ater",{"2":{"264":1}}],["atable",{"2":{"240":1}}],["at",{"2":{"196":4,"276":1}}],["atos",{"2":{"165":2}}],["atomicity",{"2":{"279":1}}],["atomicintegerfieldupdater",{"2":{"167":1,"171":2}}],["atomicintegerarray",{"2":{"167":1,"169":2}}],["atomicinteger等",{"2":{"144":1}}],["atomicinteger",{"0":{"168":1},"2":{"141":4,"167":1,"168":2,"172":2,"176":4,"177":3,"178":6}}],["atomicuserref",{"2":{"170":7}}],["atomicref",{"2":{"170":2}}],["atomicreferencefieldupdater",{"2":{"167":1}}],["atomicreference",{"2":{"167":1,"170":2}}],["atomicreferencearray",{"2":{"167":1}}],["atomicarray",{"0":{"169":1}}],["atomicmarkablereference",{"2":{"167":1}}],["atomicstampedreference",{"2":{"167":1}}],["atomicboolean",{"2":{"167":1}}],["atomiclongfieldupdater",{"2":{"167":1}}],["atomiclongarray",{"2":{"167":1}}],["atomiclong",{"2":{"167":1}}],["atomic",{"2":{"143":1,"166":1,"167":4}}],["attempting",{"2":{"139":4}}],["all直接合并",{"2":{"228":1}}],["all",{"2":{"228":1,"232":1,"259":1,"264":1}}],["allowcorethreadtimeout",{"2":{"140":2}}],["alter",{"2":{"218":5,"221":1,"271":1}}],["always",{"2":{"139":2,"155":4}}],["any",{"2":{"232":1}}],["and",{"2":{"139":2,"162":1,"176":1,"178":1,"180":1,"210":1,"216":1,"220":2}}],["an",{"2":{"139":1}}],["artifactid>",{"2":{"189":1}}],["artifactid>jol",{"2":{"189":1}}],["array数组类型原子类",{"2":{"167":1}}],["arrayblockingqueue",{"2":{"136":1,"138":1}}],["are",{"2":{"140":1}}],["args",{"2":{"62":1,"97":1,"136":1,"144":1,"146":1,"152":1,"153":1,"154":2,"155":1,"157":1,"168":1,"169":1,"170":1,"171":1,"178":1,"191":2,"195":1,"196":1}}],["amp",{"0":{"128":1},"1":{"129":1,"130":1,"131":1,"132":1,"133":1,"134":1,"135":1},"2":{"220":2}}],["awaittermination",{"2":{"126":1,"153":1}}],["a",{"0":{"122":1},"2":{"139":3,"146":2,"165":1,"171":3,"180":2,"208":1,"210":1,"262":2,"283":1}}],["msyqladmin是一个执行管理操作的客户端程序",{"2":{"283":1}}],["m",{"2":{"280":1}}],["mvcc的具体实现",{"2":{"280":1}}],["mvcc",{"0":{"280":1},"2":{"279":1,"280":1}}],["my",{"2":{"259":1,"265":1}}],["myi",{"2":{"247":1}}],["myisam引擎把一个表的总行数存在了磁盘上",{"2":{"262":1}}],["myisam是mysql早期的默认存储引擎",{"2":{"247":1}}],["myisam",{"0":{"247":1},"2":{"250":1}}],["myd",{"2":{"247":1}}],["mysqlbinlog",{"2":{"283":1}}],["mysqlmysqladmin",{"2":{"283":2}}],["mysqladmin",{"2":{"283":2}}],["mysql示例",{"2":{"283":1}}],["mysql语法",{"2":{"283":6}}],["mysql数据库安装之后",{"2":{"282":1}}],["mysql管理",{"0":{"281":1},"1":{"282":1,"283":1}}],["mysql实例在初始化时会自动创建两个默认的undo表空间",{"2":{"277":1}}],["mysql5",{"2":{"275":1}}],["mysql中的锁",{"2":{"269":1}}],["mysqlfetch",{"2":{"265":1}}],["mysqlopen",{"2":{"265":1}}],["mysqlleave",{"2":{"265":1}}],["mysqlimport是客户端数据导入工具",{"2":{"283":1}}],["mysqlimport",{"2":{"283":1}}],["mysqlif",{"2":{"265":1}}],["mysqlinsert",{"2":{"262":1}}],["mysqldump客户端工具来备份数据库或者在不同数据库之间进行数据迁移",{"2":{"283":1}}],["mysqldump",{"2":{"283":1}}],["mysqldeclare",{"2":{"265":3}}],["mysqldrop",{"2":{"258":1,"264":1,"265":1,"267":1}}],["mysql服务器重新启动之后",{"2":{"265":1}}],["mysqlclose",{"2":{"265":1}}],["mysqlcase",{"2":{"265":2}}],["mysqlcall",{"2":{"265":1}}],["mysqlctreate",{"2":{"265":1}}],["mysqlcreate",{"2":{"258":1,"260":1,"264":8,"265":1,"267":1}}],["mysql提供了两个选项",{"2":{"264":1}}],["mysql允许基于另一个视图创建视图",{"2":{"264":1}}],["mysql会通过视图检查正在更改的每个行",{"2":{"264":1}}],["mysqlupdate",{"2":{"262":1}}],["mysql优化器会评估哪个字段的索引效率更高",{"2":{"260":1}}],["mysqlexplain",{"2":{"260":3,"262":2}}],["mysql认为必须要执行查询的行数",{"2":{"259":1}}],["mysqlstart",{"2":{"262":1}}],["mysqlset",{"2":{"259":1,"265":3}}],["mysqlselect",{"2":{"259":1,"260":3,"265":3,"271":2,"272":1}}],["mysqlshow客户端对象查找工具",{"2":{"283":1}}],["mysqlshow",{"2":{"258":1,"259":1,"265":1,"267":1,"283":1}}],["mysql的慢查询日志默认没有开启",{"2":{"259":1}}],["mysql的索引是在存储引擎层实现的",{"2":{"256":1}}],["mysql客户端连接成功后",{"2":{"259":1}}],["mysql索引数据结构对经典的b+tree进行优化",{"2":{"256":1}}],["mysql安装",{"0":{"251":1}}],["mysql",{"2":{"217":1,"221":2,"259":3,"260":1,"262":4,"264":1,"265":3,"277":1,"282":1,"283":1}}],["mytask",{"2":{"136":4}}],["month",{"2":{"221":1}}],["monitor中只能有一个owner",{"2":{"187":1}}],["monitor中有owner",{"2":{"187":1}}],["monitor有两大作用",{"2":{"187":1}}],["monitor",{"0":{"187":1},"2":{"187":1}}],["mode添加",{"2":{"271":1}}],["mode",{"2":{"271":2,"272":3,"280":1}}],["mod",{"2":{"221":1}}],["modify",{"2":{"218":1}}],["more",{"2":{"209":1}}],["mdl锁主要作用是维护表元数据的数据一致性",{"2":{"271":1}}],["mdl加锁过程是系统自动控制",{"2":{"271":1}}],["mdl",{"2":{"271":2}}],["md",{"2":{"207":1,"210":1,"212":1,"216":1}}],["mkdocs",{"2":{"207":1}}],["m2",{"2":{"175":1}}],["m1",{"2":{"175":1}}],["metadata",{"2":{"271":1}}],["meta",{"2":{"271":2}}],["methods",{"2":{"162":1}}],["mergre",{"2":{"262":1}}],["memory的缺陷就是对表的大小有限制",{"2":{"250":1}}],["memory引擎的表数据时存储再内存中的",{"2":{"248":1}}],["memory",{"0":{"248":1},"2":{"250":1}}],["mesi协议",{"2":{"160":1}}],["mesi",{"2":{"159":1}}],["mfence",{"2":{"161":1}}],["minutes",{"2":{"153":1}}],["min",{"2":{"140":4,"220":2,"264":1,"280":3}}],["master",{"2":{"278":1}}],["mask",{"2":{"141":1}}],["manipulation",{"2":{"216":1}}],["makes",{"2":{"209":1}}],["material",{"2":{"207":1}}],["markdown",{"2":{"206":1,"207":1,"208":3,"209":1,"210":3,"213":1,"216":1}}],["markword里面包含了其它的东西",{"2":{"189":1}}],["markword",{"0":{"189":1}}],["map",{"2":{"152":3,"165":2}}],["map的value为需要缓存的值",{"2":{"152":1}}],["map的key为threadlocal对象",{"2":{"152":1}}],["maximumpoolsize",{"0":{"130":1},"2":{"140":1}}],["max",{"2":{"126":1,"220":2,"256":2,"264":1,"280":3}}],["main函数中启动了1000个线程",{"2":{"144":1}}],["mainlock",{"2":{"140":4}}],["main",{"2":{"62":1,"97":2,"136":1,"144":1,"146":1,"152":1,"153":1,"154":2,"155":1,"157":1,"168":1,"169":1,"170":1,"171":1,"178":1,"191":4,"195":1,"196":1}}],["m946i",{"0":{"0":1,"3":1}}],["测试",{"0":{"62":1}}],["使编辑和引用外部来源可以更简单",{"2":{"209":1}}],["使得读写操作没有冲突",{"2":{"280":1}}],["使得表锁不用检查每行数据是否加锁",{"2":{"271":1}}],["使得该值又恢复为旧值",{"2":{"183":1}}],["使得开发者可以直接操作内存",{"2":{"180":1}}],["使lock前后指令不能重排序",{"2":{"160":1}}],["使用意向锁来减少表锁的检查",{"2":{"271":1}}],["使用别名old和new来引用触发器中发生变化的记录内容",{"2":{"267":1}}],["使用就可以",{"2":{"265":1}}],["使用户根据需要自己定义的变量",{"2":{"265":1}}],["使用insert语句性能较低",{"2":{"262":1}}],["使用索引的效率越高",{"2":{"261":2}}],["使用some的地方可以使用any",{"2":{"232":1}}],["使用mysql数据库",{"2":{"221":1}}],["使用数据库",{"2":{"218":1}}],["使用公平锁会有什么问题",{"0":{"199":1}}],["使用多线程很重要的考量点是线程切换的开销",{"2":{"198":1}}],["使用如下类实现",{"2":{"172":1}}],["使用原子类的效率会比使用锁的效率更高",{"2":{"166":1}}],["使用volatile修饰变量",{"2":{"146":1}}],["使用volatile修饰共享变量",{"2":{"145":1}}],["使用cas操作",{"2":{"144":1}}],["使用一个循环来执行任务",{"2":{"140":1}}],["使用",{"2":{"139":4,"158":1,"209":1,"265":1}}],["使用线程池时",{"2":{"154":1}}],["使用线程池可以进行统一的分配",{"0":{"118":1}}],["使用线程的sleep",{"2":{"61":1}}],["使用实现callable接口的方式创建的线程",{"0":{"105":1}}],["使用futuretask方式",{"0":{"102":1}}],["使用futuretask类来包装callable对象",{"2":{"97":1}}],["使用future",{"2":{"97":1}}],["使用runnable接囗",{"0":{"96":1}}],["使用yield",{"2":{"63":1}}],["使核心数与线程数形成1",{"0":{"38":1}}],["作用是跳过当前循环剩下的语句",{"2":{"265":1}}],["作用",{"0":{"58":1},"2":{"264":1}}],["作业数往往大于机器的cpu数",{"0":{"44":1}}],["而io",{"2":{"278":1}}],["而innodb中具有自适应hash功能",{"2":{"256":1}}],["而会将数据变更存在更改缓冲区change",{"2":{"276":1}}],["而非单例索引",{"2":{"260":1}}],["而选择性是指不重复的索引值",{"2":{"260":1}}],["而后面的列中没有索引",{"2":{"260":1}}],["而lock锁可重入",{"2":{"204":1}}],["而lock锁就不一定会等待下去",{"2":{"204":1}}],["而公平锁",{"2":{"197":1}}],["而reentrantlock运行开发者自己设置锁的公平性",{"2":{"197":1}}],["而reentrantlock提供了另外一种可能",{"2":{"196":1}}],["而reentrantlock是两种都可以实现",{"2":{"193":1}}],["而不是连接到mysql数据库再执行",{"2":{"283":1}}],["而不是对记录加的锁",{"2":{"272":1}}],["而不是比较索引中的值",{"2":{"257":1}}],["而不是随机插队的方式获取",{"2":{"193":1}}],["而不是偏向锁",{"2":{"191":1}}],["而不会经历blocked状态",{"0":{"90":1}}],["而操作系统领域系统一般翻译为",{"2":{"187":1}}],["而调用无参的wait方法",{"2":{"184":1}}],["而atomiclong还具有cas方法",{"2":{"172":1}}],["而且只有一个",{"2":{"257":1}}],["而且无法保证数据的安全性",{"2":{"250":1}}],["而且是不可逆的过程",{"2":{"188":1}}],["而且会加入到等待队列中",{"2":{"184":1}}],["而且longadder基本只是提供add方法",{"2":{"172":1}}],["而且以延续或者定时的方式来执行任务",{"0":{"125":1}}],["而线程对象是通过强引用指向threadlocalmap",{"2":{"153":1}}],["而其他线程能感知到变量的修改",{"2":{"146":1}}],["而是指mysql的客户端",{"2":{"283":1}}],["而是专门做优化",{"2":{"262":1}}],["而是选择更高级别的并发工具类来进行编程",{"2":{"180":1}}],["而是会将异常暂存起来",{"2":{"127":1}}],["而是可以继续执行其他的任务",{"0":{"109":1}}],["而只是一个执行的工具",{"0":{"120":1}}],["而执行start方法会产生新线程",{"2":{"59":1}}],["而start方法只能被执行一次",{"2":{"60":1}}],["而start方法是异步方法",{"2":{"57":1}}],["而start的方法呢是启动线程",{"2":{"58":1}}],["而这涉及到的知识非常的庞大",{"0":{"6":1}}],["skip",{"2":{"283":1}}],["sku",{"2":{"260":3,"262":2}}],["single",{"2":{"270":1}}],["size",{"2":{"140":1,"141":1,"262":1}}],["schema性能数据库进行性能调优和诊断的视图",{"2":{"282":1}}],["schema=",{"2":{"265":1}}],["schema",{"2":{"265":1,"267":1,"271":4,"272":2,"282":2}}],["scope>",{"2":{"189":1}}],["scope>compile",{"2":{"189":1}}],["source",{"2":{"283":1}}],["solr",{"2":{"256":1}}],["some",{"2":{"232":1}}],["sdi",{"2":{"246":1,"247":1,"248":1}}],["sn=",{"2":{"260":2}}],["sn拼接成一个字符",{"2":{"221":1}}],["sn",{"2":{"221":1,"260":2}}],["s2",{"2":{"221":2}}],["s1",{"2":{"221":1}}],["sql文件",{"2":{"283":1}}],["sqlstate",{"2":{"265":1}}],["sql语句",{"2":{"265":2,"266":1}}],["sql语句执行时间超过2秒",{"2":{"259":1}}],["sql1",{"2":{"262":1}}],["sql优化",{"0":{"262":1}}],["sql提示",{"2":{"260":2}}],["sql执行频率",{"2":{"259":1}}],["sql性能分析",{"0":{"259":1}}],["sql",{"2":{"210":1,"266":2,"272":1,"283":1}}],["spinlock",{"2":{"182":1}}],["swap的缩写",{"2":{"178":1}}],["swap",{"2":{"176":1,"180":1}}],["switch",{"0":{"41":1},"1":{"42":1,"43":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1,"50":1,"51":1}}],["share",{"2":{"271":3,"272":2,"280":1}}],["shared",{"2":{"271":5}}],["show",{"2":{"218":3,"221":1,"244":1,"246":1,"259":6,"264":1,"265":2}}],["short",{"2":{"165":1,"283":1}}],["sh",{"2":{"215":1}}],["shift",{"2":{"165":2}}],["shut",{"2":{"139":2}}],["shutdownnow",{"2":{"126":1}}],["shutdown",{"2":{"126":1,"136":1,"140":1,"141":5,"153":1}}],["sfence",{"2":{"161":1}}],["sum",{"2":{"220":2,"264":1}}],["supports",{"2":{"208":1}}],["super",{"2":{"152":1,"195":1,"196":1}}],["subquery",{"2":{"259":1}}],["substring",{"2":{"221":1,"260":1}}],["subject",{"2":{"140":1}}],["submit",{"2":{"127":4}}],["sys",{"2":{"282":1}}],["system",{"2":{"127":3,"136":1,"144":1,"146":1,"154":2,"155":1,"157":4,"168":13,"169":5,"170":3,"171":2,"178":1,"190":1,"191":4,"195":6,"196":1,"259":1,"277":1}}],["symbol",{"0":{"213":1},"2":{"213":1}}],["sync是隐式锁",{"2":{"193":1}}],["synchronized锁适合代码少量的同步问题",{"2":{"204":1}}],["synchronized锁升级",{"0":{"186":1},"1":{"187":1,"188":1,"189":1,"190":1,"191":1}}],["synchronized的锁可重入",{"2":{"204":1}}],["synchronized会自动释放锁",{"2":{"204":1}}],["synchronized无法判断是否获取锁的状态",{"2":{"204":1}}],["synchronized与lock的区别",{"0":{"204":1}}],["synchronized是不可中断的",{"2":{"193":1}}],["synchronized是非公平锁",{"2":{"187":1,"193":1}}],["synchronized关键字默认是有jvm内部实现控制的",{"2":{"197":1}}],["synchronized关键字获取锁的过程中",{"2":{"194":1}}],["synchronized关键字和wait",{"2":{"187":1}}],["synchronized关键字和lock的实现类都是悲观锁",{"2":{"175":1}}],["synchronized关联了monitor",{"2":{"187":1}}],["synchronized和lock",{"2":{"146":1}}],["synchronized和lock都可以保证",{"2":{"145":1}}],["synchronized",{"2":{"143":3,"146":1,"155":1,"175":1,"177":1,"191":2}}],["s",{"2":{"139":1,"272":3,"283":1}}],["sleep不需要被唤醒",{"2":{"184":1}}],["sleep方法不会释放lock",{"2":{"184":1}}],["sleep方法不依赖于同步器synchronized",{"2":{"184":1}}],["sleep必须设置参数时间",{"2":{"184":1}}],["sleep是线程中的方法",{"2":{"184":1}}],["sleep的区别",{"0":{"184":1}}],["sleep",{"2":{"136":1,"154":2,"155":1,"157":1,"191":3,"195":1,"196":3}}],["sleepthread",{"2":{"62":1}}],["segment回滚段中",{"2":{"279":1}}],["segment",{"2":{"274":3,"279":1}}],["selet",{"2":{"271":1}}],["select语句",{"2":{"264":3}}],["select的访问频次",{"2":{"259":1}}],["select的任何一个",{"2":{"229":1}}],["select",{"2":{"218":1,"220":8,"221":3,"225":2,"226":2,"227":1,"228":2,"229":2,"237":1,"240":1,"259":4,"260":4,"262":9,"264":7,"265":3,"271":3,"272":3,"280":2,"283":1}}],["search",{"2":{"265":2}}],["session",{"2":{"265":6}}],["session|global",{"2":{"240":1,"259":1}}],["secondary",{"2":{"257":1}}],["seconds",{"2":{"126":1,"136":1,"191":3,"195":1,"196":3}}],["seriaiizable",{"2":{"280":1}}],["serializable",{"2":{"240":1}}],["serial与happens",{"2":{"161":1}}],["serial语义",{"2":{"146":1}}],["server",{"2":{"160":1}}],["setatomicinteger",{"2":{"177":1}}],["setnumber",{"2":{"177":1}}],["set",{"2":{"152":4,"153":1,"154":2,"168":1,"170":1,"219":1,"237":1,"240":1,"251":2,"262":3,"265":3}}],["setdaemon",{"0":{"75":1}}],["stmt",{"2":{"267":1}}],["student",{"2":{"264":2}}],["str",{"2":{"221":6}}],["string>",{"2":{"154":2}}],["string",{"2":{"62":1,"97":1,"136":1,"144":1,"146":1,"152":1,"153":1,"154":4,"155":1,"157":1,"168":1,"169":1,"170":1,"171":1,"178":1,"191":2,"195":2,"196":2}}],["styled",{"2":{"207":1}}],["stos",{"2":{"165":2}}],["storeload屏障",{"2":{"165":1}}],["storeload",{"2":{"164":2,"165":1}}],["store2",{"2":{"164":2}}],["storesore",{"2":{"164":1}}],["storestore屏障",{"2":{"165":1}}],["storestore",{"2":{"164":1}}],["store1",{"2":{"164":2}}],["store",{"2":{"158":1,"165":2}}],["stored",{"2":{"141":1}}],["stop",{"2":{"140":4,"141":3,"283":2}}],["sta",{"2":{"262":3}}],["statement",{"2":{"265":7}}],["status",{"2":{"259":1,"262":1}}],["status命令可以提供服务器",{"2":{"259":1}}],["staticprivate",{"2":{"153":1}}],["static",{"2":{"62":1,"66":1,"97":1,"136":1,"139":4,"141":7,"144":1,"146":3,"152":3,"153":2,"154":2,"155":1,"157":4,"168":1,"169":1,"170":1,"171":1,"172":1,"178":1,"191":2,"195":3,"196":4}}],["stack",{"2":{"165":18}}],["start+len字符串截取",{"2":{"221":1}}],["start",{"2":{"62":1,"97":1,"138":1,"144":1,"152":2,"154":2,"155":1,"157":2,"191":3,"195":2,"196":2,"221":2,"283":2}}],["start与run",{"0":{"56":1},"1":{"57":1,"58":1,"59":1,"60":1}}],["old表示将要或者已经删除的数据",{"2":{"267":1}}],["old表示修改之前的数据",{"2":{"267":1}}],["open",{"2":{"265":1}}],["openjdk",{"2":{"189":1}}],["options",{"2":{"283":7}}],["option>",{"2":{"264":1}}],["option子句创建视图时",{"2":{"264":1}}],["option",{"2":{"264":5}}],["ozntel",{"2":{"214":1}}],["over",{"2":{"210":1}}],["override",{"2":{"54":1,"97":1,"136":1,"138":1,"144":1,"146":3,"154":2,"191":2,"195":1,"196":1}}],["oop",{"2":{"165":2}}],["other",{"2":{"162":1}}],["otherwise",{"2":{"139":1}}],["obsidian",{"0":{"209":1,"212":1},"2":{"207":3,"208":2,"209":2,"210":2,"212":2,"213":1,"214":1,"215":2,"216":2}}],["obj",{"2":{"165":19,"187":3}}],["object",{"2":{"146":3,"152":2,"165":4,"179":5,"271":5,"272":2}}],["obtains",{"2":{"139":1}}],["o",{"2":{"145":1,"190":2,"191":1,"269":1,"283":1}}],["organization",{"2":{"262":1}}],["or连接的条件",{"2":{"260":1}}],["or",{"2":{"141":1,"220":1,"264":2}}],["orderaccess",{"2":{"165":3}}],["order",{"2":{"141":1,"220":2,"261":1,"262":5}}],["on",{"2":{"221":2,"225":1,"226":2,"227":1,"258":2,"260":2,"262":3,"267":1}}],["only",{"2":{"140":1,"271":1}}],["one",{"2":{"139":1}}],["offset=",{"2":{"283":1}}],["offset",{"2":{"165":16}}],["of",{"2":{"139":2,"214":1}}],["outer",{"2":{"226":4}}],["out",{"2":{"54":1,"126":1,"127":4,"136":1,"140":1,"144":1,"146":1,"154":2,"155":1,"157":4,"168":13,"169":5,"170":3,"171":2,"172":2,"178":2,"190":1,"191":8,"195":3,"196":1,"265":2}}],["=name",{"2":{"283":2}}],["=null",{"2":{"146":1,"152":1}}],["=20",{"2":{"264":1}}],["=count",{"2":{"262":1}}],["=true",{"2":{"146":2}}],["=false",{"2":{"146":1}}],["=15",{"2":{"264":1}}],["=1",{"2":{"146":2}}],["=10",{"2":{"126":1}}],["=0",{"2":{"146":2}}],["=======================",{"2":{"177":1}}],["=============乐观锁的调用方式",{"2":{"176":1}}],["=============success",{"2":{"157":1}}],["==",{"2":{"140":1,"162":2,"165":14,"196":1,"280":1}}],["=",{"2":{"54":1,"97":3,"127":4,"136":6,"138":3,"140":21,"141":9,"143":1,"144":3,"146":4,"152":10,"153":4,"154":6,"155":2,"157":3,"162":3,"165":1,"168":25,"169":8,"170":7,"171":1,"172":3,"175":1,"176":1,"177":2,"178":1,"190":2,"191":9,"195":3,"196":4,"197":2,"220":4,"221":1,"229":1,"231":3,"233":1,"237":1,"243":1,"251":2,"256":1,"262":1,"264":1,"265":8,"277":1,"280":2}}],["txt",{"2":{"283":1}}],["txt文件",{"2":{"283":1}}],["tmp",{"2":{"283":1}}],["t参数后导出的文件文本",{"2":{"283":1}}],["ts",{"2":{"277":1}}],["tbl",{"2":{"267":1}}],["tb",{"2":{"260":5,"262":17}}],["tgrosinger",{"2":{"216":1}}],["t2获取到了锁",{"2":{"195":1}}],["t2开始获取锁",{"2":{"195":1}}],["t2",{"2":{"195":3,"196":4}}],["t3",{"2":{"177":1}}],["type",{"2":{"165":14,"218":1,"221":1,"259":2,"266":1,"271":3,"272":1}}],["t=",{"2":{"152":1}}],["t",{"2":{"152":5,"165":2,"178":2,"189":1,"190":1,"195":6,"196":6,"221":2,"262":2,"283":2}}],["temporary",{"2":{"277":1}}],["tex主键乱序插入",{"2":{"262":1}}],["texusing",{"2":{"260":1}}],["tex中断标志",{"2":{"196":1}}],["textfile2",{"2":{"283":1}}],["textfile1",{"2":{"283":1}}],["text01",{"2":{"283":1}}],["text等",{"2":{"260":1}}],["text",{"2":{"256":1,"283":1}}],["text介绍",{"2":{"253":1}}],["text1700663163568",{"2":{"195":1}}],["text锁对象刚被创建",{"2":{"190":1}}],["textcas是jdk提供的非阻塞原子性操作",{"2":{"178":1}}],["text说明",{"2":{"172":1}}],["terminated",{"2":{"141":4,"262":2}}],["testsleep",{"2":{"62":1}}],["test1",{"2":{"54":1}}],["test",{"2":{"54":1,"154":2,"262":4,"283":1}}],["tidying",{"2":{"141":5}}],["time等",{"2":{"265":1}}],["time=2",{"2":{"259":1}}],["timeout",{"2":{"204":1}}],["time",{"2":{"140":1,"259":1}}],["timeunit",{"2":{"126":1,"136":1,"140":1,"153":1,"191":1,"195":1,"196":4,"204":1}}],["timedout",{"2":{"140":4}}],["timed",{"0":{"87":1},"1":{"88":1,"89":1,"90":1},"2":{"140":3}}],["tab=name\\t\\t\\t\\t自动生成两个文件",{"2":{"283":1}}],["table语句",{"2":{"283":1}}],["table\\t\\t\\t在每个表创建语句前加上drop",{"2":{"283":1}}],["table",{"2":{"216":1,"218":9,"243":1,"246":2,"258":3,"260":4,"262":3,"271":1,"277":3,"283":2}}],["tablespace语法创建通用表空间",{"2":{"277":1}}],["tablespaces",{"2":{"277":4}}],["tablespace",{"2":{"277":4}}],["tables",{"0":{"216":1},"2":{"216":1,"218":1,"271":3,"283":1}}],["take",{"2":{"140":1}}],["task2中val和finish操作顺序调整对单线程来说是没有任何影响的",{"2":{"146":1}}],["task2",{"2":{"146":1}}],["task1不会出现val为null时被使用的情况",{"2":{"146":1}}],["task1",{"2":{"146":1}}],["task对象作为thread对象的target创建",{"2":{"97":1}}],["task",{"2":{"97":4,"126":1,"136":2,"138":2,"139":15,"140":8,"144":2,"146":1}}],["tom",{"2":{"262":4}}],["tomcat线程池构造函数调用此方法而jdk没有",{"2":{"137":1}}],["tomcat线程池和jdk线程池区别",{"0":{"137":1}}],["tomcat用来接受处理外部的请求的线程就是守护线程",{"0":{"80":1}}],["toprintabble",{"2":{"191":2}}],["toprintable",{"2":{"190":1,"191":5}}],["tos",{"2":{"165":14}}],["tostring",{"2":{"139":2,"146":1,"170":2}}],["to",{"2":{"139":8,"140":1,"207":1,"218":1,"221":1}}],["that",{"2":{"139":1}}],["then",{"2":{"139":1,"221":4,"265":6}}],["the",{"2":{"139":16,"140":1,"141":1,"214":2}}],["this",{"2":{"136":1,"139":4,"140":1,"152":1,"162":1,"196":2,"208":1}}],["threshold",{"2":{"262":2}}],["thread的工作压力",{"2":{"278":1}}],["thread刷新脏页到磁盘的线程",{"2":{"278":1}}],["thread主要负责这些io请求的回调",{"2":{"278":1}}],["thread巧也来执行synchronized",{"2":{"187":1}}],["thread2",{"2":{"152":2,"191":1}}],["thread1",{"2":{"152":2,"191":1}}],["threadlocal内存泄漏是怎么回事",{"0":{"153":1}}],["threadlocals",{"2":{"152":2}}],["threadlocalmap也是通过强引用指向entry对象",{"2":{"153":1}}],["threadlocalmap",{"2":{"152":3}}],["threadlocal底层是通过threadlocalmap来实现的",{"2":{"152":1}}],["threadlocal是java中所提供的线程本地存储机制",{"2":{"152":1}}],["threadlocal是整个线程的全局变量",{"2":{"152":1}}],["threadlocal是什么",{"0":{"152":1}}],["threadlocal也就是线程本地变量",{"2":{"152":1}}],["threadlocal",{"0":{"151":1},"1":{"152":1},"2":{"152":5,"153":5,"154":8}}],["threaddemo",{"2":{"144":3}}],["threadfactory",{"0":{"134":1}}],["threadpoolexecutor",{"2":{"136":2,"139":4,"140":1}}],["threadpool",{"2":{"126":4,"127":2,"136":3}}],["thread实现的线程我们都是无法返回结果的",{"0":{"96":1}}],["thread",{"2":{"54":1,"63":1,"97":1,"136":2,"138":1,"139":1,"140":3,"144":2,"152":7,"154":10,"155":1,"157":3,"187":3,"191":8,"195":1,"196":1,"278":8}}],["throwable",{"2":{"140":1}}],["throw",{"2":{"97":2,"139":1,"140":1,"155":1,"195":1}}],["throws",{"2":{"96":1,"97":1,"139":2,"153":1,"154":2,"157":1,"178":1,"191":1,"196":1}}],["trx",{"2":{"274":1,"276":1,"280":14}}],["triggers",{"2":{"267":1}}],["trigger",{"2":{"267":4}}],["trim",{"2":{"221":1}}],["tree区别",{"2":{"256":1}}],["tree为例",{"2":{"256":1}}],["tree",{"2":{"256":2}}],["transaction",{"2":{"240":2,"262":1,"270":1}}],["truncate",{"2":{"218":1}}],["true表示获取锁成功",{"2":{"194":1}}],["true",{"0":{"75":1},"2":{"137":1,"140":2,"155":1,"157":1,"168":1,"196":1}}],["trylock",{"0":{"195":1},"2":{"195":2}}],["tryterminate",{"2":{"140":1}}],["try",{"2":{"97":1,"126":1,"136":2,"140":5,"191":1,"195":1,"196":1}}],["t1未能获取到锁",{"2":{"195":1}}],["t1开始获取锁",{"2":{"195":1}}],["t1",{"2":{"54":1,"195":3,"196":3}}],["\\tmysqlimport",{"2":{"283":2}}],["\\tmysqldump",{"2":{"283":3}}],["\\tmysqlshow",{"2":{"283":4}}],["\\tmysqlbinlog",{"2":{"283":1}}],["\\tmysql",{"2":{"283":2}}],["\\tnot",{"2":{"265":1}}],["\\tnew",{"2":{"191":1}}],["\\tcontinue",{"2":{"265":1}}],["\\tuntil条件",{"2":{"265":1}}],["\\tusertest",{"2":{"191":1}}],["\\twhen",{"2":{"265":2}}],["\\twhile",{"2":{"137":1}}],["\\tfinal",{"2":{"191":1}}],["\\tfor",{"2":{"126":1}}],["\\tatomicinteger",{"2":{"177":1}}],["\\ttrigger",{"2":{"267":1}}],["\\ttry",{"2":{"175":1}}],["\\tthread",{"2":{"54":1}}],["\\tlock",{"2":{"175":1}}],["\\tlongaccumulator",{"2":{"172":4}}],["\\tlongadder",{"2":{"172":3}}],["\\tsource",{"2":{"283":1}}],["\\tsqlexception",{"2":{"265":1}}],["\\tsqlwarning",{"2":{"265":1}}],["\\tsqlstate",{"2":{"265":1}}],["\\tsql逻辑",{"2":{"265":2}}],["\\tsq逻辑",{"2":{"265":1}}],["\\tsync",{"2":{"197":2}}],["\\tsynchronized",{"2":{"191":2}}],["\\tsystem",{"2":{"126":1,"127":1,"172":2}}],["\\tstatic",{"2":{"155":1}}],["\\tprivate",{"2":{"141":1,"153":1,"162":1}}],["\\tpublic",{"2":{"62":1,"138":1,"155":1,"162":1,"177":4,"178":1}}],["\\tinteger",{"2":{"189":1}}],["\\tint",{"2":{"137":1}}],["\\treturn",{"2":{"127":1,"137":1,"266":1}}],["\\texit",{"2":{"265":1}}],["\\te",{"2":{"126":1}}],["\\tvolatile",{"2":{"177":1}}],["\\tv",{"2":{"96":1}}],["\\t\\t指定密码",{"2":{"283":1}}],["\\t\\te",{"2":{"191":2}}],["\\t\\tsystem",{"2":{"178":1,"191":2}}],["\\t\\tatomicinteger",{"2":{"177":1,"178":1}}],["\\t\\tnumber++",{"2":{"177":1}}],["\\t\\tnew",{"2":{"62":1,"155":1}}],["\\t\\tlock",{"2":{"175":1}}],["\\t\\treturn",{"2":{"162":1,"177":2}}],["\\t\\trunnable",{"2":{"138":1}}],["\\t\\tif",{"2":{"162":1}}],["\\t\\tthread",{"2":{"155":1}}],["\\t\\tthreadpool",{"2":{"126":1}}],["\\t\\t\\tsynchronized",{"2":{"191":2}}],["\\t\\t\\tsynchronize",{"2":{"162":1}}],["\\t\\t\\tsystem",{"2":{"54":1}}],["\\t\\t\\twhile",{"2":{"155":1}}],["\\t\\t\\t\\ttry",{"2":{"191":2}}],["\\t\\t\\t\\tsystem",{"2":{"191":2}}],["\\t\\t\\t\\tif",{"2":{"162":1}}],["\\t\\t\\t\\t\\t指定连接端口",{"2":{"283":1}}],["\\t\\t\\t\\t\\ttime",{"2":{"191":2}}],["\\t\\t\\t\\t\\thelper",{"2":{"162":1}}],["\\t\\t\\t\\t\\t",{"2":{"146":1}}],["\\t\\t\\t\\t",{"2":{"146":5,"155":4,"162":1,"283":1}}],["\\t\\t\\t",{"2":{"144":2,"146":6,"155":1,"162":1,"191":2}}],["\\t\\t\\ttask",{"2":{"138":1}}],["\\t\\twhile",{"2":{"138":1}}],["\\t\\t++n",{"2":{"137":1}}],["\\t\\tpublic",{"2":{"54":1,"191":2}}],["\\t\\t",{"2":{"54":2,"138":1,"144":6,"146":4,"155":3,"162":1,"175":1,"191":2,"283":1}}],["\\t",{"2":{"54":2,"62":1,"126":5,"137":1,"138":2,"141":1,"144":7,"146":5,"155":1,"162":2,"168":1,"172":1,"175":3,"177":11,"178":2,"187":1,"189":4,"191":10,"265":9,"266":1,"283":26}}],["ptr",{"2":{"280":1}}],["phone进行降序排序",{"2":{"262":1}}],["phone进行升序排序",{"2":{"262":1}}],["phone进行排序",{"2":{"262":1}}],["phone",{"2":{"262":8}}],["per",{"2":{"246":2,"277":2}}],["performance",{"2":{"210":1,"271":2,"272":1,"282":1}}],["p",{"2":{"217":2,"262":1,"283":11}}],["pool刷新到磁盘前",{"2":{"277":1}}],["pool数据的查询",{"2":{"276":1}}],["pool中",{"2":{"276":2}}],["pool",{"2":{"275":1}}],["pointer",{"2":{"274":1}}],["possible",{"2":{"259":1}}],["position=pos2",{"2":{"283":1}}],["position=pos1",{"2":{"283":1}}],["position",{"0":{"215":1},"2":{"215":2}}],["policy",{"2":{"251":1}}],["poll",{"2":{"138":1,"139":1,"140":2}}],["port=",{"2":{"283":1}}],["port=port",{"2":{"283":1}}],["port",{"2":{"217":1}}],["path",{"2":{"277":1}}],["page",{"2":{"275":3,"278":1}}],["pad",{"2":{"221":2}}],["password",{"2":{"217":1,"221":1,"251":2,"283":2}}],["pair",{"0":{"213":1},"2":{"213":1}}],["parseinstance",{"2":{"190":1,"191":8}}],["param",{"2":{"139":8}}],["plugin",{"0":{"209":1},"2":{"208":1,"214":1,"215":1}}],["player",{"0":{"208":1},"2":{"208":1}}],["purge",{"2":{"278":1}}],["put",{"2":{"165":16}}],["public",{"2":{"54":1,"64":1,"65":1,"66":1,"97":2,"136":3,"139":8,"144":2,"146":4,"152":1,"153":1,"154":4,"157":2,"175":1,"179":3,"191":1,"195":3,"196":5,"197":1}}],["proutines",{"2":{"265":1}}],["proceduer",{"2":{"265":3}}],["processworkerexit",{"2":{"140":2}}],["profession",{"2":{"262":7}}],["profiling=1",{"2":{"259":1}}],["profiling",{"2":{"259":1}}],["profiling参数",{"2":{"259":1}}],["profile",{"2":{"259":2}}],["profile能够在做sql优化时帮助我们了解时间都耗费到哪里去了",{"2":{"259":1}}],["profile详情",{"2":{"259":1}}],["pro",{"2":{"262":3}}],["prepare",{"2":{"157":2}}],["preparedata",{"2":{"157":2,"160":1}}],["prestartallcorethreads",{"2":{"137":1}}],["prifiles",{"2":{"259":1}}],["primary",{"2":{"222":1,"257":1,"259":1}}],["private",{"2":{"141":6,"157":2,"176":1,"195":1,"196":2}}],["printstacktrace",{"2":{"126":2,"136":2,"191":3,"196":1}}],["println",{"2":{"54":1,"126":1,"127":4,"136":1,"144":1,"146":1,"154":2,"155":1,"157":4,"168":13,"169":5,"170":3,"171":2,"172":2,"178":2,"190":1,"191":8,"195":3,"196":1}}],["pid",{"0":{"9":1}}],["通用表空间",{"2":{"277":1}}],["通常有序索引顺序扫描直接返回有序数据",{"2":{"262":1}}],["通常表的索引或全表扫描",{"2":{"262":1}}],["通常只需要一次检索就可以了",{"2":{"256":1}}],["通常使用较少",{"2":{"256":1}}],["通常用于临时表及缓存",{"2":{"250":1}}],["通常",{"2":{"166":1}}],["通常锁的粒度都要大于原子变量的粒度",{"2":{"166":1}}],["通过帮助文档查看选项",{"2":{"283":1}}],["通过视图用户只能",{"2":{"264":1}}],["通过创建",{"2":{"262":1}}],["通过have",{"2":{"259":1}}],["通过以下指令重启mysql服务器进行测试",{"2":{"259":1}}],["通过如下指令",{"2":{"259":1}}],["通过show",{"2":{"259":1}}],["通过索引列对数据进行排序",{"2":{"255":1}}],["通过双重检查锁",{"2":{"162":1}}],["通过重复利用已创建的线程降低线程创建和销毁造成的销耗",{"0":{"116":1}}],["通过检查中断标志位",{"0":{"66":1}}],["通过实现runnable",{"0":{"54":1}}],["通过继承thread",{"0":{"53":1}}],["通俗的讲",{"2":{"264":1}}],["通俗",{"0":{"25":1,"28":1,"31":1}}],["通俗地说",{"0":{"17":1}}],["通俗角度",{"0":{"17":1}}],["5版本开始",{"2":{"275":1}}],["5个区",{"2":{"274":1}}],["5个指针",{"2":{"256":1}}],["5中引入了mdl",{"2":{"271":1}}],["5阶",{"2":{"256":1}}],["5之后",{"2":{"246":1}}],["5",{"0":{"51":1},"2":{"97":2,"127":2,"141":1,"153":1,"168":7,"169":4,"178":3,"184":1,"195":1,"196":1,"204":1,"260":1,"262":3}}],["消耗大量的cpu资源",{"0":{"50":1}}],["4阶",{"2":{"256":1}}],["4个字节的classpoint",{"2":{"189":1}}],["4",{"0":{"50":1},"2":{"141":1,"169":1,"172":1,"184":1,"187":1,"191":1,"204":1,"251":1,"262":3,"278":2}}],["执行sql语句并退出",{"2":{"283":1}}],["执行创建存储过程的sql时",{"2":{"265":1}}],["执行分组操作",{"2":{"262":3}}],["执行load指令将准备好的数据",{"2":{"262":1}}],["执行如下sql语句",{"2":{"260":1}}],["执行一系列的业务sql操作",{"2":{"259":1}}],["执行的测试",{"2":{"251":1}}],["执行顺序从上到下",{"2":{"259":1}}],["执行顺序",{"2":{"220":1}}],["执行cmpxchg指令的时候",{"2":{"178":1}}],["执行cas操作的时候",{"2":{"178":1}}],["执行了1000次+1操作",{"2":{"144":1}}],["执行完terminated",{"2":{"141":1}}],["执行任务",{"2":{"140":1}}],["执行优先",{"2":{"136":1}}],["执行run方法它不会产生新线程",{"2":{"59":1}}],["执行",{"0":{"49":1},"2":{"127":2,"155":1,"180":1}}],["就可以从undo",{"2":{"279":1}}],["就可以使用runnable接口的方式",{"0":{"104":1}}],["就用它来回收",{"2":{"278":1}}],["就形成了带有顺序指针的b+tree",{"2":{"256":1}}],["就会使用到mysqlbinlog日志关系工具",{"2":{"283":1}}],["就会视为慢查询",{"2":{"259":1}}],["就会进入entrylist",{"2":{"187":1}}],["就会将monitor的所有者owner置为thread",{"2":{"187":1}}],["就会出现finish为true",{"2":{"146":1}}],["就会由stop",{"2":{"141":1}}],["就会由",{"2":{"141":2}}],["就把内存中的变量赋值为b",{"2":{"144":1}}],["就变成terminated状态",{"2":{"141":1}}],["就处于running状态",{"2":{"141":1}}],["就是快照读",{"2":{"280":1}}],["就是数据库sql语言层面的代码封装与重用",{"2":{"265":1}}],["就是在sql语句中加入一些人为的提示来达到优化操作的目的",{"2":{"260":1}}],["就是在等待获取锁的过程中",{"2":{"196":1}}],["就是在你几乎不可能察觉到的速度不断去切换这两个任务",{"0":{"34":1}}],["就是管理类的状态变量",{"2":{"187":1}}],["就是执行完一个任务",{"0":{"109":1}}],["就无法再继承其它类",{"0":{"104":1}}],["就要使用callable",{"0":{"96":1}}],["就造成了多线程的",{"0":{"49":1}}],["多版本并发控制",{"2":{"279":1,"280":1}}],["多字段排序",{"2":{"262":1}}],["多字段排序时",{"2":{"262":1}}],["多条件联合查询时",{"2":{"260":1}}],["多路平衡查找树",{"2":{"256":1}}],["多表查询",{"0":{"224":1}}],["多表关系",{"0":{"223":1}}],["多对多",{"2":{"223":1}}],["多选一",{"2":{"220":1,"232":1}}],["多个线程同时执行cas操作只有一个会成功",{"2":{"178":1}}],["多个线程操作这个变量的时候",{"2":{"152":1}}],["多个cpu从主内存读取到同一个数据到各自的高速缓存",{"2":{"159":1}}],["多线程环境下不使用原子类保证数据安全",{"2":{"177":1}}],["多线程下并发同时对共享数据进行读写",{"2":{"143":1}}],["多线程同时执行",{"0":{"48":1}}],["多线程往往会比单线程更快",{"0":{"42":1}}],["多任务系统往往需要同时执行多道作业",{"0":{"44":1}}],["更改缓冲区",{"2":{"276":1}}],["更改用户密码",{"2":{"221":1}}],["更新",{"2":{"264":1}}],["更新字段数据类型",{"2":{"219":1}}],["更新的原子性",{"2":{"178":1}}],["更新已完成任务数",{"2":{"140":1}}],["更新已完成任务的数量",{"2":{"140":1}}],["更多的线程意味着线程创建销毁开销加大",{"0":{"42":1}}],["更能够提高并发",{"0":{"42":1}}],["汪意这个核心数指的是逻辑处理器数",{"0":{"39":1}}],["内部包含1024个undo",{"2":{"279":1}}],["内连接",{"0":{"225":1}}],["内核数是6而逻辑处理器数是12",{"0":{"38":1}}],["内存结构",{"0":{"276":1}}],["内存存放",{"2":{"248":1}}],["内存位置",{"2":{"178":1,"180":1}}],["内存屏障",{"0":{"163":1},"1":{"164":1,"165":1}}],["内存的结构看下图",{"2":{"145":1}}],["内存的矛盾开始说起",{"2":{"145":1}}],["内存泄漏",{"2":{"126":1}}],["内存",{"0":{"9":1},"2":{"145":1}}],["吃饭的时候可以边吃饭边打电话",{"0":{"35":1}}],["例如插入",{"2":{"264":1}}],["例如",{"2":{"146":1}}],["例",{"0":{"35":1}}],["其典型的使用场景是做全库的逻辑备份",{"2":{"270":1}}],["其语法分别如下",{"2":{"265":1}}],["其作用域为当前连接",{"2":{"265":1}}],["其功能非常强大",{"2":{"180":1}}],["其主要原理是在硬件层面实现的",{"2":{"180":1}}],["其它cpu通过总线嗅探器机制可以感知到数据的变化从而将自己缓存里的数据失效",{"2":{"159":1}}],["其它线程可以使用interrupt方法打断正在睡眠的线程",{"2":{"62":1}}],["其他记录丢弃",{"2":{"262":1}}],["其他没有获得锁的线程不能读也不能写",{"2":{"202":1}}],["其他操作只能获取操作前或操作后的变量数据",{"2":{"146":1}}],["其他线程也能获得共享锁",{"2":{"203":1}}],["其他线程使用共享变量会去内存中读取",{"2":{"145":1}}],["其他线程需等待操作结束才能使用临界资源",{"2":{"144":1}}],["其他线程需要排队等待",{"0":{"32":1}}],["其他线程获取操作的变量时",{"2":{"144":1}}],["其中有很多的知识点没有详细的说",{"2":{"146":1}}],["其中的线程可以反复使用",{"0":{"111":1}}],["其实在jdk1",{"2":{"186":1}}],["其实在这一点上还是有排他锁的",{"2":{"178":1}}],["其实就是一个容纳多个线程的容器",{"0":{"111":1}}],["其实并不是的",{"0":{"34":1}}],["其底层还是sleep方法",{"2":{"62":1}}],["同样",{"2":{"276":1}}],["同样在time",{"0":{"88":1}}],["同步和互斥",{"2":{"187":1}}],["同一对象",{"2":{"143":1}}],["同一时间",{"0":{"47":1}}],["同一时刻只能有一个线程对数据进行操作",{"2":{"143":1}}],["同一时刻只能运行一个程序",{"0":{"32":1}}],["同一时刻",{"0":{"12":1,"38":1}}],["同时锁住数据",{"2":{"272":1}}],["同时却也降低更新表的速度",{"2":{"255":1}}],["同时读写",{"2":{"143":1}}],["同时",{"0":{"49":1}}],["同时执行效果",{"0":{"34":1}}],["综合来说",{"0":{"33":1}}],["一行一行地判断",{"2":{"262":1}}],["一般分页查询时",{"2":{"262":1}}],["一般情况下包含三个操作数",{"2":{"180":1}}],["一般情况下",{"0":{"96":1},"2":{"194":1}}],["一致性",{"2":{"238":1,"279":1}}],["一对一",{"2":{"223":1}}],["一对多",{"2":{"223":1}}],["一是禁止指令重排",{"2":{"155":1}}],["一是可见性",{"2":{"155":1}}],["一直到a和内存中一致",{"2":{"144":1}}],["一",{"0":{"144":1}}],["一次仅允许一个线程使用",{"2":{"143":1}}],["一次只能执行一个线程代码指令",{"0":{"32":1}}],["一旦被终止就不能再有任何状态的变化",{"0":{"93":1}}],["一旦进入runnable状态就不能回到new状态",{"0":{"93":1}}],["一个",{"2":{"283":2}}],["一个mysql实例可以对应多个表空间",{"2":{"274":1}}],["一个常见有非常头疼的问题就是limit",{"2":{"262":1}}],["一个升序一个降序",{"2":{"262":1}}],["一个或多个",{"2":{"259":1}}],["一个事务采用的间隙锁不会阻止另一个事务在同一个间隙上采用间隙锁",{"2":{"272":1}}],["一个事务按照条件查询数据时",{"2":{"239":1}}],["一个事务先后读取同一条记录",{"2":{"239":1}}],["一个事务读到另一个事务还没有提交的数据",{"2":{"239":1}}],["一个操作是不可中断的",{"2":{"166":1}}],["一个处理器的缓存回写到内存会导致其他处理器的缓存无效",{"2":{"159":1}}],["一个具有优先级排序的无界blockingqueue",{"2":{"133":1}}],["一个由链接节点组成的无界blockingqueue",{"2":{"133":1}}],["一个由数组支持的固定大小的blockingqueue",{"2":{"133":1}}],["一个是同时执行",{"0":{"36":1}}],["一个是交替执行",{"0":{"36":1}}],["一个cpu核心只能运行一个线程",{"0":{"12":1,"38":1}}],["一个进程可以包含多个线程",{"0":{"11":1}}],["闭",{"0":{"32":1}}],["关键字",{"2":{"257":1}}],["关联另一方的主键",{"2":{"223":1}}],["关联两张表的主键",{"2":{"223":1}}],["关联一的一方的主键",{"2":{"223":1}}],["关闭游标",{"2":{"265":1}}],["关闭指针压缩后是8个字节",{"2":{"189":1}}],["关闭线程池",{"2":{"126":1}}],["关",{"0":{"32":1}}],["只列出指定的数据库相关操作",{"2":{"283":1}}],["只不过获取到的值为null",{"2":{"265":1}}],["只不过是给人的感觉是同时运行",{"0":{"26":1}}],["只是记录被标记",{"2":{"262":1}}],["只是比起用synchronized",{"2":{"178":1}}],["只是在更新数据的时候去判断之前有没有别的线程更新了这个数据",{"2":{"176":1}}],["只是计算机的速度太快",{"0":{"34":1}}],["只读",{"0":{"149":1}}],["只要你排队",{"2":{"197":1}}],["只要记住下边两点内容",{"2":{"146":1}}],["只要保证执行结果不变",{"2":{"146":1}}],["只能有一个",{"2":{"257":1}}],["只能将这些表作为临时表或缓存表使用",{"2":{"248":1}}],["只能等待其他线程把锁释放之后才能够有机会获取到锁",{"2":{"194":1}}],["只能等qq执行完成",{"0":{"32":1}}],["只能获取操作前的变量值和操作后的变量值",{"2":{"144":1}}],["只会等待正在执行的线程执行完成之后才彻底关闭",{"2":{"126":1}}],["只有精确匹配索引列的查询才有效",{"2":{"256":1}}],["只有很少的更新和删除操作",{"2":{"250":1}}],["只有一个线程会对总线加锁成功",{"2":{"178":1}}],["只有处于中间状态才可以相互转换",{"0":{"94":1}}],["只有当执行了locksupport",{"0":{"86":1}}],["只有1个线程在执行",{"0":{"47":1}}],["我个人理解是cpu是多核处理的",{"2":{"146":1}}],["我们虽然保证了线程安全",{"2":{"203":1}}],["我们需要先弄清楚一些概念",{"2":{"193":1}}],["我们就无法正确判断这个变量是否被修改过",{"2":{"183":1}}],["我们可以在缓冲池中进行合并处理",{"2":{"276":1}}],["我们可以在备份时加上参数",{"2":{"270":1}}],["我们可以看到getandaddint方法执行时",{"2":{"181":1}}],["我们可以发现当我们改变了inheritablethreadlocal中的值后",{"2":{"154":1}}],["我们看一下下面的代码",{"2":{"154":1}}],["我们使用线程的时候就去创建一个线程",{"0":{"107":1}}],["我们上面说过必须要线程获得monitor锁",{"0":{"84":1}}],["我们无法察觉到而已",{"0":{"34":1}}],["我打开qq后",{"0":{"32":1}}],["我总结",{"0":{"6":1}}],["序",{"0":{"32":1}}],["厨师按菜单顺序炒菜",{"0":{"31":1}}],["厨师想了个办法",{"0":{"25":1}}],["先将数据页写入双写缓冲区文件中",{"2":{"277":1}}],["先操作缓冲池的数据",{"2":{"275":1}}],["先执行一次逻辑",{"2":{"265":1}}],["先判定条件",{"2":{"265":1}}],["先加锁可以保证写操作时数据正确",{"2":{"175":1}}],["先递增再获取",{"2":{"168":1}}],["先获取再递增",{"2":{"168":1}}],["先对no++这个操作分解",{"2":{"144":1}}],["先到先得",{"0":{"31":1}}],["先有进程",{"0":{"21":1}}],["能够此较好地提高性能",{"2":{"262":1}}],["能够看到当前mysql是否支持profile操作",{"2":{"259":1}}],["能够接收新任务",{"2":{"141":1}}],["能够直接执行的最小代码块",{"0":{"11":1}}],["能大大是高电脑运行的效率",{"0":{"29":1}}],["目前主流cpu都是多核的",{"0":{"38":1}}],["目前电脑市场上说的多核cpu",{"0":{"29":1}}],["目录",{"0":{"1":1}}],["即一个区中一共有64个连续的页",{"2":{"274":1}}],["即一个索引包含了多个列",{"2":{"260":1}}],["即一个索引只包含单个列",{"2":{"260":1}}],["即可以作为输入参数",{"2":{"265":1}}],["即可以多个处理器并行处理指令",{"2":{"146":1}}],["即外层的查询",{"2":{"259":1}}],["即这些操作要么同时成功",{"0":{"236":1},"1":{"255":1},"2":{"279":1}}],["即置为false",{"2":{"196":1}}],["即不使用表连接或者子查询",{"2":{"259":1}}],["即不可降级",{"2":{"188":1}}],["即不影响单线程的运行结果",{"2":{"146":1}}],["即比较并替换",{"2":{"176":1}}],["即便是多线程的情况下也可以保证",{"2":{"166":1}}],["即利用每个处理器来外稗一个可以并发执行的程序",{"0":{"29":1}}],["即见上这些程序是分时的交替运行",{"0":{"26":1}}],["在事务中每一次执行快照读时生成readview",{"2":{"280":1}}],["在事务提交之后",{"2":{"278":1}}],["在未来数据被读取时",{"2":{"276":1}}],["在未建立索引之前",{"2":{"260":1}}],["在执行dml语句时",{"2":{"276":1}}],["在执行增删改查操作时",{"2":{"275":1}}],["在执行任务之前",{"2":{"140":1}}],["在执行任务前调用beforeexecute方法",{"2":{"140":1}}],["在日常开发中使用非常广泛",{"2":{"275":1}}],["在rr隔离级别下支持",{"2":{"272":1}}],["在rr隔离级别下都支持",{"2":{"272":1}}],["在rc",{"2":{"272":1}}],["在表上有活动事务的时候",{"2":{"271":1}}],["在访问一张表的时候会自动加上",{"2":{"271":1}}],["在数据库中",{"2":{"269":1}}],["在数据之外",{"2":{"253":1}}],["在存储过程和函数中可以使用游标对结果集进行循环的处理",{"2":{"265":1}}],["在用的时候直接用",{"2":{"265":1}}],["在命令行中",{"2":{"265":1}}],["在分组操作时",{"2":{"262":1}}],["在创建表或者创建索引时指定",{"2":{"262":1}}],["在创建表时",{"0":{"243":1},"2":{"277":1}}],["在业务场景中",{"2":{"260":1}}],["在该索引中已经全部能够找到",{"2":{"260":1}}],["在innodb中引入了意向锁",{"2":{"271":1}}],["在innodb引擎中",{"2":{"270":1}}],["在innodb引擎中的表中",{"2":{"259":1}}],["在innodb存储引擎中大量使用了aio来处理io请求",{"2":{"278":1}}],["在innodb存储引擎中",{"2":{"257":1,"262":1}}],["在不损失精确性的前提下",{"2":{"259":1}}],["在不影响单线程程序执行结果的前提下",{"2":{"161":1}}],["在mysql中",{"2":{"256":1}}],["在mysql5",{"2":{"246":1,"271":1,"277":1}}],["在原b+tree的基础上",{"2":{"256":1}}],["在选择存储引擎时",{"0":{"250":1}}],["在指定的集合范围内",{"2":{"232":1}}],["在其中任何一方设置外键",{"2":{"223":1}}],["在多的一方设置外键",{"2":{"223":1}}],["在多核cpu系统中",{"0":{"29":1}}],["在预览页面就可以看到录制的命令行记录",{"2":{"208":1}}],["在写的地方使用写锁",{"2":{"203":1}}],["在读的地方使用读锁",{"2":{"203":1}}],["在没有读写锁之前",{"2":{"203":1}}],["在没有线程竞争的条件下",{"2":{"191":1}}],["在大多数情况下",{"2":{"197":1}}],["在线程调用interrupt0方法之后",{"2":{"196":1}}],["在聊reentranlock之前",{"2":{"193":1}}],["在此阶段",{"2":{"191":1}}],["在thread",{"2":{"187":1}}],["在threadpoolexecutor类中是空的",{"2":{"141":1}}],["在获取到当前变量v",{"2":{"183":1}}],["在任何时刻",{"2":{"182":1}}],["在任务异常完成后调用afterexecute方法",{"2":{"140":1}}],["在任务正常完成后调用afterexecute方法",{"2":{"140":1}}],["在store2及其后的写操作执行前",{"2":{"164":2}}],["在这种情况下我们可以使用",{"2":{"154":1}}],["在拥有了threadlocal的情况下",{"2":{"154":1}}],["在jvm层面",{"2":{"204":1}}],["在jk1",{"2":{"188":1}}],["在java领域就是",{"2":{"187":1}}],["在java中可以通过线程池来达到这样的效果",{"0":{"110":1}}],["在java中提供了runtime",{"0":{"39":1}}],["在jmm中volatile的读和写都会插入内存屏障来禁止处理器的重排",{"2":{"146":1}}],["在单线程中这样是没有问题的",{"2":{"146":1}}],["在操作过程中其他操作需要获取变量值",{"2":{"144":1}}],["在操作系统中",{"0":{"9":1,"26":1}}],["在主线程捕捉不到",{"2":{"127":1}}],["在循环访问锁的过程中",{"2":{"62":1}}],["在休眠结束的时候继续执行线程",{"2":{"61":1}}],["在我们前面的windows任务管理器贴图就能看出来",{"0":{"38":1}}],["高并发下logadder比atomiclog效率",{"2":{"172":1}}],["高档饭店就是好",{"0":{"28":1}}],["高效的处理请求",{"0":{"6":1}}],["饭店有多个厨师",{"0":{"28":1}}],["每秒将日志写入并刷新到磁盘一次",{"2":{"276":1}}],["每次select",{"2":{"280":1}}],["每次对某条引记录进行改动时",{"2":{"274":1}}],["每次对某条记录进行改动时",{"2":{"274":1}}],["每次操作锁住对应的行数据",{"2":{"269":1,"272":1}}],["每次操作锁住整张表",{"2":{"269":1,"271":1}}],["每桌安排一个厨师",{"0":{"28":1}}],["每一时刻只能有一道程序执行",{"0":{"26":1}}],["每个表的文件表空间包含单个innodb表的数据和索引",{"2":{"277":1}}],["每个页的大小默认为16kb",{"2":{"274":1}}],["每个页包含了2",{"2":{"262":1}}],["每个",{"2":{"274":1}}],["每个节点最多存储4个key",{"2":{"256":1}}],["每个java对象都可以关联一个monitor对象",{"2":{"187":1}}],["每个thread对象",{"2":{"152":1}}],["每个线程的局部变量会存在栈中",{"2":{"150":1}}],["每个线程都对no进行了一次+1操作",{"2":{"144":1}}],["每个线程都可以独立执行不同的任务",{"0":{"11":1}}],["每个线程被调度的次数会降低",{"0":{"51":1}}],["每个进程都有一个唯一的进程标识符",{"0":{"9":1}}],["这与其他的数据库是相似的",{"2":{"267":1}}],["这会让索引变得很大",{"2":{"260":1}}],["这使得在笔记",{"2":{"215":1}}],["这就是传说中的",{"2":{"199":1}}],["这就好比买票不排队",{"2":{"197":1}}],["这就要说到no++操作不是原子的问题了",{"2":{"144":1}}],["这三个方法是java中实现管程技术的组成部分",{"2":{"187":1}}],["这三个操作都是原子的",{"2":{"144":1}}],["这里的排他时间要短的多",{"2":{"178":1}}],["这是最好的索引选择性",{"2":{"260":1}}],["这是不一定的",{"2":{"197":1}}],["这是我们可以获得的最细的粒度情况了",{"2":{"166":1}}],["这是我们尤其要注意使用inheritablethreadlocal的点",{"2":{"154":1}}],["这是因为",{"2":{"154":1}}],["这是一个原子操作",{"2":{"180":1}}],["这是一个",{"2":{"140":1}}],["这段代码中变量a和b",{"2":{"146":1}}],["这种方式尤其",{"2":{"283":1}}],["这种方法的优点是可以避免长时间等待队列中的任务被执行",{"2":{"139":1}}],["这种方法的优点是可以避免无限期地等待队列中的任务被执行",{"2":{"139":1}}],["这种情况即为using",{"2":{"262":1}}],["这种存储方式的表称为索引组织表",{"2":{"262":1}}],["这种数据结构就是索引",{"2":{"253":1}}],["这种内存结构会引起什么问题呢",{"2":{"145":1}}],["这个时间差存在的还是很明显的",{"2":{"198":1}}],["这个对象的内存分布是和jvm的实现有关",{"2":{"189":1}}],["这个过程中涉及到操作系统用户模式和内核模式的转换",{"2":{"182":1}}],["这个过程可以参考下图",{"2":{"144":1}}],["这个写回内存的操作会引起在其他cpu里缓存了该内存地址的数据无效",{"2":{"160":1}}],["这个方法用于从工作队列中获取一个任务",{"2":{"140":1}}],["这个方法主要分为以下几个部分",{"2":{"140":1}}],["这时mark",{"2":{"191":1}}],["这时将偏向锁升级为00轻量级锁",{"2":{"191":1}}],["这时线程b对",{"2":{"144":1}}],["这时sleep方法",{"2":{"62":1}}],["这可以由调用代码捕获并处理",{"2":{"139":1}}],["这样可以极大地提高数据库的性能",{"2":{"278":1}}],["这样可以大大节约索引空间",{"2":{"260":1}}],["这样就可以在这些数据结构上实现高级查找算法",{"2":{"253":1}}],["这样提高了程序的执行效率",{"2":{"203":1}}],["这样的话",{"2":{"183":1}}],["这样原子性",{"2":{"146":1}}],["这样task1中",{"2":{"146":1}}],["这样频繁创建线程就会人人降低系统的效率",{"0":{"108":1}}],["这样实现起来非常简便",{"0":{"107":1}}],["这样多个程序便可以同日丸行",{"0":{"29":1}}],["这两件事情可以同时执行",{"0":{"35":1}}],["这些数据结构以某种方式引用",{"2":{"253":1}}],["这些插件在知识库中参与了文档格式化",{"2":{"206":1}}],["这些会在后边的文章中慢慢研究",{"2":{"146":1}}],["这些同一时刻的程序可以分配到多个处理器上",{"0":{"29":1}}],["这些纤程之间可以共享同一个线程资源",{"0":{"15":1}}],["这在单cpu系统中",{"0":{"26":1}}],["底层采用链表数据结构管理page",{"2":{"275":1}}],["底层数据结构是用哈希表实现的",{"2":{"256":1}}],["底层实现即为cpu指令cmpxchg",{"2":{"178":1}}],["底层实现主要通过汇编lock前缀指令",{"2":{"160":1}}],["底层",{"0":{"26":1,"29":1,"32":1}}],["底层角度",{"0":{"11":1,"14":1}}],["不开启",{"2":{"283":1}}],["不通过索引条件检索数据",{"2":{"272":1}}],["不加锁",{"2":{"280":2}}],["不加任何锁",{"2":{"272":1}}],["不加引号",{"2":{"260":1}}],["不含该记录",{"2":{"272":1}}],["不包含sql语句",{"2":{"266":1}}],["不执行逻辑",{"2":{"265":1}}],["不保存查询的结果",{"2":{"264":1}}],["不保证可见性",{"2":{"168":1}}],["不是用户定义的",{"2":{"265":1}}],["不是针对记录加的锁",{"2":{"262":1}}],["不是整个程序的就全局变量",{"2":{"152":1}}],["不取值",{"2":{"262":1}}],["不为null",{"2":{"262":1}}],["不需要额外排序",{"2":{"262":1}}],["不需要操作系统介入",{"0":{"16":1}}],["不要在索引列上进行运算操作",{"2":{"260":1}}],["不同的隔离级别",{"2":{"280":1}}],["不同的存储引擎有不同的结构",{"2":{"256":1}}],["不同事务或相同事务对同一条记录进行修改",{"2":{"280":1}}],["不同cpu硬件对于jvm的内存屏障规范实现指令不一样",{"2":{"161":1}}],["不支持语句级触发",{"2":{"267":1}}],["不支持范围查询",{"2":{"256":2}}],["不支持行锁",{"2":{"247":1}}],["不支持外键",{"2":{"247":1}}],["不支持事务",{"2":{"247":1}}],["不在指定的集合范围之内",{"2":{"232":1}}],["不可以访问该版本",{"2":{"280":1}}],["不可以对元数据进行写入操作",{"2":{"271":1}}],["不可重复读",{"2":{"239":1}}],["不可中断",{"2":{"204":1}}],["不可分割",{"2":{"166":1}}],["不指定时间需要被别人中断",{"2":{"184":1}}],["不设置将一直休眠",{"2":{"184":1}}],["不如锁的特点能够使其读操作的性能大幅提升",{"2":{"176":1}}],["不调用remove方法",{"2":{"153":1}}],["不过默认是非公平锁",{"2":{"193":1}}],["不过本质是空间换时间",{"2":{"172":1}}],["不过原子类相对于锁有一点的优势",{"2":{"166":1}}],["不过进行了指令重排之后呢",{"2":{"146":1}}],["不过合在一起就不行了",{"2":{"144":1}}],["不一样",{"2":{"144":1}}],["不能来了",{"2":{"196":1}}],["不能获取到操作过程中的中间值",{"2":{"144":1}}],["不能再同时打开微信",{"0":{"32":1}}],["不处理已添加的任务",{"2":{"141":1}}],["不接收新任务",{"2":{"141":2}}],["不会直接操作磁盘",{"2":{"276":1}}],["不会因为之前已经获取过还没释放而阻塞",{"2":{"192":1}}],["不会造成所谓的数据不一致问题",{"2":{"178":1}}],["不会立马抛出异常",{"2":{"127":1}}],["不会立马停止正在执行的线程",{"2":{"126":2}}],["不会停止线程",{"0":{"65":1}}],["不仅会销耗系统资源",{"0":{"118":1}}],["不至于后面来的客户闹情绪",{"0":{"25":1}}],["317",{"2":{"196":1}}],["32和intel",{"2":{"159":1,"160":1}}],["30",{"2":{"136":2}}],["3000l",{"2":{"136":1}}],["3",{"0":{"25":1,"49":1,"102":1},"2":{"127":1,"141":3,"160":1,"169":3,"172":3,"184":1,"187":1,"193":1,"204":1,"262":4}}],["轮流炒第2",{"0":{"25":1}}],["再将合并后的数据刷新到磁盘中",{"2":{"276":1}}],["再将数据合并恢复到buffer",{"2":{"276":1}}],["再执行循环体中的sql语句",{"2":{"265":1}}],["再次查看sql的耗时",{"2":{"260":1}}],["再并发条件下要求数据一致性",{"2":{"250":1}}],["再进入该线程的内层方法会自动获取锁",{"2":{"192":1}}],["再从队列中取出任务来执行",{"0":{"114":1}}],["再回到runnable状态",{"0":{"88":1}}],["再",{"0":{"25":1}}],["然后再以一定频率刷新到磁盘",{"2":{"275":1}}],["然后再次执行相同的sql语句",{"2":{"260":1}}],["然后这个隐藏列就相当于一个指针",{"2":{"274":1}}],["然后判定逻辑是否满足",{"2":{"265":1}}],["然后累积计数",{"2":{"262":1}}],["然后通过如下指令查看指令的执行耗时",{"2":{"259":1}}],["然后存储在hash表中",{"2":{"256":1}}],["然后调用interrupt",{"2":{"204":1}}],["然后释放同步状态",{"2":{"198":1}}],["然后唤醒entrylist中等待的线程来竞争锁",{"2":{"187":1}}],["然后不断的判断是否能够成功获取",{"2":{"182":1}}],["然后在排序缓冲区sort",{"2":{"262":1}}],["然后在争夺到锁资源后恢复为runnable状态",{"2":{"182":1}}],["然后在同步到主内存中",{"2":{"145":1}}],["然后在线程创建后启动这些任务",{"0":{"114":1}}],["然后同步到内存中",{"2":{"145":1}}],["然后a将2赋值给no",{"2":{"144":1}}],["然后做no+1",{"2":{"144":1}}],["然后重新尝试执行任务",{"2":{"135":1}}],["然后抢夺锁成功后",{"0":{"88":1}}],["然后进程可以创建线程",{"0":{"21":1}}],["然而一颗cpu同时只能执行一项任务",{"0":{"44":1}}],["然",{"0":{"25":1}}],["却只有一个厨师",{"0":{"25":1}}],["串行执行",{"0":{"124":1}}],["串行就很好理解了",{"0":{"31":1}}],["串行",{"0":{"23":1,"30":1},"1":{"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":2,"32":2,"33":2,"34":2,"35":2,"36":2,"38":1,"39":1,"40":1,"42":1,"43":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1,"50":1,"51":1,"53":1,"54":1,"55":1,"57":1,"58":1,"59":1,"60":1,"62":1,"65":1,"66":1,"67":1,"68":1,"69":1,"70":1,"74":1,"75":1,"76":1,"77":1}}],["并不会立即删除undo",{"2":{"279":1}}],["并存储在文件系统上的单个数据文件中",{"2":{"277":1}}],["并每秒刷新到磁盘一次",{"2":{"276":1}}],["并锁住数据前面的间隙gap",{"2":{"272":1}}],["并非实际使用长度",{"2":{"259":1}}],["并回写到主内存",{"2":{"160":1}}],["并设置为非守护线程",{"2":{"140":1}}],["并在必要时中断线程",{"2":{"140":1}}],["并重新尝试执行被拒绝的任务",{"2":{"139":1}}],["并启动新线程",{"2":{"97":1}}],["并实现call方法",{"2":{"97":1}}],["并清除当前中断状态",{"0":{"67":1}}],["并执行其他线程",{"2":{"63":1}}],["并发度最高",{"2":{"272":1}}],["并发度最低",{"2":{"271":1}}],["并发性要求不是很高",{"2":{"250":1}}],["并发事务问题",{"0":{"239":1}}],["并发编程三大特性",{"2":{"161":1}}],["并发编程下的性能优化往往和cpu核心数密切相关",{"0":{"40":1}}],["并发的是同一时间段内宏观上有多个程序同时运行",{"0":{"26":1}}],["并发是多个客户在同一时间段内不约而同来到饭店",{"0":{"25":1}}],["并发",{"0":{"23":1,"24":1,"34":1},"1":{"24":1,"25":2,"26":2,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1,"33":1,"34":1,"35":1,"36":1}}],["并行parallel",{"0":{"35":1}}],["并行处理的程序越多",{"0":{"29":1}}],["并行是多个客户在同一时刻一起来到饭店",{"0":{"28":1}}],["并行",{"0":{"23":1,"27":1},"1":{"24":1,"25":1,"26":1,"27":1,"28":2,"29":2,"30":1,"31":1,"32":1,"33":1,"34":1,"35":1,"36":1}}],["并且以相对随机的顺序插入二级索引",{"2":{"276":1}}],["并且是在使用视图动态生成的",{"2":{"264":1}}],["并且该索引不能失效",{"2":{"262":1}}],["并且需要返回的列",{"2":{"260":1}}],["并且事务的完整性",{"2":{"250":1}}],["并且处于不可偏向状态",{"2":{"191":1}}],["并且锁对象始终保持对该线程的偏向",{"2":{"191":1}}],["并且4种状态会随着竞争的情况逐渐升级",{"2":{"188":1}}],["并且会中断正在处理的任务",{"2":{"141":1}}],["并且线程池中的任务数为0",{"2":{"141":1}}],["并且当前工作的worker数量大于1或工作队列为空",{"2":{"140":1}}],["并且工作队列为空",{"2":{"140":1}}],["并且不跳过索引中的列",{"2":{"260":1}}],["并且不会增加系统资源的消耗",{"2":{"139":1}}],["并且不产生任何异常或通知",{"2":{"139":1}}],["并且能在主线程捕捉到",{"2":{"127":1}}],["并且代表线程池也已经执行完毕",{"2":{"126":1}}],["并且每个线程都是执行一个时间很短的任务就结束了",{"0":{"108":1}}],["并且有一个返回v",{"0":{"97":1}}],["并且正式java的虚拟线程的开发者",{"0":{"19":1}}],["并且保证程序",{"0":{"6":1}}],["但不包含写入数据的语句",{"2":{"266":1}}],["但不能授权到数据库特定行和特定的列上",{"2":{"264":1}}],["但不取值",{"2":{"262":1}}],["但两次读取的数据不同",{"2":{"239":1}}],["但并没有在对象上并发的获取锁时",{"2":{"191":1}}],["但之后已复制上下文的核心线程不会回收的情况下",{"2":{"154":1}}],["但线程池中的线程不会回收",{"2":{"153":1}}],["但能处理已添加的任务",{"2":{"141":1}}],["但有返回结果",{"0":{"96":1}}],["但提高并发并不意味着启动更多的线程来执行",{"0":{"42":1}}],["但intel引入超线程技术后",{"0":{"38":1}}],["但是会阻塞写",{"2":{"271":1}}],["但是需要的数据都在索引列中能找到",{"2":{"260":1}}],["但是需要回表查询",{"2":{"260":1}}],["但是需要注意的是",{"2":{"180":1}}],["但是在插入数据时",{"2":{"239":1}}],["但是也浪费了一定的资源",{"2":{"203":1}}],["但是从cpu的角度来看",{"2":{"198":1}}],["但是wait需要",{"2":{"184":1}}],["但是wait需要依赖synchronized关键字",{"2":{"184":1}}],["但是wait会释放",{"2":{"184":1}}],["但是wait是object中的方法",{"2":{"184":1}}],["但是自旋锁不会引起调用者堵塞",{"2":{"182":1}}],["但是仍然会输出旧的年龄",{"2":{"171":1}}],["但是它能完成类似内存屏障的功能",{"2":{"161":1}}],["但是不保证原子性",{"2":{"161":1}}],["但是不抛出异常",{"2":{"135":1}}],["但是严格意义上讲executor并不是一个线程池",{"0":{"120":1}}],["但是就会有一个问题",{"0":{"107":1}}],["但是如果对一些场合需要线程返回的结果",{"0":{"96":1}}],["但是如果想进入其他状态就相对比较特殊",{"0":{"84":1}}],["但是对于timed",{"0":{"89":1}}],["但是",{"2":{"63":1}}],["但是后面的客户就要等得比较久了",{"0":{"31":1}}],["但是都想快点上菜",{"0":{"25":1}}],["但是要注意资源竞争的问题",{"0":{"22":1}}],["但它们共享进程的资源",{"0":{"11":1}}],["总结",{"0":{"20":1,"46":1,"91":1},"1":{"21":1,"22":1,"92":1,"93":1,"94":1,"96":1,"97":1,"99":1,"100":1,"101":1,"102":1}}],["据说这个大神已经入职oracle了",{"0":{"19":1}}],["jerry",{"2":{"262":4}}],["join",{"2":{"191":1,"225":1,"226":2,"227":1}}],["jol",{"2":{"189":1}}],["jdk中偏向锁存在延迟4秒启动",{"2":{"191":1}}],["jvm为了提高锁的获取与释放效率",{"2":{"188":1}}],["jvm",{"2":{"180":1}}],["jvm底层简化了内存屏障硬件指令的实现",{"2":{"161":1}}],["jmm缓存不一致问题",{"0":{"159":1}}],["jmm数据原子操作",{"0":{"158":1}}],["jmm内存模型",{"0":{"157":1}}],["jmm内存模型怎么回事",{"0":{"156":1},"1":{"157":1}}],["javaimport",{"2":{"196":1}}],["java\\tpublic",{"2":{"195":1}}],["java\\tprivate",{"2":{"141":1}}],["java\\tnew",{"2":{"191":1}}],["javat",{"2":{"190":1}}],["javatry",{"2":{"126":1}}],["javaclass",{"2":{"189":1}}],["javasynchronized",{"2":{"187":1}}],["java对象于monitor之间的关系",{"2":{"187":1}}],["java内置锁还是一个重量级锁",{"2":{"186":1}}],["java原子类中的递增操作就通过cas自旋实现的",{"2":{"176":1}}],["java8引入的",{"2":{"172":1}}],["java规定volatile需要实现的内存屏障",{"0":{"165":1},"1":{"167":1}}],["java规范定义的内存屏障",{"0":{"164":1}}],["java程序汇编代码查看",{"2":{"160":1}}],["javaprivate",{"2":{"140":2,"141":1}}],["javapublic",{"2":{"62":1,"96":1,"97":1,"136":1,"137":1,"139":4,"144":1,"146":1,"152":2,"153":1,"154":2,"155":1,"157":1,"162":1,"168":1,"169":1,"170":1,"171":1,"172":1,"175":1,"177":1,"178":1,"191":2,"197":1}}],["javafinal",{"2":{"140":1}}],["javaarrayblockingqueue",{"2":{"138":1}}],["java类库提供了许多静态方法创建一个线程池",{"0":{"121":1}}],["java里面线程池的顶级接口是java",{"0":{"120":1}}],["java中",{"0":{"104":1}}],["java中有三种线程创建方式",{"0":{"99":1}}],["java线程创建调用关系",{"0":{"55":1}}],["java",{"2":{"54":1,"127":1,"146":3,"166":1,"176":1,"180":1,"196":13}}],["java19才支持虚拟线程",{"0":{"18":1}}],["juc",{"2":{"180":1}}],["juc就是在并发场景下",{"0":{"6":1}}],["juc是java",{"0":{"5":1}}],["如",{"2":{"280":1}}],["如02000",{"2":{"265":1}}],["如身份证号",{"2":{"262":1}}],["如对表进行insert",{"2":{"255":1}}],["如下图",{"2":{"183":1}}],["如compareandswqpxxx",{"2":{"178":1}}],["如cpu",{"0":{"9":1}}],["如何保证数据并发访问的一致性",{"2":{"269":1}}],["如何解决线程不安全",{"0":{"147":1},"1":{"148":1,"149":1,"150":1}}],["如何让用户感觉这些任务正在同时进行呢",{"0":{"44":1}}],["如单核cpu",{"0":{"32":1}}],["如果需要导入sql文件",{"2":{"283":1}}],["如果需要更新",{"2":{"276":1}}],["如果trx",{"2":{"280":1}}],["如果thread",{"2":{"187":1}}],["如果表结构没有指定主键",{"2":{"280":1}}],["如果表是在系统表空间而不是每个表文件或通用表空间中创建的",{"2":{"277":1}}],["如果表没有主键",{"2":{"257":1}}],["如果观察到hash索引可以提升速度",{"2":{"276":1}}],["如果每一次都操作磁盘",{"2":{"276":1}}],["如果这些数据page没有在buffer",{"2":{"276":1}}],["如果这个数据没有被更新",{"2":{"176":1}}],["如果在从库上备份",{"2":{"270":1}}],["如果在主库上备份",{"2":{"270":1}}],["如果在线程池中使用threadlocal会造成内存泄漏",{"2":{"153":1}}],["如果满足",{"2":{"265":1}}],["如果条件为true",{"2":{"265":1}}],["如果没有指定schema",{"2":{"267":1}}],["如果没有session",{"2":{"265":1}}],["如果没有待处理的任务",{"2":{"140":1}}],["如果视图包含以下任何一项",{"2":{"264":1}}],["如果count函数的参数不是null",{"2":{"262":1}}],["如果cas长时间一直不成功",{"2":{"181":1}}],["如果cas失败",{"2":{"181":1}}],["如果索引列不能存储null值",{"2":{"261":1}}],["如果索引了多列",{"2":{"260":1}}],["如果mysql评估使用索引比全表更慢",{"2":{"260":1}}],["如果or前的条件中的所有列有索引",{"2":{"260":1}}],["如果仅仅是尾部模糊匹配",{"2":{"260":1}}],["如果跳跃某一列",{"2":{"260":1}}],["如果为null",{"2":{"259":1}}],["如果为了更高的吞吐量",{"2":{"200":1}}],["如果存在多个查询条件",{"2":{"260":1}}],["如果存在多个程",{"0":{"32":1}}],["如果存在主键",{"2":{"257":1}}],["如果两个",{"2":{"256":1}}],["如果应用是以读操作和插入操作为主",{"2":{"250":1}}],["如果尝试获取不到锁",{"2":{"204":1}}],["如果锁被占用",{"2":{"195":1}}],["如果锁已经被其它线程获取",{"2":{"182":1}}],["如果获取锁的时间能够设置超时时间",{"2":{"194":1}}],["如果之后有线程再尝试获取user对象的锁",{"2":{"191":1}}],["如果上面的字节相加后不能被8整除",{"2":{"189":1}}],["如果了解对象的内存布局的可以忽略此段",{"2":{"189":1}}],["如果使用synchronized给对象加锁",{"2":{"187":1}}],["如果自旋锁已经被别人的执行单元保持",{"2":{"182":1}}],["如果知道",{"0":{"180":1}}],["如果相匹配",{"2":{"178":1}}],["如果相同就设置新值",{"2":{"168":1}}],["如果数据已经被其他线程更新",{"2":{"176":1}}],["如果我们过于信任它的传递能力",{"2":{"154":1}}],["如果你等了半小时朋友还没到",{"2":{"196":1}}],["如果你创建了一个threadlocal变量",{"2":{"152":1}}],["如果你开两个线程执行",{"0":{"34":1}}],["如果弄不清楚原子性和可见性的区别",{"2":{"146":1}}],["如果是字符串类型的字段",{"2":{"261":1}}],["如果是头部模糊匹配",{"2":{"260":1}}],["如果是应用对事物的完整性有比较高的要求",{"2":{"250":1}}],["如果是1个有synchronized修饰的递归调用方法",{"2":{"192":1}}],["如果是就给总线加锁",{"2":{"178":1}}],["如果是jdk8",{"2":{"172":1}}],["如果是count++操作",{"2":{"172":1}}],["如果是多线程呢",{"2":{"146":1}}],["如果是突然退出",{"2":{"140":1}}],["如果一行数据多大",{"2":{"262":1}}],["如果一次性需要插入大批量数据",{"2":{"262":1}}],["如果一个线程正在等待获取锁",{"2":{"196":1}}],["如果一个线程在等待获取锁",{"2":{"196":1}}],["如果一个类既要继承其它的类",{"0":{"104":1}}],["如果一个类继承了thread类",{"0":{"104":1}}],["如果一致那么可以直接获取",{"2":{"191":1}}],["如果一致",{"2":{"144":1}}],["如果不在sql逻辑中增加退出循环的条件",{"2":{"265":1}}],["如果不满足",{"2":{"265":1}}],["如果不可避免的出现filesort",{"2":{"262":1}}],["如果不存在主键",{"2":{"257":1}}],["如果不安装可能会导致无法正常渲染和阅读",{"2":{"206":1}}],["如果不这样",{"2":{"203":1}}],["如果不熟悉其实现机制和使用场景的话很容易引发难以察觉的安全隐患和性能问题",{"2":{"180":1}}],["如果不匹配",{"2":{"178":1}}],["如果不理解cpu缓存这部分内容的话",{"2":{"145":1}}],["如果不能保证原子性会有什么问题呢",{"2":{"144":1}}],["如果不是突然退出",{"2":{"140":1}}],["如果破坏其原子性",{"2":{"143":1}}],["如果当前线程1获得锁",{"2":{"204":1}}],["如果当前线程池的规模超出了处理需求",{"0":{"123":1}}],["如果当前工作线程数量大于等于最小值",{"2":{"140":1}}],["如果最小值为0且工作队列不为空",{"2":{"140":1}}],["如果工作队列为空",{"2":{"140":1}}],["如果无限制的创建",{"0":{"118":1}}],["如果并发的线程数量很多",{"0":{"108":1}}],["如果返回的结果是true则为守护线程",{"0":{"76":1}}],["如果线程1阻塞",{"2":{"204":1}}],["如果线程池状态至少为shutdown",{"2":{"140":1}}],["如果线程池正在停止或线程被中断并且线程池至少处于stop状态",{"2":{"140":1}}],["如果线程数量超过了最大数量",{"0":{"114":1}}],["如果线程数非常多",{"0":{"50":1}}],["如果线程是饭桌",{"0":{"17":1}}],["如果第一个客户吃的是满汉全席后面的客户可能就不想等了",{"0":{"31":1}}],["21",{"2":{"262":2}}],["2或者strong",{"2":{"251":1}}],["25",{"2":{"196":1}}],["2bit",{"2":{"190":1,"191":1}}],["2执行完同步代码块的内容",{"2":{"187":1}}],["2执行synchronized",{"2":{"187":1}}],["2上锁的过程中",{"2":{"187":1}}],["22",{"2":{"170":1}}],["2020",{"2":{"178":1}}],["2000000",{"2":{"262":1}}],["20000000",{"2":{"262":1}}],["2000010的记录",{"2":{"262":1}}],["2000",{"2":{"155":1,"157":1}}],["20",{"2":{"136":3,"170":1,"264":1}}],["2步",{"2":{"97":1}}],["2的关系",{"0":{"38":1}}],["2",{"0":{"16":1,"22":1,"48":1,"54":1,"70":1,"101":1},"2":{"127":1,"141":7,"144":1,"145":1,"146":2,"160":1,"168":1,"169":4,"184":1,"187":1,"191":2,"193":1,"196":2,"198":1,"204":2,"221":2,"262":4,"265":1,"276":1}}],["15",{"2":{"262":2,"264":1}}],["1或者medium",{"2":{"251":1}}],["16k",{"2":{"246":1}}],["1m",{"2":{"246":1}}],["1700663163724",{"2":{"195":2}}],["1700663163568",{"2":{"195":1}}],["1是之前获得过锁的线程",{"2":{"187":1}}],["1263",{"2":{"196":1}}],["12",{"2":{"168":2}}],["11",{"2":{"168":1,"171":1}}],["1预期值",{"2":{"168":1}}],["1024",{"2":{"153":2,"178":1}}],["10000",{"2":{"154":2}}],["10000003145001",{"2":{"260":2}}],["1000000",{"2":{"152":2}}],["1000",{"2":{"144":1}}],["100",{"2":{"136":1,"153":1}}],["10个顾客请求",{"2":{"136":1}}],["10",{"2":{"136":4,"138":1,"168":5,"171":2,"262":2,"264":1}}],["1",{"0":{"15":1,"21":1,"47":1,"53":1,"69":1,"100":1},"2":{"127":1,"136":1,"140":2,"141":10,"144":1,"145":1,"146":2,"153":1,"160":1,"165":18,"168":2,"169":8,"172":3,"184":1,"191":1,"193":1,"196":5,"198":1,"204":2,"221":5,"260":1,"262":8,"276":1,"278":2}}],["1的关系",{"0":{"12":1,"38":1}}],["专业说法",{"0":{"9":1}}],["纤程之间共享全局变量",{"0":{"22":1}}],["纤程是在同一个进程內部运行的",{"0":{"16":1}}],["纤程可以在内部创建多个纤程",{"0":{"15":1}}],["纤程",{"0":{"7":1,"18":1},"1":{"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1}}],["线程类型",{"2":{"278":1}}],["线程可以不用一直等待就结束了",{"2":{"204":1}}],["线程调用interrupt",{"2":{"196":1}}],["线程采取cas的自旋方式尝试获取锁",{"2":{"191":1}}],["线程会进入waiting无限时等待状态",{"2":{"184":1}}],["线程进入状态不同",{"2":{"184":1}}],["线程不被回收",{"2":{"153":1}}],["线程不安全",{"2":{"143":1}}],["线程2则会一直等待下去",{"2":{"204":1}}],["线程2线程等待",{"2":{"204":1}}],["线程2",{"2":{"152":1,"155":1}}],["线程1首先请求锁a",{"2":{"197":1}}],["线程1",{"2":{"152":1,"155":1}}],["线程解锁是",{"2":{"145":1}}],["线程在加锁时",{"2":{"145":1}}],["线程a对var做了一次修改",{"2":{"145":1}}],["线程a读取no值是1",{"2":{"144":1}}],["线程变量的可见性问题",{"2":{"145":1}}],["线程中的任务",{"2":{"140":1}}],["线程工厂",{"0":{"134":1}}],["线程复用",{"0":{"115":1}}],["线程池彻底终止",{"2":{"141":1}}],["线程池中的线程上下文将不会再被改变",{"2":{"154":1}}],["线程池中执行的任务为空时",{"2":{"141":1}}],["线程池中一直占用系统资源",{"2":{"126":1}}],["线程池会变为tidying状态",{"2":{"141":1}}],["线程池由",{"2":{"141":1}}],["线程池由running",{"2":{"141":1}}],["线程池处在tidying状态时",{"2":{"141":1}}],["线程池处在stop状态时",{"2":{"141":1}}],["线程池处在shutdown状态时",{"2":{"141":1}}],["线程池处在running状态时",{"2":{"141":1}}],["线程池被一旦被创建",{"2":{"141":1}}],["线程池五种状态",{"0":{"141":1}}],["线程池状态至少为stop",{"2":{"140":1}}],["线程池淘汰策略",{"0":{"140":1}}],["线程池拒绝策略",{"0":{"139":1}}],["线程池如何创建线程",{"0":{"138":1}}],["线程池参数",{"0":{"128":1},"1":{"129":1,"130":1,"131":1,"132":1,"133":1,"134":1,"135":1}}],["线程池规模无限制",{"0":{"123":1}}],["线程池的初始化状态是running",{"2":{"141":1}}],["线程池的关闭",{"0":{"126":1}}],["线程池的规模将不再变化",{"0":{"122":1}}],["线程池的使用",{"0":{"119":1},"1":{"120":1,"121":1,"122":1,"123":1,"124":1,"125":1}}],["线程池的优势",{"0":{"113":1},"1":{"114":1,"115":1,"116":1,"117":1,"118":1,"120":1,"121":1,"122":1,"123":1,"124":1,"125":1,"129":1,"130":1,"131":1,"132":1,"133":1,"134":1,"135":1}}],["线程池做的工作丰要是控制运行的线程数量",{"0":{"114":1}}],["线程池",{"0":{"111":1}}],["线程生命周期不可逆",{"0":{"93":1}}],["线程状态间转换",{"0":{"82":1},"1":{"83":1,"84":1,"85":1,"86":1,"87":1,"88":1,"89":1,"90":1,"91":1,"92":1,"93":1,"94":1}}],["线程合并",{"0":{"71":1}}],["线程打断",{"0":{"64":1},"1":{"65":1,"66":1,"67":1,"68":1,"69":1,"70":1}}],["线程数量方面",{"0":{"59":1}}],["线程的中断标志会被清空",{"2":{"196":1}}],["线程的中断标志会被置为true",{"2":{"196":1}}],["线程的退出",{"2":{"140":1}}],["线程的3种创建方式",{"0":{"98":1},"1":{"99":1,"100":1,"101":1,"102":1,"103":1,"104":1,"105":1}}],["线程的状态是按照箭头方向来走的",{"0":{"92":1}}],["线程的5种状态",{"0":{"81":1}}],["线程的让步",{"0":{"63":1}}],["线程的休眠",{"0":{"61":1},"1":{"62":1}}],["线程的执行效率降低",{"0":{"51":1}}],["线程的串行亦是如此",{"0":{"32":1}}],["线程里面可以包含多个协程",{"0":{"21":1}}],["线程是稀缺资源",{"0":{"118":1}}],["线程是cpu调度的最小单位",{"0":{"38":1}}],["线程是依附在进程里面的",{"0":{"21":1}}],["线程是操作系统中的基本执行单元",{"0":{"11":1}}],["线程",{"0":{"7":1,"45":1},"1":{"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1}}],["线程安全",{"0":{"6":1,"142":1},"1":{"143":1,"144":1,"145":1,"146":1}}],["city",{"2":{"283":1}}],["cnf中配置",{"2":{"265":1}}],["cleaner",{"2":{"278":1}}],["clean",{"2":{"275":1}}],["clustered",{"2":{"257":1}}],["classlayout",{"2":{"190":1,"191":2}}],["class",{"2":{"62":1,"97":2,"136":2,"139":4,"144":1,"146":1,"152":2,"153":1,"154":2,"155":1,"157":1,"162":1,"171":1,"177":1,"178":1,"195":1,"196":2}}],["ceil",{"2":{"221":1}}],["creator",{"2":{"280":2}}],["creating",{"2":{"209":1}}],["create",{"2":{"218":3,"221":1,"243":1,"260":1,"262":2,"264":1,"265":1,"266":1,"277":2,"283":2}}],["createmap",{"2":{"152":1}}],["creates",{"2":{"139":4}}],["ck需在fina日y中手工释放锁",{"2":{"204":1}}],["cmpxchg指令",{"2":{"178":1}}],["change",{"2":{"218":1,"276":2}}],["characteristic说明",{"2":{"266":1}}],["characteristic",{"2":{"266":1}}],["charset",{"2":{"218":1}}],["char",{"2":{"165":1,"265":1}}],["chinese",{"0":{"213":1},"2":{"213":1}}],["checked",{"2":{"162":1}}],["check",{"2":{"140":1,"222":1,"264":7}}],["ctos",{"2":{"165":2}}],["ctl记录的",{"2":{"141":1}}],["ctlof",{"2":{"141":2}}],["ctl",{"2":{"140":4,"141":2}}],["c++if",{"2":{"165":1}}],["c1",{"2":{"155":1}}],["c=",{"2":{"146":2}}],["curtime",{"2":{"221":1}}],["curdate",{"2":{"221":1}}],["cursor",{"0":{"215":1},"2":{"215":2,"265":2}}],["currenttimemillis",{"2":{"195":3}}],["currentthread",{"2":{"136":1,"140":1,"152":1}}],["culling",{"2":{"140":1}}],["customethreadpool",{"2":{"136":1,"152":1}}],["c2",{"2":{"136":1,"152":1}}],["col",{"2":{"258":1,"283":1}}],["column3=value3",{"2":{"262":1}}],["column2=value2",{"2":{"262":1}}],["column1=value1",{"2":{"262":2}}],["column1",{"2":{"229":2}}],["column",{"2":{"218":2,"260":1}}],["collate",{"2":{"218":1}}],["com",{"2":{"259":1}}],["committed",{"2":{"240":1,"280":2}}],["commit",{"2":{"237":1,"262":1,"276":1}}],["comment",{"2":{"218":3,"243":3}}],["command+shift+6",{"2":{"209":1}}],["compare",{"2":{"176":1,"178":1,"180":1}}],["compareandswapobject",{"2":{"179":3}}],["compareandset",{"2":{"168":3,"169":3,"170":3,"178":2,"179":1}}],["compareanddecrementworkercount",{"2":{"140":1}}],["compilecommand=compileonly",{"2":{"160":1}}],["completedtasks",{"2":{"140":1}}],["completedtasks++",{"2":{"140":1}}],["completedtaskcount",{"2":{"140":1}}],["completedabruptly",{"2":{"140":6}}],["core",{"2":{"189":1}}],["corepoolsize",{"0":{"129":1},"2":{"140":2}}],["count的几种方法",{"2":{"262":1}}],["count优化",{"2":{"262":1}}],["count",{"0":{"214":1},"2":{"141":8,"172":2,"214":1,"220":2,"260":4,"262":16,"264":1,"283":4}}],["code",{"2":{"139":4}}],["consistency",{"2":{"279":1}}],["const",{"2":{"259":1}}],["condition2",{"2":{"265":1}}],["condition1",{"2":{"265":1}}],["condition",{"2":{"260":1,"265":3}}],["config",{"2":{"259":1}}],["conf",{"2":{"259":1}}],["concurrency",{"2":{"280":1}}],["concurrent",{"0":{"34":1,"120":3},"2":{"166":1,"196":5}}],["concurrent包的缩写",{"0":{"5":1}}],["concat",{"2":{"221":1}}],["control",{"2":{"280":1}}],["content",{"2":{"207":1}}],["context",{"0":{"41":1},"1":{"42":1,"43":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1,"50":1,"51":1}}],["continue",{"2":{"140":1}}],["cat",{"2":{"262":4}}],["catch",{"2":{"97":2,"126":2,"136":2,"140":2,"191":3,"195":1,"196":1}}],["card",{"2":{"165":2}}],["cardtablemodrefbs",{"2":{"165":2}}],["cache",{"2":{"165":1}}],["cascaded",{"2":{"264":3}}],["cascaded和local",{"2":{"264":1}}],["cascaded|local",{"2":{"264":3}}],["cas自选锁属于乐观",{"2":{"182":1}}],["cas的缺点",{"0":{"181":1}}],["cas底层原理",{"0":{"180":1}}],["casdemo",{"2":{"178":1}}],["cas是一条cpu的原子指令",{"2":{"178":1}}],["cas是什么",{"0":{"178":1}}],["cas有3个操作数",{"2":{"178":1}}],["cas",{"0":{"177":1},"1":{"178":1,"179":1,"180":1,"181":1},"2":{"146":1,"176":1,"180":2}}],["cas算法",{"2":{"143":1}}],["case",{"2":{"139":2,"221":4,"265":4}}],["caller",{"2":{"139":1}}],["callerrunspolicy",{"2":{"135":1,"139":4}}],["call",{"2":{"96":1,"97":1}}],["callable",{"2":{"96":1,"97":2,"127":1}}],["callable只能executorservice的线程池中跑",{"0":{"96":1}}],["callable接口",{"0":{"95":1},"1":{"96":1,"97":1}}],["cpu硬件级内存屏障实现指令",{"2":{"161":1}}],["cpu处理完数据后会先放到缓存中",{"2":{"145":1}}],["cpu的读写性能上要大于内存",{"2":{"145":1}}],["cpu和内存之间隔着缓存和cpu寄存器",{"2":{"145":1}}],["cpu会在n个线程之间切换",{"0":{"50":1}}],["cpu调度线程的时间足够快",{"0":{"49":1}}],["cpu只能处理1个线程",{"0":{"47":1}}],["cpu核心数和线程的关系",{"0":{"37":1},"1":{"38":1,"39":1,"40":1}}],["cpu",{"0":{"29":1},"2":{"145":2,"259":1,"269":1}}],["c",{"0":{"4":1,"124":1},"1":{"5":1,"6":1},"2":{"140":8}}],["using",{"2":{"260":2,"262":2}}],["use",{"2":{"158":1,"218":1,"221":1,"260":2}}],["user=name\\t\\t\\t\\t指定用户名",{"2":{"283":1}}],["user=name",{"2":{"283":1}}],["user对象无线程竞争",{"2":{"191":1}}],["usertest",{"2":{"191":18}}],["userthreadlocal",{"2":{"152":5}}],["user",{"2":{"152":8,"170":12,"171":3,"217":1,"221":4,"260":2,"262":15}}],["user>",{"2":{"152":1,"170":1,"171":1}}],["upper",{"2":{"221":1}}],["update添加",{"2":{"271":1}}],["update型触发器",{"2":{"267":1}}],["update优化",{"2":{"262":1}}],["update",{"0":{"179":1},"2":{"219":1,"229":1,"255":1,"259":1,"262":1,"267":2,"271":3,"272":3,"280":2}}],["updateuser",{"2":{"170":4}}],["uintptr",{"2":{"165":2}}],["undo页的回收",{"2":{"278":1}}],["undo",{"2":{"277":1,"278":1,"279":7,"280":2}}],["undolog等",{"2":{"277":1}}],["undolog",{"2":{"276":1}}],["under",{"2":{"214":1}}],["uncommitted",{"2":{"240":1}}],["union或者union",{"2":{"264":1}}],["union中的第二个或者后面的查询语句",{"2":{"259":1}}],["union",{"2":{"228":3,"259":1}}],["unique|fulltext",{"2":{"258":1}}],["unique",{"2":{"222":1,"223":1,"257":2}}],["unit",{"0":{"132":1},"2":{"191":2,"204":1}}],["unsigned",{"2":{"218":1}}],["unsafe",{"2":{"180":5}}],["unsafe提供的cas方法",{"2":{"178":1}}],["unlock",{"2":{"140":3,"158":1,"175":1,"195":1,"196":2,"204":1,"271":1}}],["unless",{"2":{"139":2}}],["unpark",{"0":{"86":1,"90":1}}],["util",{"0":{"5":1,"120":3},"2":{"166":1,"196":5}}],["u",{"0":{"4":1},"1":{"5":1,"6":1},"2":{"183":1,"217":1,"262":1,"283":9}}],["笔记",{"0":{"2":1},"1":{"3":1}}],["📒",{"0":{"2":1},"1":{"3":1}}]],"serializationVersion":2}';export{t as default};
